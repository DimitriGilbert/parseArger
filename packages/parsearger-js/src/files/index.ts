// Auto-generated by embed-scripts.ts - do not edit manually
// Generated at: 2026-01-30T00:43:18.032Z
// Total files: 67

/**
 * Embedded parseArger bash scripts as a virtual filesystem map.
 * Keys are virtual paths, values are file contents.
 */
export const parseArgerFiles: Record<string, string> = {
  "/parseArger/parseArger": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"standalone bash argument parsing framework\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-set export PARSEARGER_ROOT_DIR=\"/parseArger\";\nexport PARSEARGER_ROOT_DIR=\"/parseArger\";\n# @parseArger-leftovers leftovers\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos target \"what to do\" --subcommand-directory \"bin\" --subcommand-use-leftovers --subcommand --one-of \"bulk-parse\" --one-of \"completely\" --one-of \"document\" --one-of \"generate\" --one-of \"html-form\" --one-of \"parse\" --one-of \"project\" --one-of \"parse_temp\"\n# @parseArger opt output \"create file with command output at value\" --complete \"file\"\n# @parseArger flag prepend \"add output on top of file\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_target=\"\";\n_one_of_arg_target=(\"bulk-parse\" \"completely\" \"document\" \"generate\" \"html-form\" \"parse\" \"project\" \"parse_temp\" );\n_arg_subcommand_arg=\"_arg_target\";\n__subcommand=();\n# OPTIONALS ARGUMENTS\n_arg_output=\n# FLAGS\n_arg_prepend=\"off\"\n# NESTED\n# LEFTOVERS\n_arg_leftovers=()\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [ \"$__cli_arg_count\" -ge 2 ]; then\n\t\t# echo \"$0 sub command help\n\t#\"\n\t\t_triggerSCHelp=0;\n\t\t_helpHasBeenPrinted=0;\n\telse\n\t\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"standalone bash argument parsing framework:\"\n\techo -e \"\ttarget: what to do [one of 'bulk-parse' 'completely' 'document' 'generate' 'html-form' 'parse' 'project' 'parse_temp']\"\n\techo -e \"\t--output <output>: create file with command output at value\"\n\techo -e \"\t--prepend|--no-prepend: add output on top of file\"\n\techo -e \"Usage :\n\t$0 <target> [--output <value>] [--[no-]prepend]\";\n\tfi\n\n\tfi\n\t\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--output)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_output=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--output=*)\n\t\t\t\t_arg_output=\"${_key##--output=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--prepend)\n\t\t\t\t_arg_prepend=\"on\"\n\t\t\t\t;;\n\t\t\t--no-prepend)\n\t\t\t\t_arg_prepend=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t--quiet)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"target\"\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_target \";\n\t_leftovers_count=$((${#_positionals[@]} - 1))\n\tfor ((ii = 0; ii < _leftovers_count; ii++));do\n\t\t_positional_names=\"$_positional_names _arg_leftovers[$((ii + 0))]\";\n\tdone\n\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\tif ! [[ \"$_positional_name\" =~ \"_arg_leftovers\" ]];then\n\t\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\t\tlocal _match_var=\"_match${_positional_name}\";\n\t\t\tlocal _regex=\"${!_match_var}\";\n\t\t\tif [ -n \"$_regex\" ]; then\n\t\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\t\tfi\n\t\t\t\n\t\t\tif [ \"$_arg_subcommand_arg\" == \"$_positional_name\" ];then\n\t\t\t\tif [ -f \"bin/${1}\" ];then\n\t\t\t\t\t__subcommand+=(\"bin/${1}\");\n\t\t\t\telif [ -f \"$_SCRIPT_DIR/bin/${1}\" ];then\n\t\t\t\t\t__subcommand+=(\"$_SCRIPT_DIR/bin/${1}\");\n\t\t\t\telif [[ \"bin/\" == $(basename \"$_SCRIPT_DIR\")* ]];then\n\t\t\t\t\tcmdToSub=\"$(basename \"$_SCRIPT_DIR\")\";\n\t\t\t\t\tcmdsubDir=\"bin/\";\n\t\t\t\t\t__subcommand+=(\"$_SCRIPT_DIR${cmdsubDir#\"${cmdToSub}\"}${1}\");\n\t\t\t\telse\n\t\t\t\t\t__subcommand+=(\"$_SCRIPT_DIR/bin/${1}\");\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\ttarget: ${_arg_target}\";\n\techo -e \"\toutput: ${_arg_output}\";\n\techo -e \"\tprepend: ${_arg_prepend}\";\n\techo -e \"\tleftovers: ${_arg_leftovers[*]}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n__subcommand+=(\"${_arg_leftovers[@]}\");\nif [ \"$_triggerSCHelp\" == \"0\" ];then\n\t__subcommand+=(\"--help\");\nfi\nif [ \"$_verbose_level\" -ne \"0\" ];then\n\t__subcommand+=(\"--verbose\" \"$_verbose_level\");\nfi\n\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\nif [ \"$_triggerSCHelp\" == \"0\" ]; then\n\t_arg_leftovers+=(\"--help\");\nfi\n\ncmdOutStr=$(set -- \"${__subcommand[@]:1}\"; source \"${__subcommand[0]}\");\n\nif [ \"$_arg_output\" == \"\" ]; then\n\techo -e \"${cmdOutStr}\";\nelse\n\toutput=\"${cmdOutStr}\";\n\t\n\tif [ \"$_arg_output\" != \"\" ]; then\n\t\tif [[ -f \"$_arg_output\" ]]; then\n\t\t\tif [ \"$_arg_prepend\" == \"on\" ]; then\n\t\t\t\toutput+=$(cat \"$_arg_output\");\n\t\t\telse\n\t\t\t\toutput=$(cat \"$_arg_output\")$output;\n\t\t\tfi\t\n\t\tfi\n\t\techo -e \"${output}\" > \"$_arg_output\";\n\t\tchmod +x \"$_arg_output\";\n\tfi\nfi  \n",
  "/parseArger/bin/utils": "#!/bin/bash\npaStart=\"# @parse\";\npaStart+=\"Arger\";\n\nparsearger_get_help() {\n  sed -ne 's/'\"${paStart}\"'-help \\(.*\\).*/\\1/p' \"$1\"\n}\nparsearger_get_version() {\n  sed -ne 's/'\"${paStart}\"'-version \\(.*\\).*/\\1/p' \"$1\"\n}\nparsearger_get_set() {\n  local -n _lset=$1;\n  readarray -t _lset <<< \"$(sed -ne 's/'\"${paStart}\"'-set \\(.*\\).*/\\1/p' \"$2\")\"\n}\nparsearger_get_leftovers() {\n  sed -ne 's/'\"${paStart}\"'-leftovers \\(.*\\).*/\\1/p' \"$1\" | awk '{print $1}'\n}\nparsearger_get_parse_leftovers() {\n  sed -ne 's/'\"${paStart}\"'-leftovers \\(.*\\).*/\\1/p' \"$1\" | awk '{print $2}'\n}\nparsearger_get_source() {\n  local -n _lsource=$1;\n  readarray -t _lsource <<< \"$(sed -ne 's/'\"${paStart}\"'-source \\(.*\\).*/\\1/p' \"$2\")\"\n}\nparsearger_get_pos() {\n  local -n _lpos=$1;\n  readarray -t _lpos <<< \"$(sed -ne 's/'\"${paStart}\"' pos \\(.*\\).*/\\1/p' \"$2\")\"\n}\nparsearger_get_opt() {\n  local -n _lopt=$1;\n  readarray -t _lopt <<< \"$(sed -ne 's/'\"${paStart}\"' opt \\(.*\\).*/\\1/p' \"$2\")\"\n}\nparsearger_get_flag() {\n  local -n _lflag=$1;\n  readarray -t _lflag <<< \"$(sed -ne 's/'\"${paStart}\"' flag \\(.*\\).*/\\1/p' \"$2\")\"\n}\nparsearger_get_nested() {\n  local -n _lnested=$1;\n  readarray -t _lnested <<< \"$(sed -ne 's/'\"${paStart}\"' nested \\(.*\\).*/\\1/p' \"$2\")\"\n}\nparsearger_get_one_ofs() {\n  local -n _lone_ofs=$1;\n  readarray -t _lone_ofs <<< \"$(echo \"$2\" | grep -oE -- '--one-of \"([^\"]+)\"' | cut -d'\"' -f2)\"\n}\nparsearger_get_dependencies() {\n  local -n _ldependencies=$1;\n  readarray -t _ldependencies <<< \"$(sed -ne 's/'\"${paStart}\"'-dependencies \\(.*\\).*/\\1/p' \"$2\" | sed 's/ /\\n/g')\"\n}\nparsearger_get_xdg() {\n  sed -ne 's/'\"${paStart}\"'-xdg \\(.*\\).*/\\1/p' \"$1\"\n}\nparsearger_get_verbose() {\n  sed -ne 's/'\"${paStart}\"'-verbose \\(.*\\).*/\\1/p' \"$1\"\n}\nparsearger_is_pa_file() {\n  if [ -f \"$1\" ]; then\n    local _isPA=\"$(sed -ne 's/'\"${paStart}\"'//p' \"$1\")\";\n    if [ \"${_isPA}\" != \"\" ]; then\n      return 0;\n    else\n      return 1;\n    fi\n  else\n    return 1;\n  fi\n}",
  "/parseArger/bin/help/parser": "#!/bin/bash\n\n# @parseArger-begin\n# @parseArger-help \"create help parser\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos message \"your main help message\"\n# @parseArger opt option \"help trigger option\" --default-value \"help\"\n# @parseArger opt short-option \"help trigger short option\" --default-value \"h\"\n# @parseArger flag has-subcommand \"do not exit after print_help\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/help\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_message=\"\";\n# OPTIONALS ARGUMENTS\n_arg_option=\"help\"\n_arg_short_option=\"h\"\n# FLAGS\n_arg_has_subcommand=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"create help parser:\"\n\techo -e \"\tmessage: your main help message\"\n\techo -e \"\t--option <option>: help trigger option [default: ' help ']\"\n\techo -e \"\t--short-option <short-option>: help trigger short option [default: ' h ']\"\n\techo -e \"\t--has-subcommand|--no-has-subcommand: do not exit after print_help\"\n\techo -e \"Usage :\n\t$0 <message> [--option <value>] [--short-option <value>] [--[no-]has-subcommand]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--option=*)\n\t\t\t\t_arg_option=\"${_key##--option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--short-option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short-option=*)\n\t\t\t\t_arg_short_option=\"${_key##--short-option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--has-subcommand)\n\t\t\t\t_arg_has_subcommand=\"on\"\n\t\t\t\t;;\n\t\t\t--no-has-subcommand)\n\t\t\t\t_arg_has_subcommand=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"message\"\n\tif [ \"${_positionals_count}\" -gt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_message \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\tmessage: ${_arg_message}\";\n\techo -e \"\\toption: ${_arg_option}\";\n\techo -e \"\\tshort-option: ${_arg_short_option}\";\n\techo -e \"\\thas-subcommand: ${_arg_has_subcommand}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\noutStr=\"\";\n\nif [ \"$_arg_option\" != \"\" ]; then\n\toutStr+=\"--$_arg_option\";\nfi\nif [ \"$_arg_short_option\" != \"\" ]; then\n\toutStr=\"-$_arg_short_option|$outStr\";\nfi\n\necho -e \"$outStr)\n\tprint_help;\"\n\tif [[ \"$_arg_has_subcommand\" == \"off\" ]]; then\n\t\techo -e \"\texit 0;\";\n\tfi\n\techo -e \"\t;;\";\n\nif [ \"$_arg_short_option\" != \"\" ]; then\n\techo -e \"-${_arg_short_option}*)\n\tprint_help;\"\n\tif [[ \"$_arg_has_subcommand\" == \"off\" ]]; then\n\t\techo -e \"\texit 0;\";\n\tfi\n\techo -e \"\t;;\";\nfi\n",
  "/parseArger/bin/help/get-trigger": "#!/bin/bash\n\n# @parseArger-begin\n# @parseArger-help \"create common help stuff\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos message \"your main help message\"\n# @parseArger opt option \"help trigger option\" --default-value \"help\"\n# @parseArger opt short-option \"help trigger short option\" --default-value \"h\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/help\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_message=\"\";\n# OPTIONALS ARGUMENTS\n_arg_option=\"help\"\n_arg_short_option=\"h\"\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"create common help stuff:\"\n\techo -e \"\tmessage: your main help message\"\n\techo -e \"\t--option <option>: help trigger option [default: ' help ']\"\n\techo -e \"\t--short-option <short-option>: help trigger short option [default: ' h ']\"\n\techo -e \"Usage :\n\t$0 <message> [--option <value>] [--short-option <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--option=*)\n\t\t\t\t_arg_option=\"${_key##--option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--short-option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short-option=*)\n\t\t\t\t_arg_short_option=\"${_key##--short-option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"message\"\n\tif [ \"${_positionals_count}\" -gt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_message \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\tmessage: ${_arg_message}\";\n\techo -e \"\\toption: ${_arg_option}\";\n\techo -e \"\\tshort-option: ${_arg_short_option}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\necho \"$_arg_option\";\n",
  "/parseArger/bin/help/declaration": "#!/bin/bash\n\n# @parseArger-begin\n# @parseArger-help \"create common help stuff\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos message \"your main help message\"\n# @parseArger opt option \"help trigger option\" --default-value \"help\"\n# @parseArger opt short-option \"help trigger short option\" --default-value \"h\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/help\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_message=\"\";\n# OPTIONALS ARGUMENTS\n_arg_option=\"help\"\n_arg_short_option=\"h\"\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"create common help stuff:\"\n\techo -e \"\tmessage: your main help message\"\n\techo -e \"\t--option <option>: help trigger option [default: ' help ']\"\n\techo -e \"\t--short-option <short-option>: help trigger short option [default: ' h ']\"\n\techo -e \"Usage :\n\t$0 <message> [--option <value>] [--short-option <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--option=*)\n\t\t\t\t_arg_option=\"${_key##--option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--short-option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short-option=*)\n\t\t\t\t_arg_short_option=\"${_key##--short-option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"message\"\n\tif [ \"${_positionals_count}\" -gt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_message \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\tmessage: ${_arg_message}\";\n\techo -e \"\\toption: ${_arg_option}\";\n\techo -e \"\\tshort-option: ${_arg_short_option}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\noutStr=\"# @parse\"\noutStr+=\"Arger-help \\\"$_arg_message\\\"\";\n\nif [ \"$_arg_option\" != \"\" ]; then\n\toutStr+=\" --option \\\"$_arg_option\\\"\";\nfi\nif [ \"$_arg_short_option\" != \"\" ]; then\n\toutStr+=\" --short-option \\\"$_arg_short_option\\\"\";\nfi\n\necho \"$outStr\";\n",
  "/parseArger/bin/bulk-parse": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parse multiple file and directories\" --option \"help\" --short-option \"h\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger opt bump \"new version\"\n# @parseArger opt file \"file to document\" --short f --repeat --complete \"file\"\n# @parseArger opt directory \"directory to document\" --short d --repeat --alias folder --complete \"directory\"\n# @parseArger flag sub-directory \"document subdirectory\" --on\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n# OPTIONALS ARGUMENTS\n_arg_bump=\n_arg_file=()\n_arg_directory=()\n# FLAGS\n_arg_sub_directory=\"on\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parse multiple file and directories:\"\n\techo -e \"\t--bump <bump>: new version\"\n\techo -e \"\t-f, --file <file>: file to document, repeatable\"\n\techo -e \"\t-d, --directory|--folder <directory>: directory to document, repeatable\"\n\techo -e \"\t--sub-directory|--no-sub-directory: document subdirectory, on by default (use --no-sub-directory to turn it off)\"\n\techo -e \"Usage :\n\t$0 [--bump <value>] [--file <value>] [--directory <value>] [--[no-]sub-directory]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--bump)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_bump=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--bump=*)\n\t\t\t\t_arg_bump=\"${_key##--bump=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-f|--file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_file+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--file=*)\n\t\t\t\t_arg_file+=(\"${_key##--file=}\")\n\t\t\t\t;;\n\t\t\t-f*)\n\t\t\t\t_arg_file+=(\"${_key##-f}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-d|--folder|--directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_directory+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--directory=*)\n\t\t\t\t_arg_directory+=(\"${_key##--directory=}\")\n\t\t\t\t;;\n\t\t\t--folder=*)\n\t\t\t\t_arg_directory+=(\"${_key##--folder=}\")\n\t\t\t\t;;\n\t\t\t-d*)\n\t\t\t\t_arg_directory+=(\"${_key##-d}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--sub-directory)\n\t\t\t\t_arg_sub_directory=\"on\"\n\t\t\t\t;;\n\t\t\t--no-sub-directory)\n\t\t\t\t_arg_sub_directory=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t--quiet)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"\"\n\tif [ \"${_positionals_count}\" -gt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 0 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 0 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"\";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\";\n\t\tlocal _regex=\"${!_match_var}\";\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\tbump: ${_arg_bump}\";\n\techo -e \"\tfile: ${_arg_file[*]}\";\n\techo -e \"\tdirectory: ${_arg_directory[*]}\";\n\techo -e \"\tsub-directory: ${_arg_sub_directory}\";\n\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nSCRIPT_ROOT_DIR=\"\"/parseArger/bin\"/..\";\n\npacmd=(\"${SCRIPT_ROOT_DIR}/parseArger\" parse \"-i\");\n\nif [ \"$_arg_bump\" != \"\" ]; then\n  pacmd+=(\"--set-version\" \"$_arg_bump\");\nfi\n\npaStart=\"# @parse\";\npaStart+=\"Arger\";\n\nif [ \"${#_arg_file[@]}\" -gt 0 ]; then\n\tfor _file in \"${_arg_file[@]}\"; do\n\t\tif [ -f \"$_file\" ]; then\n\t\t\t_isPA=\"$(sed -ne 's/'\"${paStart}\"'//p' \"$_file\")\";\n\t\t\tif [ \"${_isPA}\" != \"\" ]; then\n\t\t\t\t\"${pacmd[@]}\" \"$_file\";\n\t\t\tfi\n\t\tfi\n\tdone\nfi\n\nif [ \"${#_arg_directory[@]}\" -gt 0 ]; then\n\tfor _directory in \"${_arg_directory[@]}\"; do\n\t\tif [ -d \"$_directory\" ]; then\n\t\t\trpacmd=();\n\t\t\tif [ \"$_arg_sub_directory\" == \"off\" ]; then\n\t\t\t\trpacmd+=(--no-sub-directory);\n\t\t\tfi\n\n\t\t\tif [ \"$_arg_bump\" != \"\" ]; then\n\t\t\t\trpacmd+=(\"--bump\" \"$_arg_bump\");\n\t\t\tfi\n\t\t\t\n\t\t\tfor _file in \"$_directory\"/*; do\n\t\t\t\tif [ -f \"${_file}\" ]; then\n\t\t\t\t\trpacmd+=(--file \"$_file\");\n\t\t\t\tfi\n\t\t\t\tif [ -d \"${_file}\" ] && [ \"$_arg_sub_directory\" == \"on\" ] ; then\n\t\t\t\t\trpacmd+=(--directory \"$_file\");\n\t\t\t\tfi\n\t\t\tdone\n\t\t\t\"$0\" \"${rpacmd[@]}\";\n\t\tfi\n\tdone\nfi\n",
  "/parseArger/bin/_project/git-init": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"initialize git, optionally add and commit\" --option \"help\" --short-option \"h\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger pos name \"project name\" --optional\n# @parseArger opt add \"what to add\" --repeat\n# @parseArger opt commit \"commit, default message if nothing specified\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/_project\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_name=\"\";\n_optional_positionals+=(\"_arg_name\");\n# OPTIONALS ARGUMENTS\n_arg_add=()\n_arg_commit=\n# FLAGS\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"initialize git, optionally add and commit:\"\n\techo -e \"\tname: project name, optional\"\n\techo -e \"\t--add <add>: what to add, repeatable\"\n\techo -e \"\t--commit <commit>: commit, default message if nothing specified\"\n\techo -e \"Usage :\n\t$0 [name] [--add <value>] [--commit <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-\"0\"}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--add)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_add+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--add=*)\n\t\t\t\t_arg_add+=(\"${_key##--add=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--commit)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_commit=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--commit=*)\n\t\t\t\t_arg_commit=\"${_key##--commit=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"\"\n\tif [ \"${_positionals_count}\" -gt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 0 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_name \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\tname: ${_arg_name}\";\n\techo -e \"\tadd: ${_arg_add[*]}\";\n\techo -e \"\tcommit: ${_arg_commit}\";\n\n}\n\nprint_version()\n{\n\techo \"\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\nif [ ! -d \".git\" ]; then\n\tgit init;\n\t# git add .;\n\t# git commit -m \"Initial commit\";\nelse\n\tlog \"git already initialized\" -1;\nfi\nif [ \"${#_arg_add[@]}\" -gt 0 ] || [ \"$_arg_commit\" != \"\" ]; then\n\tif [ \"${#_arg_add[@]}\" -eq 0 ]; then\n\t\t_arg_add=(\".\");\n\tfi\n\tgit add \"${_arg_add[@]}\";\nfi\n\nif [ \"$_arg_commit\" != \"\" ]; then\n\tgit commit -m \"$_arg_commit\";\nfi\n",
  "/parseArger/bin/_project/mkfile": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"create makefile\" --option \"help\" --short-option \"h\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger pos name \"programm name\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/_project\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_name=\"\";\n# OPTIONALS ARGUMENTS\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"create makefile:\"\n\techo -e \"\tname: programm name\"\n\techo -e \"Usage :\n\t$0 <name>\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-'0'}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\u001b[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\u001b[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\u001b[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\u001b[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\u001b[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\u001b[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\u001b[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\u001b[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"name\"\n\tif [ \"${_positionals_count}\" -gt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\n\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_name \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\tname: ${_arg_name}\";\n\n}\n\nprint_version()\n{\n\techo \"\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nsed \"${_SCRIPT_DIR}/../../templates/mkfile\" \\\n\t-e \"s|__program_name__|$_arg_name|g\" >> \"Makefile\";",
  "/parseArger/bin/_project/webserver": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"create web server for a project\" --option \"help\" --short-option \"h\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger pos name \"program name\"\n# @parseArger opt route \"route to add\" --repeat --alias url\n# @parseArger opt file \"create the server file name\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/_project\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_name=\"\";\n# OPTIONALS ARGUMENTS\n_arg_route=()\n_arg_file=\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"create web server for a project:\"\n\techo -e \"\tname: program name\"\n\techo -e \"\t--route|--url <route>: route to add, repeatable\"\n\techo -e \"\t--file <file>: create the server file name\"\n\techo -e \"Usage :\n\t$0 <name> [--route <value>] [--file <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-'0'}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--url|--route)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_route+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--route=*)\n\t\t\t\t_arg_route+=(\"${_key##--route=}\")\n\t\t\t\t;;\n\t\t\t--url=*)\n\t\t\t\t_arg_route+=(\"${_key##--url=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_file=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--file=*)\n\t\t\t\t_arg_file=\"${_key##--file=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"name\"\n\tif [ \"${_positionals_count}\" -gt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_name \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\tname: ${_arg_name}\";\n\techo -e \"\\troute: ${_arg_route[*]}\";\n\techo -e \"\\tfile: ${_arg_file}\";\n\n}\n\nprint_version()\n{\n\techo \"\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nif [ \"$_arg_file\" == \"\" ]; then\n\t_arg_file=\"utils/webserver\";\nfi\n\nif [ ! -d \"$(dirname \"$_arg_file\")\" ]; then\n\tmkdir -p \"$(dirname \"$_arg_file\")\";\nfi\n\nsed 's/\\/parseArger/\\/'\"$_arg_name\"'/g' \"${_SCRIPT_DIR}/../../utils/webserver\" > \"$_arg_file\";\n\nfor route in \"${_arg_route[@]}\"; do\n\trstr=\"\\n\\t\\t\\t\\t${route})\\n\\t\\t\\t\\t\\tsend200 'TODO';\\n\\t\\t\\t\\t;;\";\n\tsed -i '/# Set your custom routes here/a '\"$rstr\"'' \"$_arg_file\"\ndone\n",
  "/parseArger/bin/_project/installer": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"generate the get_<myscript> docwloader and installer\" --option \"help\" --short-option \"h\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger pos name \"project name\"\n# @parseArger opt git-repo \"git repository name\"\n# @parseArger opt git-service \"git service\" --default-value \"github.com\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/_project\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_name=\"\";\n# OPTIONALS ARGUMENTS\n_arg_git_repo=\n_arg_git_service=\"github.com\"\n_arg_parsearger=()\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"generate the get_<myscript> docwloader and installer:\"\n\techo -e \"\tname: project name\"\n\techo -e \"\t--git-repo <git-repo>: git repository name\"\n\techo -e \"\t--git-service <git-service>: git service [default: ' github.com ']\"\n\techo -e \"\t--parsearger <parsearger>: parseArger path, repeatable\"\n\techo -e \"Usage :\n\t$0 <name> [--git-repo <value>] [--git-service <value>] [--parsearger <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--git-repo)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_git_repo=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--git-repo=*)\n\t\t\t\t_arg_git_repo=\"${_key##--git-repo=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--git-service)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_git_service=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--git-service=*)\n\t\t\t\t_arg_git_service=\"${_key##--git-service=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--parsearger)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_parsearger+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--parsearger=*)\n\t\t\t\t_arg_parsearger+=(\"${_key##--parsearger=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"name\"\n\tif [ \"${_positionals_count}\" -gt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_name \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\tname: ${_arg_name}\";\n\techo -e \"\\tgit-repo: ${_arg_git_repo}\";\n\techo -e \"\\tgit-service: ${_arg_git_service}\";\n\techo -e \"\\tparsearger: ${_arg_parsearger[*]}\";\n\n}\n\nprint_version()\n{\n\techo \"\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nsshurl=\"git@${_arg_git_service}:${_arg_git_repo}.git\";\nhttpsurl=\"https://${_arg_git_service}/${_arg_git_repo}.git\";\nzipurl=\"https://${_arg_git_service}/${_arg_git_repo}/archive/refs/heads/\\${_arg_branch}.zip\";\n\nif [ ! -d \"utils\" ]; then\n\tlog \"Creating utils directory\" 4;\n\tmkdir -p \"utils\";\nfi\n\npaBin=\"$_SCRIPT_DIR/../../parseArger\";\n\nif [ ! -f \"utils/get_${_arg_name}\" ]; then\n\tgenget_=(\"$paBin\" generate --help-message \"Get $_arg_name installer\" --output \"utils/get_${_arg_name}\");\n\tgenget_+=(--opt 'branch \"version to install\" --short b --alias tag --alias install-version');\n\tgenget_+=(--opt 'install-directory \"where to install\" --complete \"directory\"');\n\tgenget_+=(--opt 'install-file \"rc files to install to, forces install\" --repeat');\n\tgenget_+=(--flag 'install \"install in bashrc\" --short i');\n\tgenget_+=(--flag 'remove-installer \"remove install script itself\" --alias rm');\n\tgenget_+=(--flag 'ssh \"clone using ssh\"');\n\tgenget_+=(--flag 'zip \"install using zip archive, not recommended\"');\n\tlog \"generating gette script\" 4;\n\tlog \"${genget_[*]}\" 1;\n\t\"${genget_[@]}\";\n\n\tsed \"${_SCRIPT_DIR}/../../templates/utils/get_\" \\\n\t\t-e \"s|__git_ssh_url__|$sshurl|g\" \\\n\t\t-e \"s|__git_https_url__|$httpsurl|g\" \\\n\t\t-e \"s|__zip_url__|$zipurl|g\" \\\n\t\t-e \"s|__program_name__|$_arg_name|g\" >> \"utils/get_${_arg_name}\";\nfi\n\nif [ ! -f \"utils/install\" ]; then\n\tgeninst_=(\"$paBin\" generate --help-message \"Install $_arg_name\" --output \"utils/install\");\n\tgeninst_+=(--opt 'shell-rc-file \"where to put the source directive\" --default-value \"\\$HOME/.bashrc\" --repeat --alias install-file');\n\tgeninst_+=(--flag 'comment \"add parsearger comment\" --on');\n\tlog \"generating install script\" 4;\n\tlog \"${geninst_[*]}\" 1;\n\t\"${geninst_[@]}\";\n\n\tsed \"${_SCRIPT_DIR}/../../templates/utils/install\" \\\n\t\t-e \"s|__program_name__|$_arg_name|g\" \\\n\t\t-e \"s|__program_name_upper__|${_arg_name^^}|g\" >> \"utils/install\";\nfi\n\nif [ -f \"readme.md\" ]; then\n\tlog \"Adding install instruction to readme\" 4;\n\tsed \"${_SCRIPT_DIR}/../../templates/install.md\" \\\n\t\t-e \"s|__program_name__|$_arg_name|g\" \\\n\t\t-e \"s|__git_repo__|$_arg_git_repo|g\" >> \"readme.md\";\nfi\n",
  "/parseArger/bin/generate": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"generate a parseArger script\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger opt pos \"positional argument declaration\" --short p --repeat\n# @parseArger opt opt \"optional arg declaration\" --short o --repeat\n# @parseArger opt flag \"flag declaration\" --short f --repeat\n# @parseArger opt set \"declare var\" --short s --repeat\n# @parseArger opt source \"file to source\" --short l --repeat\n# @parseArger opt help-message \"help message for the command\" --short m --default-value \"I send an SOS to the world\"\n# @parseArger opt help-option \"help option trigger\"\n# @parseArger opt help-short-option \"short help option\"\n# @parseArger opt leftovers-name \"extra arguments variable name\" --default-value \"leftovers\"\n# @parseArger opt use-shebang \"shebang executable\" --default-value \"/bin/bash\"\n# @parseArger opt set-version \"set version number\"\n# @parseArger opt version-opt-name \"version option name\" --default-value \"version\"\n# @parseArger opt version-short-option \"version short option name\" --default-value \"v\"\n# @parseArger opt die-fn-name \"die function name\" --default-value \"die\"\n# @parseArger opt log-fn-name \"log function name\" --default-value \"log\"\n# @parseArger opt verbose-opt-name \"verbose option name\" --default-value \"verbose\"\n# @parseArger opt verbose-level \"default verbose level\" --default-value \"0\"\n# @parseArger opt nested \"nested option declaration\" --repeat\n# @parseArger opt history \"add n history lines at the end of the file\"\n# @parseArger opt history-offset \"offset --history value by value\"\n# @parseArger opt history-file \"specify history file\" --default-value \"$HOME/.bash_history\"\n# @parseArger opt dependencies \"specify script dependencies\" --repeat\n# @parseArger opt xdg \"XDG app name for config/data/cache directories\"\n# @parseArger opt xdg-config-file \"XDG config file name\" --default-value \"config\"\n# @parseArger flag xdg-config \"enable XDG_CONFIG_HOME support\" --on\n# @parseArger flag xdg-data \"enable XDG_DATA_HOME support\" --on\n# @parseArger flag xdg-cache \"enable XDG_CACHE_HOME support\"\n# @parseArger flag leftovers \"accept extra arguments\"\n# @parseArger flag bang \"include shebang\" --on\n# @parseArger flag version-opt \"generate version opt handling\" --on\n# @parseArger flag use-verbose \"generate verbose level parser\" --on\n# @parseArger flag parse-leftovers \"parse leftovers, force leftovers\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n# OPTIONALS ARGUMENTS\n_arg_pos=()\n_arg_opt=()\n_arg_flag=()\n_arg_set=()\n_arg_source=()\n_arg_help_message=\"I send an SOS to the world\"\n_arg_help_option=\n_arg_help_short_option=\n_arg_leftovers_name=\"leftovers\"\n_arg_use_shebang=\"/bin/bash\"\n_arg_set_version=\n_arg_version_opt_name=\"version\"\n_arg_version_short_option=\"v\"\n_arg_die_fn_name=\"die\"\n_arg_log_fn_name=\"log\"\n_arg_verbose_opt_name=\"verbose\"\n_arg_verbose_level=\"0\"\n_arg_nested=()\n_arg_history=\n_arg_history_offset=\n_arg_history_file=\"$HOME/.bash_history\"\n_arg_dependencies=()\n_arg_xdg=\n_arg_xdg_config_file=\"config\"\n# FLAGS\n_arg_xdg_config=\"on\"\n_arg_xdg_data=\"on\"\n_arg_xdg_cache=\"off\"\n_arg_leftovers=\"off\"\n_arg_bang=\"on\"\n_arg_version_opt=\"on\"\n_arg_use_verbose=\"on\"\n_arg_parse_leftovers=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"generate a parseArger script:\"\n\techo -e \"\t-p, --pos <pos>: positional argument declaration, repeatable\"\n\techo -e \"\t-o, --opt <opt>: optional arg declaration, repeatable\"\n\techo -e \"\t-f, --flag <flag>: flag declaration, repeatable\"\n\techo -e \"\t-s, --set <set>: declare var, repeatable\"\n\techo -e \"\t-l, --source <source>: file to source, repeatable\"\n\techo -e \"\t-m, --help-message <help-message>: help message for the command [default: ' I send an SOS to the world ']\"\n\techo -e \"\t--help-option <help-option>: help option trigger\"\n\techo -e \"\t--help-short-option <help-short-option>: short help option\"\n\techo -e \"\t--leftovers-name <leftovers-name>: extra arguments variable name [default: ' leftovers ']\"\n\techo -e \"\t--use-shebang <use-shebang>: shebang executable [default: ' /bin/bash ']\"\n\techo -e \"\t--set-version <set-version>: set version number\"\n\techo -e \"\t--version-opt-name <version-opt-name>: version option name [default: ' version ']\"\n\techo -e \"\t--version-short-option <version-short-option>: version short option name [default: ' v ']\"\n\techo -e \"\t--die-fn-name <die-fn-name>: die function name [default: ' die ']\"\n\techo -e \"\t--log-fn-name <log-fn-name>: log function name [default: ' log ']\"\n\techo -e \"\t--verbose-opt-name <verbose-opt-name>: verbose option name [default: ' verbose ']\"\n\techo -e \"\t--verbose-level <verbose-level>: default verbose level [default: ' 0 ']\"\n\techo -e \"\t--nested <nested>: nested option declaration, repeatable\"\n\techo -e \"\t--history <history>: add n history lines at the end of the file\"\n\techo -e \"\t--history-offset <history-offset>: offset --history value by value\"\n\techo -e \"\t--history-file <history-file>: specify history file [default: ' $HOME/.bash_history ']\"\n\techo -e \"\t--dependencies <dependencies>: specify script dependencies, repeatable\"\n\techo -e \"\t--xdg <xdg>: XDG app name for config/data/cache directories\"\n\techo -e \"\t--xdg-config-file <xdg-config-file>: XDG config file name [default: ' config ']\"\n\techo -e \"\t--xdg-config|--no-xdg-config: enable XDG_CONFIG_HOME support, on by default (use --no-xdg-config to turn it off)\"\n\techo -e \"\t--xdg-data|--no-xdg-data: enable XDG_DATA_HOME support, on by default (use --no-xdg-data to turn it off)\"\n\techo -e \"\t--xdg-cache|--no-xdg-cache: enable XDG_CACHE_HOME support\"\n\techo -e \"\t--leftovers|--no-leftovers: accept extra arguments\"\n\techo -e \"\t--bang|--no-bang: include shebang, on by default (use --no-bang to turn it off)\"\n\techo -e \"\t--version-opt|--no-version-opt: generate version opt handling, on by default (use --no-version-opt to turn it off)\"\n\techo -e \"\t--use-verbose|--no-use-verbose: generate verbose level parser, on by default (use --no-use-verbose to turn it off)\"\n\techo -e \"\t--parse-leftovers|--no-parse-leftovers: parse leftovers, force leftovers\"\n\techo -e \"Usage :\n\t$0 [--pos <value>] [--opt <value>] [--flag <value>] [--set <value>] [--source <value>] [--help-message <value>] [--help-option <value>] [--help-short-option <value>] [--leftovers-name <value>] [--use-shebang <value>] [--set-version <value>] [--version-opt-name <value>] [--version-short-option <value>] [--die-fn-name <value>] [--log-fn-name <value>] [--verbose-opt-name <value>] [--verbose-level <value>] [--nested <value>] [--history <value>] [--history-offset <value>] [--history-file <value>] [--dependencies <value>] [--xdg <value>] [--xdg-config-file <value>] [--[no-]xdg-config] [--[no-]xdg-data] [--[no-]xdg-cache] [--[no-]leftovers] [--[no-]bang] [--[no-]version-opt] [--[no-]use-verbose] [--[no-]parse-leftovers]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t-p|--pos)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_pos+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--pos=*)\n\t\t\t\t_arg_pos+=(\"${_key##--pos=}\")\n\t\t\t\t;;\n\t\t\t-p*)\n\t\t\t\t_arg_pos+=(\"${_key##-p}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-o|--opt)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_opt+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--opt=*)\n\t\t\t\t_arg_opt+=(\"${_key##--opt=}\")\n\t\t\t\t;;\n\t\t\t-o*)\n\t\t\t\t_arg_opt+=(\"${_key##-o}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-f|--flag)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_flag+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--flag=*)\n\t\t\t\t_arg_flag+=(\"${_key##--flag=}\")\n\t\t\t\t;;\n\t\t\t-f*)\n\t\t\t\t_arg_flag+=(\"${_key##-f}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-s|--set)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_set+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--set=*)\n\t\t\t\t_arg_set+=(\"${_key##--set=}\")\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_set+=(\"${_key##-s}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-l|--source)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_source+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--source=*)\n\t\t\t\t_arg_source+=(\"${_key##--source=}\")\n\t\t\t\t;;\n\t\t\t-l*)\n\t\t\t\t_arg_source+=(\"${_key##-l}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-m|--help-message)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_help_message=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--help-message=*)\n\t\t\t\t_arg_help_message=\"${_key##--help-message=}\"\n\t\t\t\t;;\n\t\t\t-m*)\n\t\t\t\t_arg_help_message=\"${_key##-m}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--help-option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_help_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--help-option=*)\n\t\t\t\t_arg_help_option=\"${_key##--help-option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--help-short-option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_help_short_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--help-short-option=*)\n\t\t\t\t_arg_help_short_option=\"${_key##--help-short-option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--leftovers-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_leftovers_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--leftovers-name=*)\n\t\t\t\t_arg_leftovers_name=\"${_key##--leftovers-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--use-shebang)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_use_shebang=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--use-shebang=*)\n\t\t\t\t_arg_use_shebang=\"${_key##--use-shebang=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--set-version)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_set_version=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--set-version=*)\n\t\t\t\t_arg_set_version=\"${_key##--set-version=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--version-opt-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_version_opt_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--version-opt-name=*)\n\t\t\t\t_arg_version_opt_name=\"${_key##--version-opt-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--version-short-option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_version_short_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--version-short-option=*)\n\t\t\t\t_arg_version_short_option=\"${_key##--version-short-option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--die-fn-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_die_fn_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--die-fn-name=*)\n\t\t\t\t_arg_die_fn_name=\"${_key##--die-fn-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--log-fn-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_log_fn_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--log-fn-name=*)\n\t\t\t\t_arg_log_fn_name=\"${_key##--log-fn-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--verbose-opt-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_verbose_opt_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--verbose-opt-name=*)\n\t\t\t\t_arg_verbose_opt_name=\"${_key##--verbose-opt-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--verbose-level)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_verbose_level=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--verbose-level=*)\n\t\t\t\t_arg_verbose_level=\"${_key##--verbose-level=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--nested)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_nested+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--nested=*)\n\t\t\t\t_arg_nested+=(\"${_key##--nested=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--history)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_history=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--history=*)\n\t\t\t\t_arg_history=\"${_key##--history=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--history-offset)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_history_offset=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--history-offset=*)\n\t\t\t\t_arg_history_offset=\"${_key##--history-offset=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--history-file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_history_file=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--history-file=*)\n\t\t\t\t_arg_history_file=\"${_key##--history-file=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--dependencies)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_dependencies+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--dependencies=*)\n\t\t\t\t_arg_dependencies+=(\"${_key##--dependencies=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--xdg)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_xdg=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--xdg=*)\n\t\t\t\t_arg_xdg=\"${_key##--xdg=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--xdg-config-file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_xdg_config_file=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--xdg-config-file=*)\n\t\t\t\t_arg_xdg_config_file=\"${_key##--xdg-config-file=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--xdg-config)\n\t\t\t\t_arg_xdg_config=\"on\"\n\t\t\t\t;;\n\t\t\t--no-xdg-config)\n\t\t\t\t_arg_xdg_config=\"off\"\n\t\t\t\t;;\n\t\t\t--xdg-data)\n\t\t\t\t_arg_xdg_data=\"on\"\n\t\t\t\t;;\n\t\t\t--no-xdg-data)\n\t\t\t\t_arg_xdg_data=\"off\"\n\t\t\t\t;;\n\t\t\t--xdg-cache)\n\t\t\t\t_arg_xdg_cache=\"on\"\n\t\t\t\t;;\n\t\t\t--no-xdg-cache)\n\t\t\t\t_arg_xdg_cache=\"off\"\n\t\t\t\t;;\n\t\t\t--leftovers)\n\t\t\t\t_arg_leftovers=\"on\"\n\t\t\t\t;;\n\t\t\t--no-leftovers)\n\t\t\t\t_arg_leftovers=\"off\"\n\t\t\t\t;;\n\t\t\t--bang)\n\t\t\t\t_arg_bang=\"on\"\n\t\t\t\t;;\n\t\t\t--no-bang)\n\t\t\t\t_arg_bang=\"off\"\n\t\t\t\t;;\n\t\t\t--version-opt)\n\t\t\t\t_arg_version_opt=\"on\"\n\t\t\t\t;;\n\t\t\t--no-version-opt)\n\t\t\t\t_arg_version_opt=\"off\"\n\t\t\t\t;;\n\t\t\t--use-verbose)\n\t\t\t\t_arg_use_verbose=\"on\"\n\t\t\t\t;;\n\t\t\t--no-use-verbose)\n\t\t\t\t_arg_use_verbose=\"off\"\n\t\t\t\t;;\n\t\t\t--parse-leftovers)\n\t\t\t\t_arg_parse_leftovers=\"on\"\n\t\t\t\t;;\n\t\t\t--no-parse-leftovers)\n\t\t\t\t_arg_parse_leftovers=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t--quiet)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"\"\n\tif [ \"${_positionals_count}\" -gt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 0 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 0 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"\";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\";\n\t\tlocal _regex=\"${!_match_var}\";\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\tpos: ${_arg_pos[*]}\";\n\techo -e \"\topt: ${_arg_opt[*]}\";\n\techo -e \"\tflag: ${_arg_flag[*]}\";\n\techo -e \"\tset: ${_arg_set[*]}\";\n\techo -e \"\tsource: ${_arg_source[*]}\";\n\techo -e \"\thelp-message: ${_arg_help_message}\";\n\techo -e \"\thelp-option: ${_arg_help_option}\";\n\techo -e \"\thelp-short-option: ${_arg_help_short_option}\";\n\techo -e \"\tleftovers-name: ${_arg_leftovers_name}\";\n\techo -e \"\tuse-shebang: ${_arg_use_shebang}\";\n\techo -e \"\tset-version: ${_arg_set_version}\";\n\techo -e \"\tversion-opt-name: ${_arg_version_opt_name}\";\n\techo -e \"\tversion-short-option: ${_arg_version_short_option}\";\n\techo -e \"\tdie-fn-name: ${_arg_die_fn_name}\";\n\techo -e \"\tlog-fn-name: ${_arg_log_fn_name}\";\n\techo -e \"\tverbose-opt-name: ${_arg_verbose_opt_name}\";\n\techo -e \"\tverbose-level: ${_arg_verbose_level}\";\n\techo -e \"\tnested: ${_arg_nested[*]}\";\n\techo -e \"\thistory: ${_arg_history}\";\n\techo -e \"\thistory-offset: ${_arg_history_offset}\";\n\techo -e \"\thistory-file: ${_arg_history_file}\";\n\techo -e \"\tdependencies: ${_arg_dependencies[*]}\";\n\techo -e \"\txdg: ${_arg_xdg}\";\n\techo -e \"\txdg-config-file: ${_arg_xdg_config_file}\";\n\techo -e \"\txdg-config: ${_arg_xdg_config}\";\n\techo -e \"\txdg-data: ${_arg_xdg_data}\";\n\techo -e \"\txdg-cache: ${_arg_xdg_cache}\";\n\techo -e \"\tleftovers: ${_arg_leftovers}\";\n\techo -e \"\tbang: ${_arg_bang}\";\n\techo -e \"\tversion-opt: ${_arg_version_opt}\";\n\techo -e \"\tuse-verbose: ${_arg_use_verbose}\";\n\techo -e \"\tparse-leftovers: ${_arg_parse_leftovers}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nSCRIPT_ROOT_DIR=\"/parseArger/bin\";\n\n# var definitions\nminPos=\"${#_arg_pos[@]}\";\nmaxPos=\"${#_arg_pos[@]}\";\nreqPos=();\nposNames=();\nposArgNames=();\noptNames=();\noptArgNames=();\nflagNames=();\nflagArgNames=();\npaCmtTrgr=\"@parse\";\npaCmtTrgr+=\"Arger-\";\n\nposI=0;\nfor pos in \"${_arg_pos[@]}\"; do\n\tposNames+=(\"$(echo \"$pos\" | head -n1 | cut -d \" \" -f1)\");\n\tposArgNames+=(\"$(echo \"$pos\" | head -n1 | cut -d \" \" -f1 | sed 's/-/_/')\");\n\tif [[ $pos =~ \"--optional\" ]]; then\n\t\tminPos=$((minPos-1));\n\telse\n\t\treqPos+=(\"${posNames[$posI]}\");\n\tfi\n\t# TODO\n\t# [ ] extract min-repeat value\n\tif [[ $pos =~ \"--min-repeat\" ]]; then\n\t\tminPos=$((minPos+1));\n\tfi\n\t# TODO\n\t# [ ] extract max-repeat value\n\tif [[ $pos =~ \"--max-repeat\" ]]; then\n\t\tmaxPos=$((maxPos+1));\n\tfi\n\tposI=$((posI+1));\ndone\nfor opt in \"${_arg_opt[@]}\"; do\n\toptNames+=(\"$(echo \"$opt\" | head -n1 | cut -d \" \" -f1)\");\n\toptArgNames+=(\"$(echo \"$opt\" | head -n1 | cut -d \" \" -f1 | sed 's/-/_/g')\");\ndone\nfor flag in \"${_arg_flag[@]}\"; do\n\tflagNames+=(\"$(echo \"$flag\" | head -n1 | cut -d \" \" -f1)\");\n\tflagArgNames+=(\"$(echo \"$flag\" | head -n1 | cut -d \" \" -f1 | sed 's/-/_/g')\");\ndone\nfor nested in \"${_arg_nested[@]}\"; do\n\tnestedNames+=(\"$(echo \"$nested\" | head -n1 | cut -d \" \" -f1)\");\n\tnestedArgNames+=(\"$(echo \"$nested\" | head -n1 | cut -d \" \" -f1 | sed 's/-/_/g')\");\ndone\n\n# generate shebang\nif [ \"$_arg_bang\" != \"off\" ]; then\n\techo \"#!${_arg_use_shebang}\";\nfi\n\n# parsing\necho -e \"# ${paCmtTrgr}begin\";\n\n# help\nhelpDecArg=(\"$_arg_help_message\");\nif [ \"$_arg_help_option\" != \"\" ]; then\n\thelpDecArg+=(\"--option\" \"$_arg_help_option\");\nfi\nif [ \"$_arg_help_short_option\" != \"\" ]; then\n\thelpDecArg+=(\"--short-option\" \"$_arg_help_short_option\");\nfi\nsource \"$SCRIPT_ROOT_DIR/help/declaration\" \"${helpDecArg[@]}\";\n\n# version\nif [ \"$_arg_set_version\" != \"\" ] && [ \"$_arg_version_opt\" != \"off\" ]; then\n\tversionDecArg=(\"$_arg_set_version\");\n\tif [ \"$_arg_version_opt_name\" != \"\" ]; then\n\t\tversionDecArg+=(\"--option\" \"$_arg_version_opt_name\");\n\tfi\n\tif [ \"$_arg_version_short_option\" != \"\" ]; then\n\t\tversionDecArg+=(\"--short-option\" \"$_arg_version_short_option\");\n\tfi\n\tsource \"$SCRIPT_ROOT_DIR/version/declaration\" \"${versionDecArg[@]}\";\nelse\n\tversionDecArg=(\"\");\nfi\n\n# verbose\nif [ \"$_arg_use_verbose\" != \"off\" ]; then\n\tverboseDecArg=(\"--option\" \"$_arg_verbose_opt_name\" --level \"$_arg_verbose_level\" --log-fn-name \"$_arg_log_fn_name\");\n\tsource \"$SCRIPT_ROOT_DIR/verbose/declaration\" \"${verboseDecArg[@]}\";\nelse\n\tverboseDecArg=(\"\");\nfi\n\n# xdg\nif [ \"$_arg_xdg\" != \"\" ]; then\n\txdgDecArg=(\"$_arg_xdg\");\n\tif [ \"$_arg_xdg_config\" == \"on\" ]; then\n\t\txdgDecArg+=(--config);\n\telse\n\t\txdgDecArg+=(--no-config);\n\tfi\n\tif [ \"$_arg_xdg_data\" == \"on\" ]; then\n\t\txdgDecArg+=(--data);\n\telse\n\t\txdgDecArg+=(--no-data);\n\tfi\n\tif [ \"$_arg_xdg_cache\" == \"on\" ]; then\n\t\txdgDecArg+=(--cache);\n\telse\n\t\txdgDecArg+=(--no-cache);\n\tfi\n\tif [ \"$_arg_xdg_config_file\" != \"config\" ]; then\n\t\txdgDecArg+=(--config-file \"$_arg_xdg_config_file\");\n\tfi\n\tsource \"$SCRIPT_ROOT_DIR/xdg/declaration\" \"${xdgDecArg[@]}\";\nfi\n\n# setting user variables\nif [ \"${#_arg_set[@]}\" -gt 0 ]; then\n\tfor _set in \"${_arg_set[@]}\"; do\n\t\techo \"# ${paCmtTrgr}set $_set\";\n\t\techo -e \"$_set\";\n\tdone\nfi\n\n# sourcing user files\nif [ \"${#_arg_source[@]}\" -gt 0 ]; then\n\tfor _source in \"${_arg_source[@]}\"; do\n\t\techo \"# ${paCmtTrgr}source $_source\";\n\t\techo -e \"source \\\"$_source\\\";\";\n\tdone\nfi\n\n# leftovers\nif [ \"$_arg_leftovers_name\" != \"leftovers\" ] || [ \"$_arg_parse_leftovers\" == \"on\" ]; then\n\t_arg_leftovers=\"on\";\nfi\nif [ \"$_arg_leftovers\" == \"on\" ]; then\n\tlfDec=\"# ${paCmtTrgr}leftovers $_arg_leftovers_name\";\n\tif [ \"$_arg_parse_leftovers\" == \"on\" ]; then\n\t\tlfDec+=\" --parse\";\n\tfi\n\techo -e \"$lfDec\";\nfi\n\nhasSubCmd=\"1\";\n\n# argument declarations\necho -e \"_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=\\$(tput colors 2>/dev/null)\n\tif [ -n \\\"\\$ncolors\\\" ] && [ \\\"\\$ncolors\\\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\";\necho -e \"# ${paCmtTrgr}declarations\";\nfor pos in \"${_arg_pos[@]}\"; do\n\tif [[ \"$hasSubCmd\" == \"1\" ]]; then\n\t\thasSubCmd=$(eval \"source $SCRIPT_ROOT_DIR/pos/is-subcmd $pos\")\n\tfi\n\teval \"source $SCRIPT_ROOT_DIR/pos/declaration $pos\";\ndone\nfor opt in \"${_arg_opt[@]}\"; do\n\teval \"source $SCRIPT_ROOT_DIR/opt/declaration $opt\";\ndone\nfor flag in \"${_arg_flag[@]}\"; do\n\teval \"source $SCRIPT_ROOT_DIR/flag/declaration $flag\";\ndone\nfor nested in \"${_arg_nested[@]}\"; do\n\teval \"source $SCRIPT_ROOT_DIR/nested/declaration $nested\";\ndone\n\nif [ \"${#_arg_dependencies[@]}\" -gt 0 ]; then\n\t__depdeclstr=\"\";\n\tfor dep in \"${_arg_dependencies[@]}\"; do\n\t\t__depdeclstr+=\" \\\"$dep\\\"\";\n\tdone\n\techo \"# ${paCmtTrgr}dependencies${__depdeclstr}\";\nfi\n\n# generating parsing function\necho \"# ${paCmtTrgr}declarations-end\n\n# ${paCmtTrgr}utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\\\"\\$(cd \\\"\\$(dirname \\\"\\${BASH_SOURCE[0]}\\\")\\\" && pwd -P)\\\";\n# ${paCmtTrgr}utils-end\n\n# ${paCmtTrgr}parsing\n\n__cli_arg_count=\"\\$#\";\n\n${_arg_die_fn_name}()\n{\n\tlocal _ret=1\n    if [[ -n \\\"\\$2\\\" ]] && [[ \\\"\\$2\\\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\\\"\\$2\\\"\n    fi\n\ttest \\\"\\${_PRINT_HELP:-no}\\\" = yes && print_help >&2\n\tlog \\\"\\$1\\\" -3 >&2\n\texit \\\"\\${_ret}\\\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\\\"\\${1:0:1}\\\"\n\ttest \\\"\\$all_short_options\\\" = \\\"\\${all_short_options/\\$first_option/}\\\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\"\n\n# variable initialisation\nfor pos in \"${_arg_pos[@]}\"; do\n\teval \"source $SCRIPT_ROOT_DIR/pos/init $pos\";\ndone\necho \"# OPTIONALS ARGUMENTS\"\nfor opt in \"${_arg_opt[@]}\"; do\n\teval \"source $SCRIPT_ROOT_DIR/opt/init $opt\";\ndone\necho \"# FLAGS\"\nfor flag in \"${_arg_flag[@]}\"; do\n\teval \"source $SCRIPT_ROOT_DIR/flag/init $flag\";\ndone\necho \"# NESTED\"\nfor nested in \"${_arg_nested[@]}\"; do\n\teval \"source $SCRIPT_ROOT_DIR/nested/init $nested\";\ndone\nif [ \"$_arg_leftovers\" != \"off\" ]; then\n\techo -e \"# LEFTOVERS\n_arg_${_arg_leftovers_name}=()\";\n\tif [ \"$_arg_parse_leftovers\" == \"on\" ]; then\n\t\techo -e \"# LEFTOVERS\n\tdeclare -A _arg_parsed_${_arg_leftovers_name}\";\n\tfi\nfi\n# verbose level init\nif [ \"$_arg_use_verbose\" != \"off\" ]; then\n\tsource \"$SCRIPT_ROOT_DIR/verbose/init\" \"${verboseDecArg[@]}\";\nfi\n\n# xdg init\nif [ \"$_arg_xdg\" != \"\" ]; then\n\tsource \"$SCRIPT_ROOT_DIR/xdg/init\" \"${xdgDecArg[@]}\";\nfi\n\n# help\n# TODO get the index of the subcommand arg to compare to total number of args\n#\t\t2 selected because \"tgt --help\" is 2 args\necho -e \"\n\nprint_help()\n{\n\t_triggerSCHelp=1;\";\nif [ \"$hasSubCmd\" == \"0\" ]; then\n\techo -e \"\n\tif [ \\\"\\$__cli_arg_count\\\" -ge 2 ]; then\n\t\t# echo \\\"\\$0 sub command help\\\\n\t#\\\"\n\t\t_triggerSCHelp=0;\n\t\t_helpHasBeenPrinted=0;\n\telse\n\t\";\nfi\necho -e \"\n\tif [[ \\\"\\$_helpHasBeenPrinted\\\" == \\\"1\\\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \\\"$_arg_help_message:\\\"\";\n# help examples\nposexample=\"\";\nfor pos in \"${_arg_pos[@]}\"; do\n\topCh=\"<\";\n\tclCh=\">\";\n\tif [[ $pos =~ \"--optional\" ]]; then\n\t\topCh=\"[\";\n\t\tclCh=\"]\";\n\tfi\n\tposexample+=\" ${opCh}$(echo \"$pos\" | head -n1 | cut -d \" \" -f1)${clCh}\";\n\teval \"source $SCRIPT_ROOT_DIR/pos/help $pos\";\ndone\noptexample=\"\";\nfor opt in \"${_arg_opt[@]}\"; do\n\toptexample+=\" [--$(echo \"$opt\" | head -n1 | cut -d \" \" -f1) <value>]\";\n\teval \"source $SCRIPT_ROOT_DIR/opt/help $opt\";\ndone\nflagexample=\"\";\nfor flag in \"${_arg_flag[@]}\"; do\n\tflagexample+=\" [--[no-]$(echo \"$flag\" | head -n1 | cut -d \" \" -f1)]\";\n\teval \"source $SCRIPT_ROOT_DIR/flag/help $flag\";\ndone\nnestedexample=\"\";\nfor nested in \"${_arg_nested[@]}\"; do\n\tnestedexample+=\" [--[no-]$(echo \"$nested\" | head -n1 | cut -d \" \" -f1)]\";\n\teval \"source $SCRIPT_ROOT_DIR/nested/help $nested\";\ndone\n\necho -e \"\\techo -e \\\"Usage :\\n\\t\\$0${posexample}${optexample}${flagexample}${nestedexample}\\\";\n\tfi\";\nif [ \"$hasSubCmd\" == \"0\" ]; then\n\techo -e \"\n\tfi\n\t\";\nfi\necho -e \"\n}\n\";\n# verbose log function\nif [ \"$_arg_use_verbose\" != \"off\" ]; then\n\tsource \"$SCRIPT_ROOT_DIR/verbose/logger\" \"${verboseDecArg[@]}\";\nfi\n\n# xdg helper functions\nif [ \"$_arg_xdg\" != \"\" ]; then\n\tsource \"$SCRIPT_ROOT_DIR/xdg/functions\" \"${xdgDecArg[@]}\";\nfi\n\n# TODO: handle repeat-min and repeat-max\n# actual parsing\necho -e \"\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test \\$# -gt 0\n\tdo\n\t\t_key=\\\"\\$1\\\"\n\t\tcase \\\"\\$_key\\\" in\";\nfor opt in \"${_arg_opt[@]}\"; do\n\teval \"source $SCRIPT_ROOT_DIR/opt/parser $opt\" | sed -e 's/^/\\t\\t\\t/';\ndone\n\nfor flag in \"${_arg_flag[@]}\"; do\n\teval \"source $SCRIPT_ROOT_DIR/flag/parser $flag\" | sed -e 's/^/\\t\\t\\t/';\ndone\n\nfor nested in \"${_arg_nested[@]}\"; do\n\teval \"source $SCRIPT_ROOT_DIR/nested/parser $nested\" | sed -e 's/^/\\t\\t\\t/';\ndone\n\nif [[ \"$hasSubCmd\" == \"0\" ]]; then\n\thelpDecArg+=(\"--has-subcommand\")\nfi\nsource \"$SCRIPT_ROOT_DIR/help/parser\" \"${helpDecArg[@]}\" | sed -e 's/^/\\t\\t\\t/';\n\nif [ \"$_arg_set_version\" != \"\" ] && [ \"$_arg_version_opt\" != \"off\" ]; then\n\tsource \"$SCRIPT_ROOT_DIR/version/parser\" \"${versionDecArg[@]}\" | sed -e 's/^/\\t\\t\\t/';\nfi\n\nif [ \"$_arg_use_verbose\" != \"off\" ]; then\n\tsource \"$SCRIPT_ROOT_DIR/verbose/parser\" \"${verboseDecArg[@]}\" | sed -e 's/^/\\t\\t\\t/';\nfi\n\nif [ \"$_arg_parse_leftovers\" == \"on\" ]; then\n\techo -e \"\\t\\t\\t\\t# parsing leftovers\n\t\t\t\t--*)\n\t\t\t\t\tif [[ \\\"\\$2\\\" =~ ^--([^=]+)(=(.*))?$ ]] || [ \\\"\\$2\\\" = \\\"\\\" ]; then\n\t\t\t\t\t\t_arg_parsed_${_arg_leftovers_name}[\\\"\\${1#--}\\\"]=\\\"on\\\"\n\t\t\t\t\telif [[ \\\"\\$1\\\" =~ ^--([^=]+)=(.*)$ ]]; then\n\t\t\t\t\t\t_arg_parsed_${_arg_leftovers_name}[\\\"\\${BASH_REMATCH[1]}\\\"]=\\\"\\${BASH_REMATCH[2]}\\\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_arg_parsed_${_arg_leftovers_name}[\\\"\\${1#--}\\\"]=\\\"\\${2}\\\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\";\nfi\necho -e \"\\t\\t\\t\\t*)\n\t\t\t\t_last_positional=\\\"\\$1\\\"\n\t\t\t\t_positionals+=(\\\"\\$_last_positional\\\")\n\t\t\t\t_positionals_count=\\$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\\\"${reqPos[*]}\\\"\";\n\nif [ \"$_arg_leftovers\" == \"off\" ]; then\n\techo -e \"\tif [ \\\"\\${_positionals_count}\\\" -gt ${maxPos} ] && [ \\\"\\$_helpHasBeenPrinted\\\" == \\\"1\\\" ];then\n\t\t_PRINT_HELP=yes die \\\"FATAL ERROR: There were spurious positional arguments --- we expect at most $maxPos (namely: \\$_required_args_string), but got \\${_positionals_count} (the last one was: '\\${_last_positional}').\\\\\\\\n\\\\\\\\t\\${_positionals[*]}\\\" 1\n\tfi\";\nfi\n\n\techo -e \"\tif [ \\\"\\${_positionals_count}\\\" -lt ${minPos} ] && [ \\\"\\$_helpHasBeenPrinted\\\" == \\\"1\\\" ];then\n\t\t_PRINT_HELP=yes die \\\"FATAL ERROR: Not enough positional arguments - we require at least $minPos (namely: \\$_required_args_string), but got only \\${_positionals_count}.\\\\n\\\\t\\${_positionals[*]}\\\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=\\$1;\n\t_positional_names=\\\"$(for pos in \"${posArgNames[@]}\"; do printf \"_arg_%s \" \"$pos\";done;)\\\";\";\n\nif [ \"$_arg_leftovers\" != \"off\" ]; then\n\techo -e \"\t_leftovers_count=\\$((\\${#_positionals[@]} - ${#_arg_pos[@]}))\n\tfor ((ii = 0; ii < _leftovers_count; ii++));do\n\t\t_positional_names=\\\"\\$_positional_names _arg_leftovers[\\$((ii + 0))]\\\";\n\tdone\n\";\nfi\n\n\techo -e \"\tshift \\\"\\$_shift_for\\\"\n\tfor _positional_name in \\${_positional_names};do\n\t\ttest \\$# -gt 0 || break;\";\n\tif [ \"$_arg_leftovers\" == \"off\" ]; then\n\t\techo -e \"\t\teval \\\"if [ \\\\\\\"\\\\\\$_one_of\\${_positional_name}\\\\\\\" != \\\\\\\"\\\\\\\" ];then [[ \\\\\\\"\\\\\\${_one_of\\${_positional_name}[*]}\\\\\\\" =~ \\\\\\\"\\\\\\${1}\\\\\\\" ]];fi\\\" || die \\\"\\${_positional_name} must be one of: \\$(eval \\\"echo \\\\\\\"\\\\\\${_one_of\\${_positional_name}[*]}\\\\\\\"\\\")\\\" 1;\";\n\t\techo -e \"\t\tlocal _match_var=\\\"_match\\${_positional_name}\\\";\n\t\tlocal _regex=\\\"\\${!_match_var}\\\";\n\t\tif [ -n \\\"\\$_regex\\\" ]; then\n\t\t\t[[ \\\"\\${1}\\\" =~ \\$_regex ]] || die \\\"\\${_positional_name} does not match pattern: \\$_regex\\\"\n\t\tfi\";\n\t\tif [[ \"$hasSubCmd\" == \"0\" ]]; then\n\t\t\techo -e \"\t\t$(eval \"source $SCRIPT_ROOT_DIR/pos/subcmd-assign ${_arg_pos[0]}\")\";\n\t\tfi\n\telse\n\t\techo \"\t\tif ! [[ \\\"\\$_positional_name\\\" =~ \\\"_arg_$_arg_leftovers_name\\\" ]];then\n\t\t\teval \\\"if [ \\\\\\\"\\\\\\$_one_of\\${_positional_name}\\\\\\\" != \\\\\\\"\\\\\\\" ];then [[ \\\\\\\"\\\\\\${_one_of\\${_positional_name}[*]}\\\\\\\" =~ \\\\\\\"\\\\\\${1}\\\\\\\" ]];fi\\\" || die \\\"\\${_positional_name} must be one of: \\$(eval \\\"echo \\\\\\\"\\\\\\${_one_of\\${_positional_name}[*]}\\\\\\\"\\\")\\\" 1;\"\n        echo \"\t\t\tlocal _match_var=\\\"_match\\${_positional_name}\\\";\n\t\t\tlocal _regex=\\\"\\${!_match_var}\\\";\n\t\t\tif [ -n \\\"\\$_regex\\\" ]; then\n\t\t\t\t[[ \\\"\\${1}\\\" =~ \\$_regex ]] || die \\\"\\${_positional_name} does not match pattern: \\$_regex\\\"\n\t\t\tfi\"\n\t\tif [[ \"$hasSubCmd\" == \"0\" ]]; then\n\t\t\techo -e \"\t\t\t$(eval \"source $SCRIPT_ROOT_DIR/pos/subcmd-assign ${_arg_pos[0]}\")\";\n\t\tfi\n\t\techo \"\t\tfi\";\n\tfi\n\techo -e \"\t\teval \\\"\\$_positional_name=\\\\\\${1}\\\" || die \\\"Error during argument parsing, possibly an ParseArger bug.\\\" 1;\";\n\n\techo -e \"\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \\\"DEBUG: \\$0 \\$@\\\";\n\t\";\nposI=0;\nfor pos in \"${posArgNames[@]}\"; do\n\techo -e \"\techo -e \\\"\\t${posNames[$posI]}: \\${_arg_${pos}}\\\";\";\n\tposI=$((posI+1));\ndone\nposI=0;\nfor opt in \"${optArgNames[@]}\"; do\n\tforRepeating=$(eval \"source $SCRIPT_ROOT_DIR/opt/is-repeating ${_arg_opt[posI]}\");\n\tif [ \"$forRepeating\" == \"0\" ];then\n\t\tforRepeating=\"[*]\";\n\telse\n\t\tforRepeating=\"\";\n\tfi\n\techo -e \"\techo -e \\\"\\t${optNames[$posI]}: \\${_arg_${opt}${forRepeating}}\\\";\";\n\tposI=$((posI+1));\ndone\nposI=0;\nfor flag in \"${flagArgNames[@]}\"; do\n\techo -e \"\techo -e \\\"\\t${flagNames[$posI]}: \\${_arg_${flag}}\\\";\";\n\tposI=$((posI+1));\ndone\nfor nested in \"${nestedArgNames[@]}\"; do\n\techo -e \"\techo -e \\\"\\t${nested}: \\${_arg_${nested}}\\\";\";\n\techo -e \"\\tfor _tmp_k_${nested} in \\\"\\${!_arg_ns_${nested}[@]}\\\"; do\n\t\techo -e \\\"\\t${nested}-\\$_tmp_k_${nested}: \\${_arg_ns_${nested}[\\$_tmp_k_${nested}]}\\\";\n\tdone\";\n\tposI=$((posI+1));\ndone\nif [ \"$_arg_leftovers\" != \"off\" ]; then\n\techo -e \"\techo -e \\\"\\t${_arg_leftovers_name}: \\${_arg_${_arg_leftovers_name}[*]}\\\";\";\nfi\necho -e \"\n}\n\";\n\nif [ \"$_arg_set_version\" != \"\" ] && [ \"$_arg_version_opt\" != \"off\" ]; then\n\techo -e \"\nprint_version()\n{\n\techo \\\"${_arg_set_version}\\\";\n}\n\"\nfi\n\necho -e \"\non_interrupt() {\n\tdie \"Process aborted!\" 130;\n}\n\"\n\nif [ \"${#_arg_dependencies[@]}\" -gt 0 ]; then\n\techo \"__missing_dependencies=()\";\n\tfor _dep in \"${_arg_dependencies[@]}\"; do\n\t\techo -e \"if ! command -v \\\"$_dep\\\" &> /dev/null; then\n\t__missing_dependencies+=(\\\"$_dep\\\");\nfi\";\n\tdone\n\techo -e \"if [ \\\"\\${#__missing_dependencies[@]}\\\" -gt 0 ]; then\n\tdie \\\"Missing dependencies: \\${__missing_dependencies[*]}\\\" 1;\nfi\";\nfi\n\necho -e \"\nparse_commandline \\\"\\$@\\\";\nhandle_passed_args_count;\nassign_positional_args 1 \\\"\\${_positionals[@]}\\\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n\";\n# xdg_init call\nif [ \"$_arg_xdg\" != \"\" ]; then\n\techo \"xdg_init;\";\nfi\nfor opt in \"${_arg_opt[@]}\"; do\n\teval \"source $SCRIPT_ROOT_DIR/opt/check-required $opt\";\ndone\necho -e \"\n\";\nif [[ \"$hasSubCmd\" == \"0\" ]]; then\n\techo -e \"$(eval \"source $SCRIPT_ROOT_DIR/pos/subcmd-handle ${_arg_pos[0]}\")\";\nfi\n\necho -e \"\n# ${paCmtTrgr}parsing-end\n# print_debug \\\"\\$@\\\"\n# ${paCmtTrgr}end\";\n\n# history\nif [ \"$_arg_history\" != \"\" ]; then\n\t_hsCmd=(history);\n\n\t_histTtQty=$((_arg_history + 0));\n\t_hCmd=();\n\tif [ \"$_arg_history_offset\" != \"\" ]; then\n\t\t_histTtQty=$((_histTtQty + _arg_history_offset));\n\t\t_hCmd+=(head \"-${_arg_history}\");\n\tfi\n\t_tlCmd=(tail \"-${_histTtQty}\");\n\n\tif [ \"$_arg_history_file\" != \"\" ]; then\n\t\t_tmphistRes=$(HISTFILE=\"$_arg_history_file\" history -r; history | \"${_tlCmd[@]}\");\n\telse\n\t\t_tmphistRes=$(history | \"${_tlCmd[@]}\");\n\tfi\n\n\tif [ \"${#_hCmd[@]}\" -gt 0 ]; then\n\t\t_tmphistRes=$(echo \"$_tmphistRes\" | \"${_hCmd[@]}\");\n\tfi\n\techo \"$_tmphistRes\" | while IFS= read -r history_line\n\tdo\n\t\tif echo \"$history_line\" | grep -q \"^ [0-9]\\+  : [0-9]\\+:[0-9]\\+;\"; then\n\t\t\t# zsh history format\n\t\t\thistRes=$(echo \"$history_line\" | awk -F';' '{print $2}')\n\t\telif echo \"$history_line\" | grep -q \"^[0-9]\\+ \\* [0-9]\\+ \"; then\n\t\t\t# bash history format with HISTTIMEFORMAT set\n\t\t\thistRes=$(echo \"$history_line\" | cut -d ' ' -f5-)\n\t\telse\n\t\t\t# default bash history format\n\t\t\thistRes=$(echo \"$history_line\" | cut -d ' ' -f2-)\n\t\tfi\n\t\techo -e \"$histRes\";\n\tdone\nfi\n",
  "/parseArger/bin/pos/help": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger help string for arguments\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces --repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces --repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt subcommand-directory \"directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n# @parseArger opt subcommand-variable \"array variable containing subcommand parts, force subcommand\" --default-value \"__subcommand\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt match \"regex match validation\"\n# @parseArger flag subcommand-run \"run subcommand, forces sub command\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag optional \"optional\"\n# @parseArger flag subcommand \"is a subcommand\"\n# @parseArger flag subcommand-use-leftovers \"add leftover arguments to subcommand, forces subcommand\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/pos\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_subcommand_directory=\n_arg_subcommand_variable=\"__subcommand\"\n_arg_complete=()\n_arg_complete_custom=()\n_arg_match=\n# FLAGS\n_arg_subcommand_run=\"off\"\n_arg_repeat=\"off\"\n_arg_optional=\"off\"\n_arg_subcommand=\"off\"\n_arg_subcommand_use_leftovers=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger help string for arguments:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces --repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces --repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t--subcommand-directory <subcommand-directory>: directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n\techo -e \"\t--subcommand-variable <subcommand-variable>: array variable containing subcommand parts, force subcommand [default: ' __subcommand ']\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--match <match>: regex match validation\"\n\techo -e \"\t--subcommand-run|--no-subcommand-run: run subcommand, forces sub command\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--optional|--no-optional: optional\"\n\techo -e \"\t--subcommand|--no-subcommand: is a subcommand\"\n\techo -e \"\t--subcommand-use-leftovers|--no-subcommand-use-leftovers: add leftover arguments to subcommand, forces subcommand\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--subcommand-directory <value>] [--subcommand-variable <value>] [--complete <value>] [--complete-custom <value>] [--match <value>] [--[no-]subcommand-run] [--[no-]repeat] [--[no-]optional] [--[no-]subcommand] [--[no-]subcommand-use-leftovers]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_directory=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-directory=*)\n\t\t\t\t_arg_subcommand_directory=\"${_key##--subcommand-directory=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-variable)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_variable=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-variable=*)\n\t\t\t\t_arg_subcommand_variable=\"${_key##--subcommand-variable=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--match)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_match=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--match=*)\n\t\t\t\t_arg_match=\"${_key##--match=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"off\"\n\t\t\t\t;;\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--optional)\n\t\t\t\t_arg_optional=\"on\"\n\t\t\t\t;;\n\t\t\t--no-optional)\n\t\t\t\t_arg_optional=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand)\n\t\t\t\t_arg_subcommand=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand)\n\t\t\t\t_arg_subcommand=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t--quiet)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\"\n\t\tlocal _regex=\"${!_match_var}\"\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\targ-name: ${_arg_arg_name}\";\n\techo -e \"\tdescription: ${_arg_description}\";\n\techo -e \"\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\tsubcommand-directory: ${_arg_subcommand_directory}\";\n\techo -e \"\tsubcommand-variable: ${_arg_subcommand_variable}\";\n\techo -e \"\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\tmatch: ${_arg_match}\";\n\techo -e \"\tsubcommand-run: ${_arg_subcommand_run}\";\n\techo -e \"\trepeat: ${_arg_repeat}\";\n\techo -e \"\toptional: ${_arg_optional}\";\n\techo -e \"\tsubcommand: ${_arg_subcommand}\";\n\techo -e \"\tsubcommand-use-leftovers: ${_arg_subcommand_use_leftovers}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nSCRIPT_ROOT_DIR=\"\"/parseArger/bin/pos\"/..\";\n\n# shellcheck source=../utils\nsource \"${SCRIPT_ROOT_DIR}/utils\";\n\noptHelp=\"${_arg_arg_name}: ${_arg_description}\";\n\nif [ \"$_arg_repeat_min\" -gt \"1\" ] || [ \"$_arg_repeat_max\" != \"\" ]; then\n  _arg_repeat=\"on\"\nfi\nif [ \"$_arg_repeat\" != \"off\" ]; then\n  optHelp+=\", repeatable (${_arg_repeat_min}-${_arg_repeat_max})\";\nfi\n\nif [ \"$_arg_optional\" != \"off\" ]; then\n\toptHelp+=\", optional\";\nfi\n\nif [ \"$_arg_default_value\" != \"\" ]; then\n\toptHelp+=\" [default: '${_arg_default_value}']\";\nfi\n\nif [ \"$_arg_subcommand_directory\" != \"\" ]; then\n\tif [ -d \"$_arg_subcommand_directory\" ]; then\n\t\t_arg_subcommand=\"on\";\n\t\t# Searching in the current directory\n\t\tfor file in \"$_arg_subcommand_directory/\"*; do\n\t\t\ttname=\"$(basename \"$file\")\";\n\t\t\tif ! [[ \"${_arg_one_of[*]}\" =~ \" $tname \" ]] && [ -f \"$file\" ] && parsearger_is_pa_file \"$file\"; then\n\t\t\t\t_arg_one_of+=(\"$tname\");\n\t\t\tfi\n\t\tdone\n\tfi\nfi\n\nif [ \"$_arg_subcommand_run\" != \"off\" ]; then\n\t_arg_subcommand=\"on\";\nfi\n\nif [ \"$_arg_subcommand_use_leftovers\" != \"off\" ]; then\n\t_arg_subcommand=\"on\";\nfi\n\nif [ \"$_arg_subcommand_variable\" != \"__subcommand\" ]; then\n\toutStr+=\" --subcommand\";\nfi\n\nif [ \"$_arg_subcommand\" != \"off\" ]; then\n\toutStr+=\" --subcommand\";\nfi\n\nif [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n\toptHelp+=\" [one of\";\n\tfor _oof in \"${_arg_one_of[@]}\"; do\n\t\toptHelp+=\" '$_oof'\";\n\tdone\n\toptHelp+=\"]\";\nfi\n\necho -e \"\\techo -e \\\"\\t${optHelp}\\\"\";\n",
  "/parseArger/bin/pos/html": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"positional argument to html input\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces --repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces --repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt subcommand-directory \"directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n# @parseArger opt subcommand-variable \"array variable containing subcommand parts, force subcommand\" --default-value \"__subcommand\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt command \"command string, default to file \"\n# @parseArger opt form-class \"form html class\"\n# @parseArger opt input-container-class \"input container class\" --default-value \"form-group\"\n# @parseArger opt input-class \"input class\" --default-value \"form-control\"\n# @parseArger opt label-class \"label class\" --default-value \"form-label\"\n# @parseArger opt select-class \"select class\" --default-value \"form-select\"\n# @parseArger opt checkbox-container-class \"checkbox and radio class\" --default-value \"form-check\" --alias radio-container-class\n# @parseArger opt checkbox-class \"checkbox and radio class\" --default-value \"form-check-input\" --alias radio-class\n# @parseArger opt checkbox-label-class \"checkbox and radio label class\" --default-value \"form-check-label\" --alias radio-label-class\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag optional \"optional\"\n# @parseArger flag subcommand \"is a subcommand\"\n# @parseArger flag subcommand-run \"run subcommand, forces sub command\"\n# @parseArger flag subcommand-use-leftovers \"add leftover arguments to subcommand, forces subcommand\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/pos\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_subcommand_directory=\n_arg_subcommand_variable=\"__subcommand\"\n_arg_complete=()\n_arg_complete_custom=()\n_arg_command=\n_arg_form_class=\n_arg_input_container_class=\"form-group\"\n_arg_input_class=\"form-control\"\n_arg_label_class=\"form-label\"\n_arg_select_class=\"form-select\"\n_arg_checkbox_container_class=\"form-check\"\n_arg_checkbox_class=\"form-check-input\"\n_arg_checkbox_label_class=\"form-check-label\"\n# FLAGS\n_arg_repeat=\"off\"\n_arg_optional=\"off\"\n_arg_subcommand=\"off\"\n_arg_subcommand_run=\"off\"\n_arg_subcommand_use_leftovers=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"positional argument to html input:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces --repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces --repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t--subcommand-directory <subcommand-directory>: directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n\techo -e \"\t--subcommand-variable <subcommand-variable>: array variable containing subcommand parts, force subcommand [default: ' __subcommand ']\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--command <command>: command string, default to file \"\n\techo -e \"\t--form-class <form-class>: form html class\"\n\techo -e \"\t--input-container-class <input-container-class>: input container class [default: ' form-group ']\"\n\techo -e \"\t--input-class <input-class>: input class [default: ' form-control ']\"\n\techo -e \"\t--label-class <label-class>: label class [default: ' form-label ']\"\n\techo -e \"\t--select-class <select-class>: select class [default: ' form-select ']\"\n\techo -e \"\t--checkbox-container-class|--radio-container-class <checkbox-container-class>: checkbox and radio class [default: ' form-check ']\"\n\techo -e \"\t--checkbox-class|--radio-class <checkbox-class>: checkbox and radio class [default: ' form-check-input ']\"\n\techo -e \"\t--checkbox-label-class|--radio-label-class <checkbox-label-class>: checkbox and radio label class [default: ' form-check-label ']\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--optional|--no-optional: optional\"\n\techo -e \"\t--subcommand|--no-subcommand: is a subcommand\"\n\techo -e \"\t--subcommand-run|--no-subcommand-run: run subcommand, forces sub command\"\n\techo -e \"\t--subcommand-use-leftovers|--no-subcommand-use-leftovers: add leftover arguments to subcommand, forces subcommand\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--subcommand-directory <value>] [--subcommand-variable <value>] [--complete <value>] [--complete-custom <value>] [--command <value>] [--form-class <value>] [--input-container-class <value>] [--input-class <value>] [--label-class <value>] [--select-class <value>] [--checkbox-container-class <value>] [--checkbox-class <value>] [--checkbox-label-class <value>] [--[no-]repeat] [--[no-]optional] [--[no-]subcommand] [--[no-]subcommand-run] [--[no-]subcommand-use-leftovers]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_directory=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-directory=*)\n\t\t\t\t_arg_subcommand_directory=\"${_key##--subcommand-directory=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-variable)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_variable=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-variable=*)\n\t\t\t\t_arg_subcommand_variable=\"${_key##--subcommand-variable=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--command)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_command=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--command=*)\n\t\t\t\t_arg_command=\"${_key##--command=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--form-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_form_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--form-class=*)\n\t\t\t\t_arg_form_class=\"${_key##--form-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--input-container-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_input_container_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--input-container-class=*)\n\t\t\t\t_arg_input_container_class=\"${_key##--input-container-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--input-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_input_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--input-class=*)\n\t\t\t\t_arg_input_class=\"${_key##--input-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--label-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_label_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--label-class=*)\n\t\t\t\t_arg_label_class=\"${_key##--label-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--select-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_select_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--select-class=*)\n\t\t\t\t_arg_select_class=\"${_key##--select-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--radio-container-class|--checkbox-container-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_checkbox_container_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--checkbox-container-class=*)\n\t\t\t\t_arg_checkbox_container_class=\"${_key##--checkbox-container-class=}\"\n\t\t\t\t;;\n\t\t\t--radio-container-class=*)\n\t\t\t\t_arg_checkbox_container_class=\"${_key##--radio-container-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--radio-class|--checkbox-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_checkbox_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--checkbox-class=*)\n\t\t\t\t_arg_checkbox_class=\"${_key##--checkbox-class=}\"\n\t\t\t\t;;\n\t\t\t--radio-class=*)\n\t\t\t\t_arg_checkbox_class=\"${_key##--radio-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--radio-label-class|--checkbox-label-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_checkbox_label_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--checkbox-label-class=*)\n\t\t\t\t_arg_checkbox_label_class=\"${_key##--checkbox-label-class=}\"\n\t\t\t\t;;\n\t\t\t--radio-label-class=*)\n\t\t\t\t_arg_checkbox_label_class=\"${_key##--radio-label-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--optional)\n\t\t\t\t_arg_optional=\"on\"\n\t\t\t\t;;\n\t\t\t--no-optional)\n\t\t\t\t_arg_optional=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand)\n\t\t\t\t_arg_subcommand=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand)\n\t\t\t\t_arg_subcommand=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tsubcommand-directory: ${_arg_subcommand_directory}\";\n\techo -e \"\\tsubcommand-variable: ${_arg_subcommand_variable}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\\tcommand: ${_arg_command}\";\n\techo -e \"\\tform-class: ${_arg_form_class}\";\n\techo -e \"\\tinput-container-class: ${_arg_input_container_class}\";\n\techo -e \"\\tinput-class: ${_arg_input_class}\";\n\techo -e \"\\tlabel-class: ${_arg_label_class}\";\n\techo -e \"\\tselect-class: ${_arg_select_class}\";\n\techo -e \"\\tcheckbox-container-class: ${_arg_checkbox_container_class}\";\n\techo -e \"\\tcheckbox-class: ${_arg_checkbox_class}\";\n\techo -e \"\\tcheckbox-label-class: ${_arg_checkbox_label_class}\";\n\techo -e \"\\trepeat: ${_arg_repeat}\";\n\techo -e \"\\toptional: ${_arg_optional}\";\n\techo -e \"\\tsubcommand: ${_arg_subcommand}\";\n\techo -e \"\\tsubcommand-run: ${_arg_subcommand_run}\";\n\techo -e \"\\tsubcommand-use-leftovers: ${_arg_subcommand_use_leftovers}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n_arg_command=\"${_arg_command// /_}\";\n\ninptCmn=\"pa-type=\\\"pos\\\" name=\\\"${_arg_arg_name}\\\" id=\\\"${_arg_arg_name}\\\"\";\n\nif [ \"$_arg_optional\" == \"off\" ]; then\n\tinptCmn+=\" required\";\nfi\n\nif [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n\tinpuStr=\"<select ${inptCmn} class=\\\"${_arg_select_class}\\\">\\n\";\n\tfor oof in \"${_arg_one_of[@]}\"; do\n\t\tinpuStr+=\"\\n\\t\\t<option value=\\\"${oof}\\\">${oof}</option>\";\n\tdone\n\tinpuStr+=\"\\n\\t</select>\";\nelse\n\tinpuStr=\"<input ${inptCmn} type=\\\"text\\\" class=\\\"${_arg_input_class}\\\" />\";\nfi\n\necho -e \"<div class=\\\"${_arg_input_container_class}\\\">\n\t<label for=\\\"${_arg_arg_name}\\\" class=\\\"${_arg_label_class}\\\">${_arg_arg_name}</label>\n\t<span class=\\\"input-help\\\">${_arg_description}</span>\n\t${inpuStr}\n</div>\";\n",
  "/parseArger/bin/pos/completely": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger string to declare a new option\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces --repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces --repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt subcommand-directory \"directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n# @parseArger opt subcommand-variable \"array variable containing subcommand parts, force subcommand\" --default-value \"__subcommand\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag optional \"optional\"\n# @parseArger flag subcommand \"is a subcommand\"\n# @parseArger flag subcommand-run \"run subcommand, forces sub command\"\n# @parseArger flag subcommand-use-leftovers \"add leftover arguments to subcommand, forces subcommand\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/pos\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_subcommand_directory=\n_arg_subcommand_variable=\"__subcommand\"\n_arg_complete=()\n_arg_complete_custom=()\n# FLAGS\n_arg_repeat=\"off\"\n_arg_optional=\"off\"\n_arg_subcommand=\"off\"\n_arg_subcommand_run=\"off\"\n_arg_subcommand_use_leftovers=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger string to declare a new option:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces --repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces --repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t--subcommand-directory <subcommand-directory>: directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n\techo -e \"\t--subcommand-variable <subcommand-variable>: array variable containing subcommand parts, force subcommand [default: ' __subcommand ']\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--optional|--no-optional: optional\"\n\techo -e \"\t--subcommand|--no-subcommand: is a subcommand\"\n\techo -e \"\t--subcommand-run|--no-subcommand-run: run subcommand, forces sub command\"\n\techo -e \"\t--subcommand-use-leftovers|--no-subcommand-use-leftovers: add leftover arguments to subcommand, forces subcommand\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--subcommand-directory <value>] [--subcommand-variable <value>] [--complete <value>] [--complete-custom <value>] [--[no-]repeat] [--[no-]optional] [--[no-]subcommand] [--[no-]subcommand-run] [--[no-]subcommand-use-leftovers]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_directory=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-directory=*)\n\t\t\t\t_arg_subcommand_directory=\"${_key##--subcommand-directory=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-variable)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_variable=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-variable=*)\n\t\t\t\t_arg_subcommand_variable=\"${_key##--subcommand-variable=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--optional)\n\t\t\t\t_arg_optional=\"on\"\n\t\t\t\t;;\n\t\t\t--no-optional)\n\t\t\t\t_arg_optional=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand)\n\t\t\t\t_arg_subcommand=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand)\n\t\t\t\t_arg_subcommand=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tsubcommand-directory: ${_arg_subcommand_directory}\";\n\techo -e \"\\tsubcommand-variable: ${_arg_subcommand_variable}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\\trepeat: ${_arg_repeat}\";\n\techo -e \"\\toptional: ${_arg_optional}\";\n\techo -e \"\\tsubcommand: ${_arg_subcommand}\";\n\techo -e \"\\tsubcommand-run: ${_arg_subcommand_run}\";\n\techo -e \"\\tsubcommand-use-leftovers: ${_arg_subcommand_use_leftovers}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nfor oof in \"${_arg_one_of[@]}\"; do\n\techo \"- ${oof}\";\ndone\n\nif [ \"${#_arg_complete[@]}\" -gt 0 ]; then\n\tfor _cmpl in \"${_arg_complete[@]}\"; do\n\t\techo \"- <${_cmpl}>\";\n\tdone\nfi\nif [ \"${#_arg_complete_custom[@]}\" -gt 0 ]; then\n\tfor _cmpl in \"${_arg_complete_custom[@]}\"; do\n\t\techo \"- \\$(${_cmpl})\";\n\tdone\nfi\n",
  "/parseArger/bin/pos/init": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger init string for agruments\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-leftovers leftovers --parse\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces --repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces --repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt subcommand-directory \"directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n# @parseArger opt subcommand-variable \"array variable containing subcommand parts, force subcommand\" --default-value \"__subcommand\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt match \"regex match validation\"\n# @parseArger flag subcommand-run \"run subcommand, forces sub command\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag optional \"optional\"\n# @parseArger flag subcommand \"is a subcommand\"\n# @parseArger flag subcommand-use-leftovers \"add leftover arguments to subcommand, forces subcommand\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/pos\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_subcommand_directory=\n_arg_subcommand_variable=\"__subcommand\"\n_arg_complete=()\n_arg_complete_custom=()\n_arg_match=\n# FLAGS\n_arg_subcommand_run=\"off\"\n_arg_repeat=\"off\"\n_arg_optional=\"off\"\n_arg_subcommand=\"off\"\n_arg_subcommand_use_leftovers=\"off\"\n# NESTED\n# LEFTOVERS\n_arg_leftovers=()\n# LEFTOVERS\n\tdeclare -A _arg_parsed_leftovers\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger init string for agruments:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces --repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces --repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t--subcommand-directory <subcommand-directory>: directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n\techo -e \"\t--subcommand-variable <subcommand-variable>: array variable containing subcommand parts, force subcommand [default: ' __subcommand ']\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--match <match>: regex match validation\"\n\techo -e \"\t--subcommand-run|--no-subcommand-run: run subcommand, forces sub command\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--optional|--no-optional: optional\"\n\techo -e \"\t--subcommand|--no-subcommand: is a subcommand\"\n\techo -e \"\t--subcommand-use-leftovers|--no-subcommand-use-leftovers: add leftover arguments to subcommand, forces subcommand\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--subcommand-directory <value>] [--subcommand-variable <value>] [--complete <value>] [--complete-custom <value>] [--match <value>] [--[no-]subcommand-run] [--[no-]repeat] [--[no-]optional] [--[no-]subcommand] [--[no-]subcommand-use-leftovers]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_directory=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-directory=*)\n\t\t\t\t_arg_subcommand_directory=\"${_key##--subcommand-directory=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-variable)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_variable=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-variable=*)\n\t\t\t\t_arg_subcommand_variable=\"${_key##--subcommand-variable=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--match)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_match=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--match=*)\n\t\t\t\t_arg_match=\"${_key##--match=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"off\"\n\t\t\t\t;;\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--optional)\n\t\t\t\t_arg_optional=\"on\"\n\t\t\t\t;;\n\t\t\t--no-optional)\n\t\t\t\t_arg_optional=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand)\n\t\t\t\t_arg_subcommand=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand)\n\t\t\t\t_arg_subcommand=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t# parsing leftovers\n\t\t\t\t--*)\n\t\t\t\t\tif [[ \"$2\" =~ ^--([^=]+)(=(.*))?$ ]] || [ \"$2\" = \"\" ]; then\n\t\t\t\t\t\t_arg_parsed_leftovers[\"${1#--}\"]=\"on\"\n\t\t\t\t\telif [[ \"$1\" =~ ^--([^=]+)=(.*)$ ]]; then\n\t\t\t\t\t\t_arg_parsed_leftovers[\"${BASH_REMATCH[1]}\"]=\"${BASH_REMATCH[2]}\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_arg_parsed_leftovers[\"${1#--}\"]=\"${2}\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\t_leftovers_count=$((${#_positionals[@]} - 2))\n\tfor ((ii = 0; ii < _leftovers_count; ii++));do\n\t\t_positional_names=\"$_positional_names _arg_leftovers[$((ii + 0))]\";\n\tdone\n\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\tif ! [[ \"$_positional_name\" =~ \"_arg_leftovers\" ]];then\n\t\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\t\teval \"local _regex=\\$(eval \\\"echo \\\\\\\"\\\\\\$_match\\${_positional_name}\\\\\\\"\\\");if [ \\\"\\$_regex\\\" != \\\"\\\" ];then [[ \\\"\\${1}\\\" =~ \\$_regex ]] || die \\\"\\${_positional_name} does not match pattern: \\$_regex\\\";fi\";\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\targ-name: ${_arg_arg_name}\";\n\techo -e \"\tdescription: ${_arg_description}\";\n\techo -e \"\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\tsubcommand-directory: ${_arg_subcommand_directory}\";\n\techo -e \"\tsubcommand-variable: ${_arg_subcommand_variable}\";\n\techo -e \"\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\tmatch: ${_arg_match}\";\n\techo -e \"\tsubcommand-run: ${_arg_subcommand_run}\";\n\techo -e \"\trepeat: ${_arg_repeat}\";\n\techo -e \"\toptional: ${_arg_optional}\";\n\techo -e \"\tsubcommand: ${_arg_subcommand}\";\n\techo -e \"\tsubcommand-use-leftovers: ${_arg_subcommand_use_leftovers}\";\n\techo -e \"\tleftovers: ${_arg_leftovers[*]}\";\n\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nSCRIPT_ROOT_DIR=\"\"/parseArger/bin/pos\"/..\";\n\n# shellcheck source=../utils\nsource \"${SCRIPT_ROOT_DIR}/utils\";\n\ninitStr=\"_arg_${_arg_arg_name//-/_}=\\\"$_arg_default_value\\\";\";\n\nif [ \"$_arg_subcommand_directory\" != \"\" ]; then\n\tif [ -d \"$_arg_subcommand_directory\" ]; then\n\t\t_arg_subcommand=\"on\";\n\t\tfor file in \"$_arg_subcommand_directory/\"*; do\n\t\t\ttname=\"$(basename \"$file\")\";\n\t\t\tif ! [[ \"${_arg_one_of[*]}\" =~ \" $tname \" ]] && [ -f \"$file\" ] && parsearger_is_pa_file \"$file\"; then\n\t\t\t\t_arg_one_of+=(\"$tname\");\n\t\t\tfi\n\t\tdone\n\tfi\nfi\n\nif [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n\tinitStr+=\"\\n_one_of_arg_${_arg_arg_name//-/_}=(\";\n\tfor i in \"${_arg_one_of[@]}\"; do\n\t\tinitStr+=\"\\\"$i\\\" \";\n\tdone\n\tinitStr+=\");\";\nfi\n\nif [ \"$_arg_optional\" == \"on\" ]; then\n\tinitStr+=\"\\n_optional_positionals+=(\\\"_arg_${_arg_arg_name//-/_}\\\");\";\nfi\n\nif [ \"$_arg_subcommand_run\" != \"off\" ]; then\n\t_arg_subcommand=\"on\";\nfi\n\nif [ \"$_arg_subcommand_use_leftovers\" != \"off\" ]; then\n\t_arg_subcommand=\"on\";\nfi\n\nif [ \"$_arg_subcommand_variable\" != \"__subcommand\" ]; then\n\t_arg_subcommand=\"on\";\nfi\n\nif [ \"$_arg_subcommand\" == \"on\" ]; then\n\tinitStr+=\"\\n_arg_subcommand_arg=\\\"_arg_${_arg_arg_name//-/_}\\\";\";\n\tinitStr+=\"\\n${_arg_subcommand_variable}=();\";\nfi\n\nif [ \"$_arg_match\" != \"\" ]; then\n    initStr+=\"\\n_match_arg_${_arg_arg_name//-/_}=\\\"${_arg_match}\\\";\";\nfi\n\necho -e \"$initStr\";",
  "/parseArger/bin/pos/is-subcmd": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"is the arg a sub command\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces --repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces --repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt subcommand-directory \"directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n# @parseArger opt subcommand-variable \"array variable containing subcommand parts, force subcommand\" --default-value \"__subcommand\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt match \"regex match validation\"\n# @parseArger flag subcommand-run \"run subcommand, forces sub command\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag optional \"optional\"\n# @parseArger flag subcommand \"is a subcommand\"\n# @parseArger flag subcommand-use-leftovers \"add leftover arguments to subcommand, forces subcommand\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/pos\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_subcommand_directory=\n_arg_subcommand_variable=\"__subcommand\"\n_arg_complete=()\n_arg_complete_custom=()\n_arg_match=\n# FLAGS\n_arg_subcommand_run=\"off\"\n_arg_repeat=\"off\"\n_arg_optional=\"off\"\n_arg_subcommand=\"off\"\n_arg_subcommand_use_leftovers=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"is the arg a sub command:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces --repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces --repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t--subcommand-directory <subcommand-directory>: directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n\techo -e \"\t--subcommand-variable <subcommand-variable>: array variable containing subcommand parts, force subcommand [default: ' __subcommand ']\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--match <match>: regex match validation\"\n\techo -e \"\t--subcommand-run|--no-subcommand-run: run subcommand, forces sub command\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--optional|--no-optional: optional\"\n\techo -e \"\t--subcommand|--no-subcommand: is a subcommand\"\n\techo -e \"\t--subcommand-use-leftovers|--no-subcommand-use-leftovers: add leftover arguments to subcommand, forces subcommand\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--subcommand-directory <value>] [--subcommand-variable <value>] [--complete <value>] [--complete-custom <value>] [--match <value>] [--[no-]subcommand-run] [--[no-]repeat] [--[no-]optional] [--[no-]subcommand] [--[no-]subcommand-use-leftovers]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_directory=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-directory=*)\n\t\t\t\t_arg_subcommand_directory=\"${_key##--subcommand-directory=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-variable)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_variable=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-variable=*)\n\t\t\t\t_arg_subcommand_variable=\"${_key##--subcommand-variable=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--match)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_match=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--match=*)\n\t\t\t\t_arg_match=\"${_key##--match=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"off\"\n\t\t\t\t;;\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--optional)\n\t\t\t\t_arg_optional=\"on\"\n\t\t\t\t;;\n\t\t\t--no-optional)\n\t\t\t\t_arg_optional=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand)\n\t\t\t\t_arg_subcommand=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand)\n\t\t\t\t_arg_subcommand=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t--quiet)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\";\n\t\tlocal _regex=\"${!_match_var}\";\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\targ-name: ${_arg_arg_name}\";\n\techo -e \"\tdescription: ${_arg_description}\";\n\techo -e \"\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\tsubcommand-directory: ${_arg_subcommand_directory}\";\n\techo -e \"\tsubcommand-variable: ${_arg_subcommand_variable}\";\n\techo -e \"\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\tmatch: ${_arg_match}\";\n\techo -e \"\tsubcommand-run: ${_arg_subcommand_run}\";\n\techo -e \"\trepeat: ${_arg_repeat}\";\n\techo -e \"\toptional: ${_arg_optional}\";\n\techo -e \"\tsubcommand: ${_arg_subcommand}\";\n\techo -e \"\tsubcommand-use-leftovers: ${_arg_subcommand_use_leftovers}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nif [ \"$_arg_subcommand_directory\" != \"\" ]; then\n\tif [ -d \"$_arg_subcommand_directory\" ]; then\n\t\t_arg_subcommand=\"on\";\n\tfi\nfi\n\nif [ \"$_arg_subcommand_run\" != \"off\" ]; then\n\t_arg_subcommand=\"on\";\nfi\n\nif [ \"$_arg_subcommand_use_leftovers\" != \"off\" ]; then\n\t_arg_subcommand=\"on\";\nfi\n\nif [ \"$_arg_subcommand_variable\" != \"__subcommand\" ]; then\n\t_arg_subcommand=\"on\";\nfi\n\nif [ \"$_arg_subcommand\" != \"off\" ]; then\n\techo 0;\n\texit 0;\nfi\n\necho 1;\nexit 1;\n",
  "/parseArger/bin/pos/parser": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger parsing string for arguments\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces --repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces --repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt subcommand-directory \"directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n# @parseArger opt subcommand-variable \"array variable containing subcommand parts, force subcommand\" --default-value \"__subcommand\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt match \"regex match validation\"\n# @parseArger flag subcommand-run \"run subcommand, forces sub command\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag optional \"optional\"\n# @parseArger flag subcommand \"is a subcommand\"\n# @parseArger flag subcommand-use-leftovers \"add leftover arguments to subcommand, forces subcommand\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/pos\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_subcommand_directory=\n_arg_subcommand_variable=\"__subcommand\"\n_arg_complete=()\n_arg_complete_custom=()\n_arg_match=\n# FLAGS\n_arg_subcommand_run=\"off\"\n_arg_repeat=\"off\"\n_arg_optional=\"off\"\n_arg_subcommand=\"off\"\n_arg_subcommand_use_leftovers=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger parsing string for arguments:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces --repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces --repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t--subcommand-directory <subcommand-directory>: directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n\techo -e \"\t--subcommand-variable <subcommand-variable>: array variable containing subcommand parts, force subcommand [default: ' __subcommand ']\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--match <match>: regex match validation\"\n\techo -e \"\t--subcommand-run|--no-subcommand-run: run subcommand, forces sub command\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--optional|--no-optional: optional\"\n\techo -e \"\t--subcommand|--no-subcommand: is a subcommand\"\n\techo -e \"\t--subcommand-use-leftovers|--no-subcommand-use-leftovers: add leftover arguments to subcommand, forces subcommand\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--subcommand-directory <value>] [--subcommand-variable <value>] [--complete <value>] [--complete-custom <value>] [--match <value>] [--[no-]subcommand-run] [--[no-]repeat] [--[no-]optional] [--[no-]subcommand] [--[no-]subcommand-use-leftovers]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_directory=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-directory=*)\n\t\t\t\t_arg_subcommand_directory=\"${_key##--subcommand-directory=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-variable)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_variable=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-variable=*)\n\t\t\t\t_arg_subcommand_variable=\"${_key##--subcommand-variable=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--match)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_match=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--match=*)\n\t\t\t\t_arg_match=\"${_key##--match=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"off\"\n\t\t\t\t;;\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--optional)\n\t\t\t\t_arg_optional=\"on\"\n\t\t\t\t;;\n\t\t\t--no-optional)\n\t\t\t\t_arg_optional=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand)\n\t\t\t\t_arg_subcommand=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand)\n\t\t\t\t_arg_subcommand=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t--quiet)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\targ-name: ${_arg_arg_name}\";\n\techo -e \"\tdescription: ${_arg_description}\";\n\techo -e \"\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\tsubcommand-directory: ${_arg_subcommand_directory}\";\n\techo -e \"\tsubcommand-variable: ${_arg_subcommand_variable}\";\n\techo -e \"\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\tmatch: ${_arg_match}\";\n\techo -e \"\tsubcommand-run: ${_arg_subcommand_run}\";\n\techo -e \"\trepeat: ${_arg_repeat}\";\n\techo -e \"\toptional: ${_arg_optional}\";\n\techo -e \"\tsubcommand: ${_arg_subcommand}\";\n\techo -e \"\tsubcommand-use-leftovers: ${_arg_subcommand_use_leftovers}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n",
  "/parseArger/bin/pos/subcmd-assign": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger parsing string for arguments\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces --repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces --repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt subcommand-directory \"directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n# @parseArger opt subcommand-variable \"array variable containing subcommand parts, force subcommand\" --default-value \"__subcommand\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger flag subcommand-run \"run subcommand, forces sub command\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag optional \"optional\"\n# @parseArger flag subcommand \"is a subcommand\"\n# @parseArger flag subcommand-use-leftovers \"add leftover arguments to subcommand, forces subcommand\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/pos\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_subcommand_directory=\n_arg_subcommand_variable=\"__subcommand\"\n_arg_complete=()\n_arg_complete_custom=()\n# FLAGS\n_arg_subcommand_run=\"off\"\n_arg_repeat=\"off\"\n_arg_optional=\"off\"\n_arg_subcommand=\"off\"\n_arg_subcommand_use_leftovers=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger parsing string for arguments:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces --repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces --repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t--subcommand-directory <subcommand-directory>: directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n\techo -e \"\t--subcommand-variable <subcommand-variable>: array variable containing subcommand parts, force subcommand [default: ' __subcommand ']\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--subcommand-run|--no-subcommand-run: run subcommand, forces sub command\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--optional|--no-optional: optional\"\n\techo -e \"\t--subcommand|--no-subcommand: is a subcommand\"\n\techo -e \"\t--subcommand-use-leftovers|--no-subcommand-use-leftovers: add leftover arguments to subcommand, forces subcommand\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--subcommand-directory <value>] [--subcommand-variable <value>] [--complete <value>] [--complete-custom <value>] [--[no-]subcommand-run] [--[no-]repeat] [--[no-]optional] [--[no-]subcommand] [--[no-]subcommand-use-leftovers]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\n\t\t\t--subcommand-directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_directory=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-directory=*)\n\t\t\t\t_arg_subcommand_directory=\"${_key##--subcommand-directory=}\"\n\t\t\t\t;;\n\n\t\t\t--subcommand-variable)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_variable=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-variable=*)\n\t\t\t\t_arg_subcommand_variable=\"${_key##--subcommand-variable=}\"\n\t\t\t\t;;\n\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\n\t\t\t--subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"off\"\n\t\t\t\t;;\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--optional)\n\t\t\t\t_arg_optional=\"on\"\n\t\t\t\t;;\n\t\t\t--no-optional)\n\t\t\t\t_arg_optional=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand)\n\t\t\t\t_arg_subcommand=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand)\n\t\t\t\t_arg_subcommand=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tsubcommand-directory: ${_arg_subcommand_directory}\";\n\techo -e \"\\tsubcommand-variable: ${_arg_subcommand_variable}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\\tsubcommand-run: ${_arg_subcommand_run}\";\n\techo -e \"\\trepeat: ${_arg_repeat}\";\n\techo -e \"\\toptional: ${_arg_optional}\";\n\techo -e \"\\tsubcommand: ${_arg_subcommand}\";\n\techo -e \"\\tsubcommand-use-leftovers: ${_arg_subcommand_use_leftovers}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n_tgtdir=\"\";\nif [ \"${_arg_subcommand_directory}\" != \"\" ];then\n\t_tgtdir=\"${_arg_subcommand_directory}\";\n\t[[ $_tgtdir != */ ]] && _tgtdir+=\"/\";\nfi\n\n# if [[ \"$_tgtdir\" != /* ]]; then\n# \t_tgtdir=\"\\$_SCRIPT_DIR/${_tgtdir}\";\n# fi\n\necho -e \"\n\t\t\tif [ \\\"\\$_arg_subcommand_arg\\\" == \\\"\\$_positional_name\\\" ];then\n\t\t\t\tif [ -f \\\"$_tgtdir\\${1}\\\" ] && command -v \\\"$_tgtdir\\${1}\\\" > /dev/null 2>&1;then\n\t\t\t\t\t${_arg_subcommand_variable}+=(\\\"$_tgtdir\\${1}\\\");\n\t\t\t\telif [ -f \\\"\\$_SCRIPT_DIR/$_tgtdir\\${1}\\\" ] && command -v \\\"\\$_SCRIPT_DIR/$_tgtdir\\${1}\\\" > /dev/null 2>&1;then\n\t\t\t\t\t${_arg_subcommand_variable}+=(\\\"\\$_SCRIPT_DIR/$_tgtdir\\${1}\\\");\n\t\t\t\telif [[ \\\"$_tgtdir\\\" == \\$(basename \\\"\\$_SCRIPT_DIR\\\")* ]];then\n\t\t\t\t\tcmdToSub=\\\"\\$(basename \\\"\\$_SCRIPT_DIR\\\")\\\";\n\t\t\t\t\tcmdsubDir=\\\"$_tgtdir\\\";\n\t\t\t\t\t${_arg_subcommand_variable}+=(\\\"\\$_SCRIPT_DIR\\${cmdsubDir#\\\"\\${cmdToSub}\\\"}\\${1}\\\");\n\t\t\t\telse\n\t\t\t\t\t${_arg_subcommand_variable}+=(\\\"\\$_SCRIPT_DIR/$_tgtdir\\${1}\\\");\n\t\t\t\tfi\n\t\t\tfi\";\n",
  "/parseArger/bin/pos/subcmd-handle": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger parsing string for arguments\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces --repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces --repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt subcommand-directory \"directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n# @parseArger opt subcommand-variable \"array variable containing subcommand parts, force subcommand\" --default-value \"__subcommand\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger flag subcommand-run \"run subcommand, forces sub command\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag optional \"optional\"\n# @parseArger flag subcommand \"is a subcommand\"\n# @parseArger flag subcommand-use-leftovers \"add leftover arguments to subcommand, forces subcommand\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/pos\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_subcommand_directory=\n_arg_subcommand_variable=\"__subcommand\"\n_arg_complete=()\n_arg_complete_custom=()\n# FLAGS\n_arg_subcommand_run=\"off\"\n_arg_repeat=\"off\"\n_arg_optional=\"off\"\n_arg_subcommand=\"off\"\n_arg_subcommand_use_leftovers=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger parsing string for arguments:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces --repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces --repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t--subcommand-directory <subcommand-directory>: directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n\techo -e \"\t--subcommand-variable <subcommand-variable>: array variable containing subcommand parts, force subcommand [default: ' __subcommand ']\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--subcommand-run|--no-subcommand-run: run subcommand, forces sub command\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--optional|--no-optional: optional\"\n\techo -e \"\t--subcommand|--no-subcommand: is a subcommand\"\n\techo -e \"\t--subcommand-use-leftovers|--no-subcommand-use-leftovers: add leftover arguments to subcommand, forces subcommand\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--subcommand-directory <value>] [--subcommand-variable <value>] [--complete <value>] [--complete-custom <value>] [--[no-]subcommand-run] [--[no-]repeat] [--[no-]optional] [--[no-]subcommand] [--[no-]subcommand-use-leftovers]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_directory=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-directory=*)\n\t\t\t\t_arg_subcommand_directory=\"${_key##--subcommand-directory=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-variable)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_variable=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-variable=*)\n\t\t\t\t_arg_subcommand_variable=\"${_key##--subcommand-variable=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"off\"\n\t\t\t\t;;\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--optional)\n\t\t\t\t_arg_optional=\"on\"\n\t\t\t\t;;\n\t\t\t--no-optional)\n\t\t\t\t_arg_optional=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand)\n\t\t\t\t_arg_subcommand=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand)\n\t\t\t\t_arg_subcommand=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tsubcommand-directory: ${_arg_subcommand_directory}\";\n\techo -e \"\\tsubcommand-variable: ${_arg_subcommand_variable}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\\tsubcommand-run: ${_arg_subcommand_run}\";\n\techo -e \"\\trepeat: ${_arg_repeat}\";\n\techo -e \"\\toptional: ${_arg_optional}\";\n\techo -e \"\\tsubcommand: ${_arg_subcommand}\";\n\techo -e \"\\tsubcommand-use-leftovers: ${_arg_subcommand_use_leftovers}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\noutStr=\"\";\n\nif [ \"$_arg_subcommand_use_leftovers\" != \"off\" ]; then\n\toutStr+=\"${_arg_subcommand_variable}+=(\\\"\\${_arg_leftovers[@]}\\\");\\n\";\nfi\n\noutStr+=\"if [ \\\"\\$_triggerSCHelp\\\" == \\\"0\\\" ];then\n\t__subcommand+=(\\\"--help\\\");\nfi\nif [ \\\"\\$_verbose_level\\\" -ne \\\"0\\\" ];then\n\t__subcommand+=(\\\"--verbose\\\" \\\"\\$_verbose_level\\\");\nfi\n\";\nif [ \"$_arg_subcommand_run\" != \"off\" ]; then\n\toutStr+=\"\\\"\\${${_arg_subcommand_variable}[@]}\\\";\";\nfi\n\necho -e \"$outStr\";\n",
  "/parseArger/bin/pos/declaration": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger string to declare a new option\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces --repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces --repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt subcommand-directory \"directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n# @parseArger opt subcommand-variable \"array variable containing subcommand parts, force subcommand\" --default-value \"__subcommand\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt match \"regex match validation\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag optional \"optional\"\n# @parseArger flag subcommand \"is a subcommand\"\n# @parseArger flag subcommand-run \"run subcommand, forces sub command\"\n# @parseArger flag subcommand-use-leftovers \"add leftover arguments to subcommand, forces subcommand\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/pos\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_subcommand_directory=\n_arg_subcommand_variable=\"__subcommand\"\n_arg_complete=()\n_arg_complete_custom=()\n_arg_match=\n# FLAGS\n_arg_repeat=\"off\"\n_arg_optional=\"off\"\n_arg_subcommand=\"off\"\n_arg_subcommand_run=\"off\"\n_arg_subcommand_use_leftovers=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger string to declare a new option:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces --repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces --repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t--subcommand-directory <subcommand-directory>: directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n\techo -e \"\t--subcommand-variable <subcommand-variable>: array variable containing subcommand parts, force subcommand [default: ' __subcommand ']\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--match <match>: regex match validation\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--optional|--no-optional: optional\"\n\techo -e \"\t--subcommand|--no-subcommand: is a subcommand\"\n\techo -e \"\t--subcommand-run|--no-subcommand-run: run subcommand, forces sub command\"\n\techo -e \"\t--subcommand-use-leftovers|--no-subcommand-use-leftovers: add leftover arguments to subcommand, forces subcommand\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--subcommand-directory <value>] [--subcommand-variable <value>] [--complete <value>] [--complete-custom <value>] [--match <value>] [--[no-]repeat] [--[no-]optional] [--[no-]subcommand] [--[no-]subcommand-run] [--[no-]subcommand-use-leftovers]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_directory=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-directory=*)\n\t\t\t\t_arg_subcommand_directory=\"${_key##--subcommand-directory=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-variable)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_variable=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-variable=*)\n\t\t\t\t_arg_subcommand_variable=\"${_key##--subcommand-variable=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--match)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_match=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--match=*)\n\t\t\t\t_arg_match=\"${_key##--match=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--optional)\n\t\t\t\t_arg_optional=\"on\"\n\t\t\t\t;;\n\t\t\t--no-optional)\n\t\t\t\t_arg_optional=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand)\n\t\t\t\t_arg_subcommand=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand)\n\t\t\t\t_arg_subcommand=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\"\n\t\tlocal _regex=\"${!_match_var}\"\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\targ-name: ${_arg_arg_name}\";\n\techo -e \"\tdescription: ${_arg_description}\";\n\techo -e \"\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\tsubcommand-directory: ${_arg_subcommand_directory}\";\n\techo -e \"\tsubcommand-variable: ${_arg_subcommand_variable}\";\n\techo -e \"\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\tmatch: ${_arg_match}\";\n\techo -e \"\trepeat: ${_arg_repeat}\";\n\techo -e \"\toptional: ${_arg_optional}\";\n\techo -e \"\tsubcommand: ${_arg_subcommand}\";\n\techo -e \"\tsubcommand-run: ${_arg_subcommand_run}\";\n\techo -e \"\tsubcommand-use-leftovers: ${_arg_subcommand_use_leftovers}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nSCRIPT_ROOT_DIR=\"\"/parseArger/bin/pos\"/..\";\n\n# shellcheck source=../utils\nsource \"${SCRIPT_ROOT_DIR}/utils\";\n\noutStr=\"# @parse\";\noutStr+=\"Arger pos $_arg_arg_name \\\"${_arg_description}\\\"\"\n\nif [ \"$_arg_default_value\" != \"\" ]; then\n  outStr+=\" --default-value \\\"$_arg_default_value\\\"\"\nfi\n\nif [ \"$_arg_repeat_min\" -gt \"1\" ] || [ \"$_arg_repeat_max\" != \"\" ]; then\n  _arg_repeat=\"on\"\nfi\nif [ \"$_arg_repeat\" != \"off\" ]; then\n  outStr+=\" --repeat\";\n\tif [ \"$_arg_repeat_min\" != \"\" ]; then\n\t\toutStr+=\" --repeat-min $_arg_repeat_min\";\n\tfi\n\n\tif [ \"$_arg_repeat_max\" != \"\" ]; then\n\t\toutStr+=\" --repeat-max $_arg_repeat_max\";\n\tfi\nfi\n\nif [ \"$_arg_optional\" != \"off\" ]; then\n\toutStr+=\" --optional\";\nfi\n\nif [ \"$_arg_subcommand_directory\" != \"\" ]; then\n\tif [ -d \"$_arg_subcommand_directory\" ]; then\n\t\toutStr+=\" --subcommand-directory \\\"$_arg_subcommand_directory\\\"\";\n\t\t_arg_subcommand=\"on\";\n\t\t# TODO: do something to fix subcommand directory (if not in root dir, not working...)\n\t\tfor file in \"$_arg_subcommand_directory/\"*; do\n\t\t\ttname=\"$(basename \"$file\")\";\n\t\t\tif ! echo \" ${_arg_one_of[*]} \" | grep -q \" $tname \" && [ -f \"$file\" ] && parsearger_is_pa_file \"$file\"; then\n\t\t\t\t_arg_one_of+=(\"$tname\");\n\t\t\tfi\n\t\tdone\n\tfi\nfi\n\nif [ \"$_arg_subcommand_run\" != \"off\" ]; then\n\toutStr+=\" --subcommand-run\";\n\t_arg_subcommand=\"on\";\nfi\n\nif [ \"$_arg_subcommand_use_leftovers\" != \"off\" ]; then\n\toutStr+=\" --subcommand-use-leftovers\";\n\t_arg_subcommand=\"on\";\nfi\n\nif [ \"$_arg_subcommand_variable\" != \"__subcommand\" ]; then\n\toutStr+=\" --subcommand\";\nfi\n\nif [ \"$_arg_subcommand\" != \"off\" ]; then\n\toutStr+=\" --subcommand\";\nfi\n\nif [ \"${#_arg_complete[@]}\" != \"off\" ]; then\n\tfor _c in \"${_arg_complete[@]}\"; do\n\t\toutStr+=\" --complete \\\"$_c\\\"\";\n\tdone\nfi\n\nif [ \"${#_arg_complete_custom[@]}\" != \"off\" ]; then\n\tfor _c in \"${_arg_complete_custom[@]}\"; do\n\t\toutStr+=\" --complete-custom \\\"$_c\\\"\";\n\tdone\nfi\n\nif [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n\tfor _oof in \"${_arg_one_of[@]}\"; do\n\t\toutStr+=\" --one-of \\\"$_oof\\\"\";\n\tdone\nfi\n\necho -e \"$outStr\";\n",
  "/parseArger/bin/pos/subcmd-html": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"positional argument to html input\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces --repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces --repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt subcommand-directory \"directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n# @parseArger opt subcommand-variable \"array variable containing subcommand parts, force subcommand\" --default-value \"__subcommand\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt command \"command string, default to file \"\n# @parseArger opt form-class \"form html class\"\n# @parseArger opt input-container-class \"input container class\" --default-value \"form-group\"\n# @parseArger opt input-class \"input class\" --default-value \"form-control\"\n# @parseArger opt label-class \"label class\" --default-value \"form-label\"\n# @parseArger opt select-class \"select class\" --default-value \"form-select\"\n# @parseArger opt checkbox-container-class \"checkbox and radio class\" --default-value \"form-check\" --alias radio-container-class\n# @parseArger opt checkbox-class \"checkbox and radio class\" --default-value \"form-check-input\" --alias radio-class\n# @parseArger opt checkbox-label-class \"checkbox and radio label class\" --default-value \"form-check-label\" --alias radio-label-class\n# @parseArger opt parent-form \"parent form for result\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag optional \"optional\"\n# @parseArger flag subcommand \"is a subcommand\"\n# @parseArger flag subcommand-run \"run subcommand, forces sub command\"\n# @parseArger flag subcommand-use-leftovers \"add leftover arguments to subcommand, forces subcommand\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/pos\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_subcommand_directory=\n_arg_subcommand_variable=\"__subcommand\"\n_arg_complete=()\n_arg_complete_custom=()\n_arg_command=\n_arg_form_class=\n_arg_input_container_class=\"form-group\"\n_arg_input_class=\"form-control\"\n_arg_label_class=\"form-label\"\n_arg_select_class=\"form-select\"\n_arg_checkbox_container_class=\"form-check\"\n_arg_checkbox_class=\"form-check-input\"\n_arg_checkbox_label_class=\"form-check-label\"\n_arg_parent_form=\n# FLAGS\n_arg_repeat=\"off\"\n_arg_optional=\"off\"\n_arg_subcommand=\"off\"\n_arg_subcommand_run=\"off\"\n_arg_subcommand_use_leftovers=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"positional argument to html input:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces --repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces --repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t--subcommand-directory <subcommand-directory>: directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n\techo -e \"\t--subcommand-variable <subcommand-variable>: array variable containing subcommand parts, force subcommand [default: ' __subcommand ']\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--command <command>: command string, default to file \"\n\techo -e \"\t--form-class <form-class>: form html class\"\n\techo -e \"\t--input-container-class <input-container-class>: input container class [default: ' form-group ']\"\n\techo -e \"\t--input-class <input-class>: input class [default: ' form-control ']\"\n\techo -e \"\t--label-class <label-class>: label class [default: ' form-label ']\"\n\techo -e \"\t--select-class <select-class>: select class [default: ' form-select ']\"\n\techo -e \"\t--checkbox-container-class|--radio-container-class <checkbox-container-class>: checkbox and radio class [default: ' form-check ']\"\n\techo -e \"\t--checkbox-class|--radio-class <checkbox-class>: checkbox and radio class [default: ' form-check-input ']\"\n\techo -e \"\t--checkbox-label-class|--radio-label-class <checkbox-label-class>: checkbox and radio label class [default: ' form-check-label ']\"\n\techo -e \"\t--parent-form <parent-form>: parent form for result\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--optional|--no-optional: optional\"\n\techo -e \"\t--subcommand|--no-subcommand: is a subcommand\"\n\techo -e \"\t--subcommand-run|--no-subcommand-run: run subcommand, forces sub command\"\n\techo -e \"\t--subcommand-use-leftovers|--no-subcommand-use-leftovers: add leftover arguments to subcommand, forces subcommand\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--subcommand-directory <value>] [--subcommand-variable <value>] [--complete <value>] [--complete-custom <value>] [--command <value>] [--form-class <value>] [--input-container-class <value>] [--input-class <value>] [--label-class <value>] [--select-class <value>] [--checkbox-container-class <value>] [--checkbox-class <value>] [--checkbox-label-class <value>] [--parent-form <value>] [--[no-]repeat] [--[no-]optional] [--[no-]subcommand] [--[no-]subcommand-run] [--[no-]subcommand-use-leftovers]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_directory=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-directory=*)\n\t\t\t\t_arg_subcommand_directory=\"${_key##--subcommand-directory=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-variable)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_variable=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-variable=*)\n\t\t\t\t_arg_subcommand_variable=\"${_key##--subcommand-variable=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--command)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_command=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--command=*)\n\t\t\t\t_arg_command=\"${_key##--command=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--form-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_form_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--form-class=*)\n\t\t\t\t_arg_form_class=\"${_key##--form-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--input-container-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_input_container_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--input-container-class=*)\n\t\t\t\t_arg_input_container_class=\"${_key##--input-container-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--input-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_input_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--input-class=*)\n\t\t\t\t_arg_input_class=\"${_key##--input-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--label-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_label_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--label-class=*)\n\t\t\t\t_arg_label_class=\"${_key##--label-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--select-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_select_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--select-class=*)\n\t\t\t\t_arg_select_class=\"${_key##--select-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--radio-container-class|--checkbox-container-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_checkbox_container_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--checkbox-container-class=*)\n\t\t\t\t_arg_checkbox_container_class=\"${_key##--checkbox-container-class=}\"\n\t\t\t\t;;\n\t\t\t--radio-container-class=*)\n\t\t\t\t_arg_checkbox_container_class=\"${_key##--radio-container-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--radio-class|--checkbox-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_checkbox_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--checkbox-class=*)\n\t\t\t\t_arg_checkbox_class=\"${_key##--checkbox-class=}\"\n\t\t\t\t;;\n\t\t\t--radio-class=*)\n\t\t\t\t_arg_checkbox_class=\"${_key##--radio-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--radio-label-class|--checkbox-label-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_checkbox_label_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--checkbox-label-class=*)\n\t\t\t\t_arg_checkbox_label_class=\"${_key##--checkbox-label-class=}\"\n\t\t\t\t;;\n\t\t\t--radio-label-class=*)\n\t\t\t\t_arg_checkbox_label_class=\"${_key##--radio-label-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--parent-form)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_parent_form=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--parent-form=*)\n\t\t\t\t_arg_parent_form=\"${_key##--parent-form=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--optional)\n\t\t\t\t_arg_optional=\"on\"\n\t\t\t\t;;\n\t\t\t--no-optional)\n\t\t\t\t_arg_optional=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand)\n\t\t\t\t_arg_subcommand=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand)\n\t\t\t\t_arg_subcommand=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tsubcommand-directory: ${_arg_subcommand_directory}\";\n\techo -e \"\\tsubcommand-variable: ${_arg_subcommand_variable}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\\tcommand: ${_arg_command}\";\n\techo -e \"\\tform-class: ${_arg_form_class}\";\n\techo -e \"\\tinput-container-class: ${_arg_input_container_class}\";\n\techo -e \"\\tinput-class: ${_arg_input_class}\";\n\techo -e \"\\tlabel-class: ${_arg_label_class}\";\n\techo -e \"\\tselect-class: ${_arg_select_class}\";\n\techo -e \"\\tcheckbox-container-class: ${_arg_checkbox_container_class}\";\n\techo -e \"\\tcheckbox-class: ${_arg_checkbox_class}\";\n\techo -e \"\\tcheckbox-label-class: ${_arg_checkbox_label_class}\";\n\techo -e \"\\tparent-form: ${_arg_parent_form}\";\n\techo -e \"\\trepeat: ${_arg_repeat}\";\n\techo -e \"\\toptional: ${_arg_optional}\";\n\techo -e \"\\tsubcommand: ${_arg_subcommand}\";\n\techo -e \"\\tsubcommand-run: ${_arg_subcommand_run}\";\n\techo -e \"\\tsubcommand-use-leftovers: ${_arg_subcommand_use_leftovers}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n_arg_command=\"${_arg_command// /_}\";\n\nif [ \"$_arg_subcommand_directory\" != \"\" ] || [ \"$_arg_subcommand_run\" != \"off\" ] || [ \"$_arg_subcommand_use_leftovers\" != \"off\" ] || [ \"$_arg_subcommand_variable\" != \"__subcommand\" ] || [ \"$_arg_subcommand\" != \"off\" ]; then\n\tif  [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n\t\t_subcmd=( \n\t\t\t\"--input-container-class\" \"${_arg_input_container_class}\"\n\t\t\t\"--input-class\" \"${_arg_input_class}\"\n\t\t\t\"--label-class\" \"${_arg_label_class}\"\n\t\t\t\"--select-class\" \"${_arg_select_class}\"\n\t\t\t\"--checkbox-container-class\" \"${_arg_checkbox_container_class}\"\n\t\t\t\"--checkbox-class\" \"${_arg_checkbox_class}\"\n\t\t\t\"--checkbox-label-class\" \"${_arg_checkbox_label_class}\"\n\t\t);\n\t\tif [ \"$_arg_form_class\" != \"\" ]; then\n\t\t\t_subcmd+=(\"--form-class\" \"${_arg_form_class}\")\n\t\tfi\n\t\toutStr+=\"<div id=\\\"${_arg_command}_subcommands\\\">\n\t<h3>Subcommand forms</h3>\n\";\n\t\tfor oof in \"${_arg_one_of[@]}\"; do\n\t\t\texf=\"$oof\";\n\t\t\tif [ \"$_arg_subcommand_directory\" != \"\" ]; then\n\t\t\t\texf=\"${_arg_subcommand_directory}/${exf}\";\n\t\t\tfi\n\t\t\t_subcmd_e=(\"$_SCRIPT_DIR/../html-form\" \"$exf\" \"--command\" \"${oof}\" \"${_subcmd[@]}\");\n\t\t\tif [ \"$_arg_parent_form\" != \"\" ]; then\n\t\t\t\t_subcmd_e+=(\"--parent-form\" \"${_arg_parent_form}\");\n\t\t\tfi\n\t\t\t_subres=\"$(\"${_subcmd_e[@]}\")\";\n\t\t\t# outStr+=\"<pre>${_subcmd_e[*]}</pre>\";\n\t\t\toutStr+=\"<div class=\\\"d-none subcmd-container-${_arg_arg_name}\\\" id=\\\"${_arg_arg_name}_${oof}_container\\\">${_subres}</div>\";\n\t\tdone\n\t\toutStr+=\"\n\t<script>\n\tdocument.getElementById(\\\"${_arg_arg_name}\\\").addEventListener(\\\"change\\\", function() {\n\t\tvar val = this.value;\n\t\tdocument.querySelectorAll(\\\".subcmd-container-${_arg_arg_name}\\\").forEach(function(el) {\n\t\t\tel.classList.add(\\\"d-none\\\");\n\t\t});\n\t\tvar subcmd = document.getElementById(\\\"${_arg_arg_name}_\\\"+val+\\\"_container\\\").classList.remove(\\\"d-none\\\");\n\t});\n\t</script>\n</div>\";\n\tfi\nfi\n\noutStr+=\"\\n</div>\";\n\necho -e \"$outStr\";\n",
  "/parseArger/bin/pos/get-subcmd-directory": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"is the arg a sub command\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces --repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces --repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt subcommand-directory \"directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n# @parseArger opt subcommand-variable \"array variable containing subcommand parts, force subcommand\" --default-value \"__subcommand\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger flag subcommand-run \"run subcommand, forces sub command\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag optional \"optional\"\n# @parseArger flag subcommand \"is a subcommand\"\n# @parseArger flag subcommand-use-leftovers \"add leftover arguments to subcommand, forces subcommand\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/pos\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_subcommand_directory=\n_arg_subcommand_variable=\"__subcommand\"\n_arg_complete=()\n_arg_complete_custom=()\n# FLAGS\n_arg_subcommand_run=\"off\"\n_arg_repeat=\"off\"\n_arg_optional=\"off\"\n_arg_subcommand=\"off\"\n_arg_subcommand_use_leftovers=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"is the arg a sub command:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces --repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces --repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t--subcommand-directory <subcommand-directory>: directory containing subcommands, force subcommand, list parseArger script in directory to fill --one-of\"\n\techo -e \"\t--subcommand-variable <subcommand-variable>: array variable containing subcommand parts, force subcommand [default: ' __subcommand ']\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--subcommand-run|--no-subcommand-run: run subcommand, forces sub command\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--optional|--no-optional: optional\"\n\techo -e \"\t--subcommand|--no-subcommand: is a subcommand\"\n\techo -e \"\t--subcommand-use-leftovers|--no-subcommand-use-leftovers: add leftover arguments to subcommand, forces subcommand\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--subcommand-directory <value>] [--subcommand-variable <value>] [--complete <value>] [--complete-custom <value>] [--[no-]subcommand-run] [--[no-]repeat] [--[no-]optional] [--[no-]subcommand] [--[no-]subcommand-use-leftovers]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_directory=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-directory=*)\n\t\t\t\t_arg_subcommand_directory=\"${_key##--subcommand-directory=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-variable)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_variable=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-variable=*)\n\t\t\t\t_arg_subcommand_variable=\"${_key##--subcommand-variable=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-run)\n\t\t\t\t_arg_subcommand_run=\"off\"\n\t\t\t\t;;\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--optional)\n\t\t\t\t_arg_optional=\"on\"\n\t\t\t\t;;\n\t\t\t--no-optional)\n\t\t\t\t_arg_optional=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand)\n\t\t\t\t_arg_subcommand=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand)\n\t\t\t\t_arg_subcommand=\"off\"\n\t\t\t\t;;\n\t\t\t--subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"on\"\n\t\t\t\t;;\n\t\t\t--no-subcommand-use-leftovers)\n\t\t\t\t_arg_subcommand_use_leftovers=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tsubcommand-directory: ${_arg_subcommand_directory}\";\n\techo -e \"\\tsubcommand-variable: ${_arg_subcommand_variable}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\\tsubcommand-run: ${_arg_subcommand_run}\";\n\techo -e \"\\trepeat: ${_arg_repeat}\";\n\techo -e \"\\toptional: ${_arg_optional}\";\n\techo -e \"\\tsubcommand: ${_arg_subcommand}\";\n\techo -e \"\\tsubcommand-use-leftovers: ${_arg_subcommand_use_leftovers}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nif [ \"$_arg_subcommand_directory\" != \"\" ]; then\n\tif [ -d \"$_arg_subcommand_directory\" ]; then\n\t\techo \"$_arg_subcommand_directory\";\n\t\texit 0;\n\tfi\nfi\n\necho 1;\nexit 1;\n",
  "/parseArger/bin/completely": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"generate a completely yaml config and completion\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos command-name \"command-name\"\n# @parseArger pos file \"file\" --optional --complete \"file\"\n# @parseArger opt pos \"positional argument declaration\" --short p --repeat\n# @parseArger opt opt \"optional arg declaration\" --short o --repeat\n# @parseArger opt flag \"flag declaration\" --short f --repeat\n# @parseArger opt set \"declare var\" --short s --repeat\n# @parseArger opt source \"file to source\" --short l --repeat --complete \"file\"\n# @parseArger opt help-message \"help message for the command\" --short m --default-value \"I send an SOS to the world\"\n# @parseArger opt help-option \"help option trigger\"\n# @parseArger opt help-short-option \"short help option\"\n# @parseArger opt leftovers-name \"extra arguments variable name\" --default-value \"leftovers\"\n# @parseArger opt version-opt-name \"version option name\" --default-value \"version\"\n# @parseArger opt version-short-option \"version short option name\" --default-value \"v\"\n# @parseArger opt verbose-opt-name \"verbose option name\" --default-value \"verbose\"\n# @parseArger opt subcommand-directory \"directory for subcommand target\" --alias subcmd-dir --complete \"directory\"\n# @parseArger opt completely-cmd \"completely command\" --repeat --alias cmpcmd\n# @parseArger opt extra-file \"extra yaml declaration\" --repeat --complete \"file\"\n# @parseArger opt yaml-file \"yaml file name\" --default-value \"completely.yaml\" --complete \"file\"\n# @parseArger opt completion-file \"completion file name\" --default-value \"completely.bash\" --complete \"file\"\n# @parseArger flag version-opt \"generate version opt handling\" --on\n# @parseArger flag use-verbose \"generate verbose level parser\" --on\n# @parseArger flag run-completely \"run completely\" --on --no-alias no-run\n# @parseArger flag discover-subcommand \"auto run completely on found subcommand\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_command_name=\"\";\n_arg_file=\"\";\n_optional_positionals+=(\"_arg_file\");\n# OPTIONALS ARGUMENTS\n_arg_pos=()\n_arg_opt=()\n_arg_flag=()\n_arg_set=()\n_arg_source=()\n_arg_help_message=\"I send an SOS to the world\"\n_arg_help_option=\n_arg_help_short_option=\n_arg_leftovers_name=\"leftovers\"\n_arg_version_opt_name=\"version\"\n_arg_version_short_option=\"v\"\n_arg_verbose_opt_name=\"verbose\"\n_arg_subcommand_directory=\n_arg_completely_cmd=()\n_arg_extra_file=()\n_arg_yaml_file=\"completely.yaml\"\n_arg_completion_file=\"completely.bash\"\n# FLAGS\n_arg_version_opt=\"on\"\n_arg_use_verbose=\"on\"\n_arg_run_completely=\"on\"\n_arg_discover_subcommand=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"generate a completely yaml config and completion:\"\n\techo -e \"\tcommand-name: command-name\"\n\techo -e \"\tfile: file, optional\"\n\techo -e \"\t-p, --pos <pos>: positional argument declaration, repeatable\"\n\techo -e \"\t-o, --opt <opt>: optional arg declaration, repeatable\"\n\techo -e \"\t-f, --flag <flag>: flag declaration, repeatable\"\n\techo -e \"\t-s, --set <set>: declare var, repeatable\"\n\techo -e \"\t-l, --source <source>: file to source, repeatable\"\n\techo -e \"\t-m, --help-message <help-message>: help message for the command [default: ' I send an SOS to the world ']\"\n\techo -e \"\t--help-option <help-option>: help option trigger\"\n\techo -e \"\t--help-short-option <help-short-option>: short help option\"\n\techo -e \"\t--leftovers-name <leftovers-name>: extra arguments variable name [default: ' leftovers ']\"\n\techo -e \"\t--version-opt-name <version-opt-name>: version option name [default: ' version ']\"\n\techo -e \"\t--version-short-option <version-short-option>: version short option name [default: ' v ']\"\n\techo -e \"\t--verbose-opt-name <verbose-opt-name>: verbose option name [default: ' verbose ']\"\n\techo -e \"\t--subcommand-directory|--subcmd-dir <subcommand-directory>: directory for subcommand target\"\n\techo -e \"\t--completely-cmd|--cmpcmd <completely-cmd>: completely command, repeatable\"\n\techo -e \"\t--extra-file <extra-file>: extra yaml declaration, repeatable\"\n\techo -e \"\t--yaml-file <yaml-file>: yaml file name [default: ' completely.yaml ']\"\n\techo -e \"\t--completion-file <completion-file>: completion file name [default: ' completely.bash ']\"\n\techo -e \"\t--version-opt|--no-version-opt: generate version opt handling, on by default (use --no-version-opt to turn it off)\"\n\techo -e \"\t--use-verbose|--no-use-verbose: generate verbose level parser, on by default (use --no-use-verbose to turn it off)\"\n\techo -e \"\t--run-completely|--no-run-completely: run completely, on by default (use --no-run-completely to turn it off)\n\t\tno-aliases: --no-run,\"\n\techo -e \"\t--discover-subcommand|--no-discover-subcommand: auto run completely on found subcommand\"\n\techo -e \"Usage :\n\t$0 <command-name> [file] [--pos <value>] [--opt <value>] [--flag <value>] [--set <value>] [--source <value>] [--help-message <value>] [--help-option <value>] [--help-short-option <value>] [--leftovers-name <value>] [--version-opt-name <value>] [--version-short-option <value>] [--verbose-opt-name <value>] [--subcommand-directory <value>] [--completely-cmd <value>] [--extra-file <value>] [--yaml-file <value>] [--completion-file <value>] [--[no-]version-opt] [--[no-]use-verbose] [--[no-]run-completely] [--[no-]discover-subcommand]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t-p|--pos)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_pos+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--pos=*)\n\t\t\t\t_arg_pos+=(\"${_key##--pos=}\")\n\t\t\t\t;;\n\t\t\t-p*)\n\t\t\t\t_arg_pos+=(\"${_key##-p}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-o|--opt)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_opt+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--opt=*)\n\t\t\t\t_arg_opt+=(\"${_key##--opt=}\")\n\t\t\t\t;;\n\t\t\t-o*)\n\t\t\t\t_arg_opt+=(\"${_key##-o}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-f|--flag)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_flag+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--flag=*)\n\t\t\t\t_arg_flag+=(\"${_key##--flag=}\")\n\t\t\t\t;;\n\t\t\t-f*)\n\t\t\t\t_arg_flag+=(\"${_key##-f}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-s|--set)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_set+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--set=*)\n\t\t\t\t_arg_set+=(\"${_key##--set=}\")\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_set+=(\"${_key##-s}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-l|--source)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_source+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--source=*)\n\t\t\t\t_arg_source+=(\"${_key##--source=}\")\n\t\t\t\t;;\n\t\t\t-l*)\n\t\t\t\t_arg_source+=(\"${_key##-l}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-m|--help-message)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_help_message=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--help-message=*)\n\t\t\t\t_arg_help_message=\"${_key##--help-message=}\"\n\t\t\t\t;;\n\t\t\t-m*)\n\t\t\t\t_arg_help_message=\"${_key##-m}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--help-option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_help_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--help-option=*)\n\t\t\t\t_arg_help_option=\"${_key##--help-option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--help-short-option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_help_short_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--help-short-option=*)\n\t\t\t\t_arg_help_short_option=\"${_key##--help-short-option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--leftovers-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_leftovers_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--leftovers-name=*)\n\t\t\t\t_arg_leftovers_name=\"${_key##--leftovers-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--version-opt-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_version_opt_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--version-opt-name=*)\n\t\t\t\t_arg_version_opt_name=\"${_key##--version-opt-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--version-short-option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_version_short_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--version-short-option=*)\n\t\t\t\t_arg_version_short_option=\"${_key##--version-short-option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--verbose-opt-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_verbose_opt_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--verbose-opt-name=*)\n\t\t\t\t_arg_verbose_opt_name=\"${_key##--verbose-opt-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcmd-dir|--subcommand-directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_subcommand_directory=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--subcommand-directory=*)\n\t\t\t\t_arg_subcommand_directory=\"${_key##--subcommand-directory=}\"\n\t\t\t\t;;\n\t\t\t--subcmd-dir=*)\n\t\t\t\t_arg_subcommand_directory=\"${_key##--subcmd-dir=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--cmpcmd|--completely-cmd)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_completely_cmd+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--completely-cmd=*)\n\t\t\t\t_arg_completely_cmd+=(\"${_key##--completely-cmd=}\")\n\t\t\t\t;;\n\t\t\t--cmpcmd=*)\n\t\t\t\t_arg_completely_cmd+=(\"${_key##--cmpcmd=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--extra-file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_extra_file+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--extra-file=*)\n\t\t\t\t_arg_extra_file+=(\"${_key##--extra-file=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--yaml-file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_yaml_file=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--yaml-file=*)\n\t\t\t\t_arg_yaml_file=\"${_key##--yaml-file=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--completion-file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_completion_file=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--completion-file=*)\n\t\t\t\t_arg_completion_file=\"${_key##--completion-file=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--version-opt)\n\t\t\t\t_arg_version_opt=\"on\"\n\t\t\t\t;;\n\t\t\t--no-version-opt)\n\t\t\t\t_arg_version_opt=\"off\"\n\t\t\t\t;;\n\t\t\t--use-verbose)\n\t\t\t\t_arg_use_verbose=\"on\"\n\t\t\t\t;;\n\t\t\t--no-use-verbose)\n\t\t\t\t_arg_use_verbose=\"off\"\n\t\t\t\t;;\n\t\t\t--run-completely)\n\t\t\t\t_arg_run_completely=\"on\"\n\t\t\t\t;;\n\t\t\t--no-run-completely|--no-run)\n\t\t\t\t_arg_run_completely=\"off\"\n\t\t\t\t;;\n\t\t\t--discover-subcommand)\n\t\t\t\t_arg_discover_subcommand=\"on\"\n\t\t\t\t;;\n\t\t\t--no-discover-subcommand)\n\t\t\t\t_arg_discover_subcommand=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"command-name\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_command_name _arg_file \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\";\n\t\tlocal _regex=\"${!_match_var}\";\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\tcommand-name: ${_arg_command_name}\";\n\techo -e \"\tfile: ${_arg_file}\";\n\techo -e \"\tpos: ${_arg_pos[*]}\";\n\techo -e \"\topt: ${_arg_opt[*]}\";\n\techo -e \"\tflag: ${_arg_flag[*]}\";\n\techo -e \"\tset: ${_arg_set[*]}\";\n\techo -e \"\tsource: ${_arg_source[*]}\";\n\techo -e \"\thelp-message: ${_arg_help_message}\";\n\techo -e \"\thelp-option: ${_arg_help_option}\";\n\techo -e \"\thelp-short-option: ${_arg_help_short_option}\";\n\techo -e \"\tleftovers-name: ${_arg_leftovers_name}\";\n\techo -e \"\tversion-opt-name: ${_arg_version_opt_name}\";\n\techo -e \"\tversion-short-option: ${_arg_version_short_option}\";\n\techo -e \"\tverbose-opt-name: ${_arg_verbose_opt_name}\";\n\techo -e \"\tsubcommand-directory: ${_arg_subcommand_directory}\";\n\techo -e \"\tcompletely-cmd: ${_arg_completely_cmd[*]}\";\n\techo -e \"\textra-file: ${_arg_extra_file[*]}\";\n\techo -e \"\tyaml-file: ${_arg_yaml_file}\";\n\techo -e \"\tcompletion-file: ${_arg_completion_file}\";\n\techo -e \"\tversion-opt: ${_arg_version_opt}\";\n\techo -e \"\tuse-verbose: ${_arg_use_verbose}\";\n\techo -e \"\trun-completely: ${_arg_run_completely}\";\n\techo -e \"\tdiscover-subcommand: ${_arg_discover_subcommand}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\noutStr=\"\";\n\nSCRIPT_ROOT_DIR=\"/parseArger/bin\";\n# shellcheck source=$SCRIPT_ROOT_DIR/utils\nsource \"$SCRIPT_ROOT_DIR/utils\";\n\nsubCmd=\"\";\n\n# argument declarations\noutStr+=\"${_arg_command_name}:\\n\";\nif [ \"$_arg_file\" != \"\" ] && [ -f \"$_arg_file\" ]; then\n\ttmp_arg_pos=();\n\ttmp_arg_opt=();\n\ttmp_arg_flag=();\n\tparsearger_get_pos tmp_arg_pos \"$_arg_file\";\n\tparsearger_get_opt tmp_arg_opt \"$_arg_file\";\n\tparsearger_get_flag tmp_arg_flag \"$_arg_file\";\n\t_arg_pos+=(\"${tmp_arg_pos[@]}\");\n\t_arg_opt+=(\"${tmp_arg_opt[@]}\");\n\t_arg_flag+=(\"${tmp_arg_flag[@]}\");\nfi\n\nfor pos in \"${_arg_pos[@]}\"; do\n\tif [ \"$pos\" != \"\" ]; then\n\t\tif [ \"$subCmd\" == \"\" ]; then\n\t\t\tisscmd=\"$(eval \"source $SCRIPT_ROOT_DIR/pos/is-subcmd $pos\")\";\n\t\t\tif [[ \"$isscmd\" == \"0\" ]]; then\n\t\t\t\tsubCmd=\"$pos\"\n\t\t\tfi\n\t\tfi\n\t\t_cmpl=\"$(eval \"source $SCRIPT_ROOT_DIR/pos/completely $pos\")\";\n\t\tif [ \"$_cmpl\" != \"\" ]; then\n\t\t\toutStr+=\"$_cmpl\\n\";\n\t\tfi\n\tfi\ndone\nmcopt=\"\";\nfor opt in \"${_arg_opt[@]}\"; do\n\tif [ \"$opt\" != \"\" ]; then\n\t\toutStr+=\"$(eval \"source $SCRIPT_ROOT_DIR/opt/completely $opt\")\\n\";\n\t\tmcopt+=\"$(eval \"source $SCRIPT_ROOT_DIR/opt/more-completely $opt --prefix '${_arg_command_name}'\")\\n\";\n\tfi\ndone\nfor flag in \"${_arg_flag[@]}\"; do\n\tif [ \"$flag\" != \"\" ]; then\n\t\toutStr+=\"$(eval \"source $SCRIPT_ROOT_DIR/flag/completely $flag\")\\n\";\n\tfi\ndone\n\nif [ \"$_arg_discover_subcommand\" == \"on\" ] && [ \"$subCmd\" != \"\" ] && [ \"$_arg_subcommand_directory\" == \"\" ] ; then\n\t_arg_subcommand_directory=\"$(eval \"source $SCRIPT_ROOT_DIR/pos/get-subcmd-directory $subCmd\")\";\nfi\n\nif [ \"$subCmd\" != \"\" ] && [ \"$_arg_subcommand_directory\" != \"\" ] && [ -d \"$_arg_subcommand_directory\" ]; then\n\t_oneofs_scmd=();\n\tparsearger_get_one_ofs _oneofs_scmd \"$subCmd\";\n\tfor _scmd in \"${_oneofs_scmd[@]}\"; do\n\t\tif [ -f \"${_arg_subcommand_directory}/${_scmd}\" ]; then\n\t\t\toutStr+=\"$(\"$0\" \"${_arg_command_name} ${_scmd}\" \"${_arg_subcommand_directory}/${_scmd}\" \"--no-run-completely\" \"--discover-subcommand\")\\n\";\n\t\tfi\n\tdone\nfi\n\nif [ \"$mcopt\" != \"\" ]; then\n\toutStr+=\"$mcopt\\n\";\nfi\n\nif [ \"${#_arg_extra_file[@]}\" -gt 0 ]; then\n\tfor _extra_file in \"${_arg_extra_file[@]}\"; do\n\t\toutStr+=\"$(cat \"$_extra_file\")\\n\";\n\tdone\nfi\n\nif [ \"$_arg_yaml_file\" != \"\" ];then\n\techo -e \"$outStr\" > \"$_arg_yaml_file\";\nfi\n\nif [ \"$_arg_yaml_file\" != \"\" ] && [ \"$_arg_run_completely\" == \"on\" ]; then\n\tif [ \"$_arg_completion_file\" != \"\" ] && [ \"$_arg_run_completely\" == \"on\" ] && [ -f \"$_arg_yaml_file\" ]; then\n\t\tif [ \"${#_arg_completely_cmd[@]}\" -le 0 ]; then\n\t\t\t_arg_completely_cmd=(\"completely\");\n\t\tfi\n\t\t\"${_arg_completely_cmd[@]}\" generate \"$_arg_yaml_file\" \"$_arg_completion_file\";\n\tfi\nelse\n\techo -e \"$outStr\";\nfi\n",
  "/parseArger/bin/document": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"create documentation for parseArger script\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger opt file \"file to document\" --short f --repeat --complete \"file\"\n# @parseArger opt directory \"directory to document\" --short d --repeat --alias folder --complete \"directory\"\n# @parseArger opt out \"output file\" --short o --complete \"file\"\n# @parseArger opt tag \"markdown tag for title\" --default-value \"##\"\n# @parseArger opt next-tag-prepend \"prepend to next title tag level\" --default-value \"#\"\n# @parseArger opt title \"documentation title\" --default-value \"Usage\"\n# @parseArger opt title-tag \"documentation title tag\" --default-value \"#\"\n# @parseArger flag sub-directory \"document subdirectory\" --on\n# @parseArger flag append-output \"add to output file if it exists\" --on\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n# OPTIONALS ARGUMENTS\n_arg_file=()\n_arg_directory=()\n_arg_out=\n_arg_tag=\"##\"\n_arg_next_tag_prepend=\"#\"\n_arg_title=\"Usage\"\n_arg_title_tag=\"#\"\n# FLAGS\n_arg_sub_directory=\"on\"\n_arg_append_output=\"on\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"create documentation for parseArger script:\"\n\techo -e \"\t-f, --file <file>: file to document, repeatable\"\n\techo -e \"\t-d, --directory|--folder <directory>: directory to document, repeatable\"\n\techo -e \"\t-o, --out <out>: output file\"\n\techo -e \"\t--tag <tag>: markdown tag for title [default: ' ## ']\"\n\techo -e \"\t--next-tag-prepend <next-tag-prepend>: prepend to next title tag level [default: ' # ']\"\n\techo -e \"\t--title <title>: documentation title [default: ' Usage ']\"\n\techo -e \"\t--title-tag <title-tag>: documentation title tag [default: ' # ']\"\n\techo -e \"\t--sub-directory|--no-sub-directory: document subdirectory, on by default (use --no-sub-directory to turn it off)\"\n\techo -e \"\t--append-output|--no-append-output: add to output file if it exists, on by default (use --no-append-output to turn it off)\"\n\techo -e \"Usage :\n\t$0 [--file <value>] [--directory <value>] [--out <value>] [--tag <value>] [--next-tag-prepend <value>] [--title <value>] [--title-tag <value>] [--[no-]sub-directory] [--[no-]append-output]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t-f|--file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_file+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--file=*)\n\t\t\t\t_arg_file+=(\"${_key##--file=}\")\n\t\t\t\t;;\n\t\t\t-f*)\n\t\t\t\t_arg_file+=(\"${_key##-f}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-d|--folder|--directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_directory+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--directory=*)\n\t\t\t\t_arg_directory+=(\"${_key##--directory=}\")\n\t\t\t\t;;\n\t\t\t--folder=*)\n\t\t\t\t_arg_directory+=(\"${_key##--folder=}\")\n\t\t\t\t;;\n\t\t\t-d*)\n\t\t\t\t_arg_directory+=(\"${_key##-d}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-o|--out)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_out=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--out=*)\n\t\t\t\t_arg_out=\"${_key##--out=}\"\n\t\t\t\t;;\n\t\t\t-o*)\n\t\t\t\t_arg_out=\"${_key##-o}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--tag)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_tag=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--tag=*)\n\t\t\t\t_arg_tag=\"${_key##--tag=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--next-tag-prepend)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_next_tag_prepend=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--next-tag-prepend=*)\n\t\t\t\t_arg_next_tag_prepend=\"${_key##--next-tag-prepend=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--title)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_title=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--title=*)\n\t\t\t\t_arg_title=\"${_key##--title=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--title-tag)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_title_tag=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--title-tag=*)\n\t\t\t\t_arg_title_tag=\"${_key##--title-tag=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--sub-directory)\n\t\t\t\t_arg_sub_directory=\"on\"\n\t\t\t\t;;\n\t\t\t--no-sub-directory)\n\t\t\t\t_arg_sub_directory=\"off\"\n\t\t\t\t;;\n\t\t\t--append-output)\n\t\t\t\t_arg_append_output=\"on\"\n\t\t\t\t;;\n\t\t\t--no-append-output)\n\t\t\t\t_arg_append_output=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t--quiet)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"\"\n\tif [ \"${_positionals_count}\" -gt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 0 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 0 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"\";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\";\n\t\tlocal _regex=\"${!_match_var}\";\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\tfile: ${_arg_file[*]}\";\n\techo -e \"\tdirectory: ${_arg_directory[*]}\";\n\techo -e \"\tout: ${_arg_out}\";\n\techo -e \"\ttag: ${_arg_tag}\";\n\techo -e \"\tnext-tag-prepend: ${_arg_next_tag_prepend}\";\n\techo -e \"\ttitle: ${_arg_title}\";\n\techo -e \"\ttitle-tag: ${_arg_title_tag}\";\n\techo -e \"\tsub-directory: ${_arg_sub_directory}\";\n\techo -e \"\tappend-output: ${_arg_append_output}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nSCRIPT_ROOT_DIR=\"/parseArger/bin\";\n\nsource \"$SCRIPT_ROOT_DIR/utils\";\n\noutStr=\"${_arg_title_tag} ${_arg_title}\\n\\n\";\n\nif [ \"${#_arg_file[@]}\" -gt 0 ]; then\n\tfor _file in \"${_arg_file[@]}\"; do\n\t\tif parsearger_is_pa_file \"$_file\" ; then\n\t\t\tlog \"parsing $_file\\n\" 1;\n\t\t\t# parse help declaration to call correct option\n\t\t\t_help_cmd=$(parsearger_get_help \"$_file\");\n\t\t\t_help_opt=$(eval \"source $SCRIPT_ROOT_DIR/help/get-trigger \\\"$_help_cmd\\\"\");\n\t\t\toutStr+=\"${_arg_tag} ${_file}\\n\\n\\`\\`\\`\\n$(bash \"$_file\" \"--$_help_opt\")\\n\\`\\`\\`\\n\\n\";\n\t\t\tfor scmd_tgt in \"${_oneofs_scmd[@]}\"; do\n\t\t\t\t# clean out from $(pwd)\n\t\t\t\tftmpStr=$(bash \"$_file\" \"$scmd_tgt\" \"--$_help_opt\" | sed -e \"s|$(pwd)||g\");\n\t\t\t\toutStr+=\"${_arg_tag} ${_file} ${scmd_tgt}\\n\\n\\`\\`\\`\\n$ftmpStr\\n\\`\\`\\`\\n\\n\";\n\t\t\tdone\n\t\tfi\n\tdone\nfi\n\nif [ \"${#_arg_directory[@]}\" -gt 0 ]; then\n\tfor _directory in \"${_arg_directory[@]}\"; do\n\t\tif [ -d \"$_directory\" ]; then\n\t\t\tlog \"----- processing $_directory directory\\n\" 1;\n\t\t\tdocCmd=(--tag \"${_arg_next_tag_prepend}${_arg_tag}\" \"--next-tag-prepend\" \"${_arg_next_tag_prepend}\" --title \"${_directory}\" \"--title-tag\" \"${_arg_tag}\" --verbose \"${_verbose_level}\");\n\t\t\tif [ \"$_arg_sub_directory\" == \"off\" ]; then\n\t\t\t\tdocCmd+=(--no-sub-directory);\n\t\t\tfi\n\t\t\tfor _file in \"$_directory\"/*; do\n\t\t\t\tif [ -f \"${_file}\" ]; then\n\t\t\t\t\tdocCmd+=(--file \"$_file\");\n\t\t\t\tfi\n\t\t\t\tif [ -d \"${_file}\" ] && [ \"$_arg_sub_directory\" == \"on\" ] ; then\n\t\t\t\t\tdocCmd+=(--directory \"$_file\");\n\t\t\t\tfi\n\t\t\tdone\n\t\t\tdtmpStr=\"$(\"$0\" \"${docCmd[@]}\")\";\n\t\t\toutStr+=\"$(echo -e \"$dtmpStr\" | sed -e \"s|$_directory||g\")\\n\\n\";\n\t\tfi\n\tdone\nfi\n\n# clean output from ./\noutStr=$(echo -e \"$outStr\" | sed -e \"s|\\./||g\");\n\nif [ \"$_arg_out\" == \"\" ]; then\n\techo -e \"$outStr\";\nelse\n\tif [ \"$_arg_append_output\" == \"on\" ]; then\n\t\tlog \"appending to $_arg_out\" 1;\n\t\techo -e \"$outStr\" >> \"$_arg_out\";\n\telse\n\t\tlog \"outputing to $_arg_out\" 1;\n\t\techo -e \"$outStr\" > \"$_arg_out\";\n\tfi\nfi\n",
  "/parseArger/bin/verbose/init": "#!/bin/bash\n\n# @parseArger-begin\n# @parseArger-help \"init verbose stuff\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger opt option \"verbose trigger option\" --default-value \"verbose\"\n# @parseArger opt level \"verbose default level\" --default-value \"0\"\n# @parseArger opt log-fn-name \"log function name\" --default-value \"log\"\n# @parseArger opt quiet-option \"trigger to tell script to shut up\" --default-value \"quiet\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/verbose\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n# OPTIONALS ARGUMENTS\n_arg_option=\"verbose\"\n_arg_level=\"0\"\n_arg_log_fn_name=\"log\"\n_arg_quiet_option=\"quiet\"\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"init verbose stuff:\"\n\techo -e \"\t--option <option>: verbose trigger option [default: ' verbose ']\"\n\techo -e \"\t--level <level>: verbose default level [default: ' 0 ']\"\n\techo -e \"\t--log-fn-name <log-fn-name>: log function name [default: ' log ']\"\n\techo -e \"\t--quiet-option <quiet-option>: trigger to tell script to shut up [default: ' quiet ']\"\n\techo -e \"Usage :\n\t$0 [--option <value>] [--level <value>] [--log-fn-name <value>] [--quiet-option <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--option=*)\n\t\t\t\t_arg_option=\"${_key##--option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--level)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_level=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--level=*)\n\t\t\t\t_arg_level=\"${_key##--level=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--log-fn-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_log_fn_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--log-fn-name=*)\n\t\t\t\t_arg_log_fn_name=\"${_key##--log-fn-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--quiet-option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_quiet_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--quiet-option=*)\n\t\t\t\t_arg_quiet_option=\"${_key##--quiet-option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"\"\n\tif [ \"${_positionals_count}\" -gt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 0 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 0 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"\";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\toption: ${_arg_option}\";\n\techo -e \"\\tlevel: ${_arg_level}\";\n\techo -e \"\\tlog-fn-name: ${_arg_log_fn_name}\";\n\techo -e \"\\tquiet-option: ${_arg_quiet_option}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\noutStr=\"_verbose_level=\\\"${_arg_level}\\\";\\n\";\n\necho -e \"$outStr\";\n",
  "/parseArger/bin/verbose/parser": "#!/bin/bash\n\n# @parseArger-begin\n# @parseArger-help \"create version parser\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger opt option \"verbose trigger option\" --default-value \"verbose\"\n# @parseArger opt level \"verbose default level\" --default-value \"0\"\n# @parseArger opt log-fn-name \"log function name\" --default-value \"log\"\n# @parseArger opt quiet-option \"trigger to tell script to shut up\" --default-value \"quiet\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/verbose\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n# OPTIONALS ARGUMENTS\n_arg_option=\"verbose\"\n_arg_level=\"0\"\n_arg_log_fn_name=\"log\"\n_arg_quiet_option=\"quiet\"\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"create version parser:\"\n\techo -e \"\t--option <option>: verbose trigger option [default: ' verbose ']\"\n\techo -e \"\t--level <level>: verbose default level [default: ' 0 ']\"\n\techo -e \"\t--log-fn-name <log-fn-name>: log function name [default: ' log ']\"\n\techo -e \"\t--quiet-option <quiet-option>: trigger to tell script to shut up [default: ' quiet ']\"\n\techo -e \"Usage :\n\t$0 [--option <value>] [--level <value>] [--log-fn-name <value>] [--quiet-option <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--option=*)\n\t\t\t\t_arg_option=\"${_key##--option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--level)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_level=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--level=*)\n\t\t\t\t_arg_level=\"${_key##--level=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--log-fn-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_log_fn_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--log-fn-name=*)\n\t\t\t\t_arg_log_fn_name=\"${_key##--log-fn-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--quiet-option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_quiet_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--quiet-option=*)\n\t\t\t\t_arg_quiet_option=\"${_key##--quiet-option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"\"\n\tif [ \"${_positionals_count}\" -gt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 0 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 0 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"\";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\toption: ${_arg_option}\";\n\techo -e \"\\tlevel: ${_arg_level}\";\n\techo -e \"\\tlog-fn-name: ${_arg_log_fn_name}\";\n\techo -e \"\\tquiet-option: ${_arg_quiet_option}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\noutStr=\"\";\n\nif [ \"$_arg_option\" != \"\" ]; then\n\t# outStr+=\"--$_arg_option\";\n\toutStr+=\"--$_arg_option)\\n\";\n\toutStr+=\"\\tif [ \\$# -lt 2 ];then\\n\";\n\toutStr+=\"\\t\\t_verbose_level=\\\"\\$((_verbose_level + 1))\\\";\\n\";\n\toutStr+=\"\\telse\\n\";\n\toutStr+=\"\\t\\t_verbose_level=\\\"\\$2\\\";\\n\";\n\toutStr+=\"\\t\\tshift;\\n\";\n\toutStr+=\"\\tfi\\n\";\n\toutStr+=\"\\t;;\\n\";\nfi\n\nif [ \"$_arg_quiet_option\" != \"\" ]; then\n\toutStr+=\"--$_arg_quiet_option)\\n\";\n\toutStr+=\"\\tif [ \\$# -lt 2 ];then\\n\";\n\toutStr+=\"\\t\\t_verbose_level=\\\"\\$((_verbose_level - 1))\\\";\\n\";\n\toutStr+=\"\\telse\\n\";\n\toutStr+=\"\\t\\t_verbose_level=\\\"-\\$2\\\";\\n\";\n\toutStr+=\"\\t\\tshift;\\n\";\n\toutStr+=\"\\tfi\\n\";\n\toutStr+=\"\\t;;\\n\";\nfi\n\necho -e \"$outStr\";\n",
  "/parseArger/bin/verbose/logger": "#!/bin/bash\n\n# @parseArger-begin\n# @parseArger-help \"init verbose stuff\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger opt option \"verbose trigger option\" --default-value \"verbose\"\n# @parseArger opt level \"verbose default level\" --default-value \"0\"\n# @parseArger opt log-fn-name \"log function name\" --default-value \"log\"\n# @parseArger opt quiet-option \"trigger to tell script to shut up\" --default-value \"quiet\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/verbose\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n# OPTIONALS ARGUMENTS\n_arg_option=\"verbose\"\n_arg_level=\"0\"\n_arg_log_fn_name=\"log\"\n_arg_quiet_option=\"quiet\"\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"init verbose stuff:\"\n\techo -e \"\t--option <option>: verbose trigger option [default: ' verbose ']\"\n\techo -e \"\t--level <level>: verbose default level [default: ' 0 ']\"\n\techo -e \"\t--log-fn-name <log-fn-name>: log function name [default: ' log ']\"\n\techo -e \"\t--quiet-option <quiet-option>: trigger to tell script to shut up [default: ' quiet ']\"\n\techo -e \"Usage :\n\t$0 [--option <value>] [--level <value>] [--log-fn-name <value>] [--quiet-option <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--option=*)\n\t\t\t\t_arg_option=\"${_key##--option=}\"\n\t\t\t\t;;\n\n\t\t\t--level)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_level=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--level=*)\n\t\t\t\t_arg_level=\"${_key##--level=}\"\n\t\t\t\t;;\n\n\t\t\t--log-fn-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_log_fn_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--log-fn-name=*)\n\t\t\t\t_arg_log_fn_name=\"${_key##--log-fn-name=}\"\n\t\t\t\t;;\n\n\t\t\t--quiet-option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_quiet_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--quiet-option=*)\n\t\t\t\t_arg_quiet_option=\"${_key##--quiet-option=}\"\n\t\t\t\t;;\n\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"\"\n\tif [ \"${_positionals_count}\" -gt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 0 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 0 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"\";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\n\techo -e \"\\toption: ${_arg_option}\";\n\techo -e \"\\tlevel: ${_arg_level}\";\n\techo -e \"\\tlog-fn-name: ${_arg_log_fn_name}\";\n\techo -e \"\\tquiet-option: ${_arg_quiet_option}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\n# TODO customizable colors\n\noutStr=\"${_arg_log_fn_name}() {\n\tlocal _arg_msg=\\\"\\${1}\\\";\n\tlocal _arg_level=\\\"\\${2:-$_arg_level}\\\";\n\tif [ \\\"\\${_arg_level}\\\" -le \\\"\\${_verbose_level}\\\" ]; then\n\t\tcase \\\"\\$_arg_level\\\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\\\"\\\\\\\\033[0;31m\\\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\\\"\\\\\\\\033[0;33m\\\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\\\"\\\\\\\\033[1;33m\\\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\\\"\\\\\\\\033[0;32m\\\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\\\"\\\\\\\\033[1;36m\\\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\\\"\\\\\\\\033[0;36m\\\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\\\"\\\\\\\\033[0m\\\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \\\"\\${_has_colors}\\\" == \\\"1\\\" ]; then\n\t\t\techo -e \\\"\\${_arg_COLOR}\\${_arg_msg}\\\\\\\\033[0m\\\";\n\t\telse\n\t\t\techo \\\"\\${_arg_msg}\\\";\n\t\tfi\n\tfi\n}\";\n\necho -e \"$outStr\";\n",
  "/parseArger/bin/verbose/declaration": "#!/bin/bash\n\n# @parseArger-begin\n# @parseArger-help \"create common verbose stuff\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger opt option \"verbose trigger option\" --default-value \"verbose\"\n# @parseArger opt level \"verbose default level\" --default-value \"0\"\n# @parseArger opt log-fn-name \"log function name\" --default-value \"log\"\n# @parseArger opt quiet-option \"trigger to tell script to shut up\" --default-value \"quiet\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/verbose\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n# OPTIONALS ARGUMENTS\n_arg_option=\"verbose\"\n_arg_level=\"0\"\n_arg_log_fn_name=\"log\"\n_arg_quiet_option=\"quiet\"\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"create common verbose stuff:\"\n\techo -e \"\t--option <option>: verbose trigger option [default: ' verbose ']\"\n\techo -e \"\t--level <level>: verbose default level [default: ' 0 ']\"\n\techo -e \"\t--log-fn-name <log-fn-name>: log function name [default: ' log ']\"\n\techo -e \"\t--quiet-option <quiet-option>: trigger to tell script to shut up [default: ' quiet ']\"\n\techo -e \"Usage :\n\t$0 [--option <value>] [--level <value>] [--log-fn-name <value>] [--quiet-option <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--option=*)\n\t\t\t\t_arg_option=\"${_key##--option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--level)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_level=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--level=*)\n\t\t\t\t_arg_level=\"${_key##--level=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--log-fn-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_log_fn_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--log-fn-name=*)\n\t\t\t\t_arg_log_fn_name=\"${_key##--log-fn-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--quiet-option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_quiet_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--quiet-option=*)\n\t\t\t\t_arg_quiet_option=\"${_key##--quiet-option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"\"\n\tif [ \"${_positionals_count}\" -gt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 0 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 0 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"\";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\toption: ${_arg_option}\";\n\techo -e \"\\tlevel: ${_arg_level}\";\n\techo -e \"\\tlog-fn-name: ${_arg_log_fn_name}\";\n\techo -e \"\\tquiet-option: ${_arg_quiet_option}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\noutStr=\"# @parse\";\noutStr+=\"Arger-verbose --option \\\"$_arg_option\\\" --level \\\"$_arg_level\\\" --quiet-option \\\"$_arg_quiet_option\\\"\";\n\necho \"$outStr\";\n",
  "/parseArger/bin/xdg/init": "#!/bin/bash\n\n# @parseArger-begin\n# @parseArger-help \"generate XDG base directory initialization\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger pos app-name \"application name for XDG directories\"\n# @parseArger flag config \"enable XDG_CONFIG_HOME support\" --on\n# @parseArger flag data \"enable XDG_DATA_HOME support\" --on\n# @parseArger flag cache \"enable XDG_CACHE_HOME support\"\n# @parseArger opt config-file \"config file name\" --default-value \"config\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/xdg\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_app_name=\n# OPTIONALS ARGUMENTS\n_arg_config_file=\"config\"\n# FLAGS\n_arg_config=\"on\"\n_arg_data=\"on\"\n_arg_cache=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"generate XDG base directory initialization:\"\n\techo -e \"\t<app-name>: application name for XDG directories\"\n\techo -e \"\t--config-file <config-file>: config file name [default: ' config ']\"\n\techo -e \"\t--config|--no-config: enable XDG_CONFIG_HOME support, on by default (use --no-config to turn it off)\"\n\techo -e \"\t--data|--no-data: enable XDG_DATA_HOME support, on by default (use --no-data to turn it off)\"\n\techo -e \"\t--cache|--no-cache: enable XDG_CACHE_HOME support\"\n\techo -e \"Usage :\n\t$0 <app-name> [--config-file <value>] [--[no-]config] [--[no-]data] [--[no-]cache]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--config-file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_config_file=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--config-file=*)\n\t\t\t\t_arg_config_file=\"${_key##--config-file=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--config)\n\t\t\t\t_arg_config=\"on\"\n\t\t\t\t;;\n\t\t\t--no-config)\n\t\t\t\t_arg_config=\"off\"\n\t\t\t\t;;\n\t\t\t--data)\n\t\t\t\t_arg_data=\"on\"\n\t\t\t\t;;\n\t\t\t--no-data)\n\t\t\t\t_arg_data=\"off\"\n\t\t\t\t;;\n\t\t\t--cache)\n\t\t\t\t_arg_cache=\"on\"\n\t\t\t\t;;\n\t\t\t--no-cache)\n\t\t\t\t_arg_cache=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"app-name\"\n\tif [ \"${_positionals_count}\" -gt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_app_name \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\tapp-name: ${_arg_app_name}\";\n\techo -e \"\\tconfig-file: ${_arg_config_file}\";\n\techo -e \"\\tconfig: ${_arg_config}\";\n\techo -e \"\\tdata: ${_arg_data}\";\n\techo -e \"\\tcache: ${_arg_cache}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\n# Generate XDG initialization code\necho \"# XDG Base Directory variables\"\necho \"_xdg_app_name=\\\"${_arg_app_name}\\\"\";\necho \"_xdg_config_file=\\\"${_arg_config_file}\\\"\";\n\nif [ \"$_arg_config\" == \"on\" ]; then\n\techo \"_xdg_config_home=\\\"\\\"\";\nfi\nif [ \"$_arg_data\" == \"on\" ]; then\n\techo \"_xdg_data_home=\\\"\\\"\";\nfi\nif [ \"$_arg_cache\" == \"on\" ]; then\n\techo \"_xdg_cache_home=\\\"\\\"\";\nfi\n",
  "/parseArger/bin/xdg/functions": "#!/bin/bash\n\n# @parseArger-begin\n# @parseArger-help \"generate XDG base directory helper functions\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger pos app-name \"application name for XDG directories\"\n# @parseArger flag config \"enable XDG_CONFIG_HOME support\" --on\n# @parseArger flag data \"enable XDG_DATA_HOME support\" --on\n# @parseArger flag cache \"enable XDG_CACHE_HOME support\"\n# @parseArger opt config-file \"config file name\" --default-value \"config\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/xdg\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_app_name=\n# OPTIONALS ARGUMENTS\n_arg_config_file=\"config\"\n# FLAGS\n_arg_config=\"on\"\n_arg_data=\"on\"\n_arg_cache=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"generate XDG base directory helper functions:\"\n\techo -e \"\t<app-name>: application name for XDG directories\"\n\techo -e \"\t--config-file <config-file>: config file name [default: ' config ']\"\n\techo -e \"\t--config|--no-config: enable XDG_CONFIG_HOME support, on by default (use --no-config to turn it off)\"\n\techo -e \"\t--data|--no-data: enable XDG_DATA_HOME support, on by default (use --no-data to turn it off)\"\n\techo -e \"\t--cache|--no-cache: enable XDG_CACHE_HOME support\"\n\techo -e \"Usage :\n\t$0 <app-name> [--config-file <value>] [--[no-]config] [--[no-]data] [--[no-]cache]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--config-file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_config_file=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--config-file=*)\n\t\t\t\t_arg_config_file=\"${_key##--config-file=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--config)\n\t\t\t\t_arg_config=\"on\"\n\t\t\t\t;;\n\t\t\t--no-config)\n\t\t\t\t_arg_config=\"off\"\n\t\t\t\t;;\n\t\t\t--data)\n\t\t\t\t_arg_data=\"on\"\n\t\t\t\t;;\n\t\t\t--no-data)\n\t\t\t\t_arg_data=\"off\"\n\t\t\t\t;;\n\t\t\t--cache)\n\t\t\t\t_arg_cache=\"on\"\n\t\t\t\t;;\n\t\t\t--no-cache)\n\t\t\t\t_arg_cache=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t--quiet)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"app-name\"\n\tif [ \"${_positionals_count}\" -gt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_app_name \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\tapp-name: ${_arg_app_name}\";\n\techo -e \"\\tconfig-file: ${_arg_config_file}\";\n\techo -e \"\\tconfig: ${_arg_config}\";\n\techo -e \"\\tdata: ${_arg_data}\";\n\techo -e \"\\tcache: ${_arg_cache}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\n# Generate the xdg_init function\ncat << 'XDGINIT'\n# Initialize XDG directories based on platform\n# Supports Linux, macOS, Windows (Git Bash, MSYS2, Cygwin)\nxdg_init() {\n\tcase \"$(uname -s)\" in\n\t\tMINGW*|MSYS*|CYGWIN*)\n\t\t\t# Windows (Git Bash, MSYS2, Cygwin)\nXDGINIT\n\nif [ \"$_arg_config\" == \"on\" ]; then\n\tcat << 'XDGCONFIGWIN'\n\t\t\t_xdg_config_home=\"${XDG_CONFIG_HOME:-${APPDATA:-$HOME/.config}}/$_xdg_app_name\"\nXDGCONFIGWIN\nfi\n\nif [ \"$_arg_data\" == \"on\" ]; then\n\tcat << 'XDGDATAWIN'\n\t\t\t_xdg_data_home=\"${XDG_DATA_HOME:-${LOCALAPPDATA:-$HOME/.local/share}}/$_xdg_app_name\"\nXDGDATAWIN\nfi\n\nif [ \"$_arg_cache\" == \"on\" ]; then\n\tcat << 'XDGCACHEWIN'\n\t\t\t_xdg_cache_home=\"${XDG_CACHE_HOME:-${LOCALAPPDATA:-$HOME/.cache}/cache}/$_xdg_app_name\"\nXDGCACHEWIN\nfi\n\ncat << 'XDGUNIX'\n\t\t\t;;\n\t\t*)\n\t\t\t# Linux, macOS, and other Unix-like systems\n\t\t\t# Uses XDG Base Directory Specification with sensible fallbacks\nXDGUNIX\n\nif [ \"$_arg_config\" == \"on\" ]; then\n\tcat << 'XDGCONFIGUNIX'\n\t\t\t_xdg_config_home=\"${XDG_CONFIG_HOME:-$HOME/.config}/$_xdg_app_name\"\nXDGCONFIGUNIX\nfi\n\nif [ \"$_arg_data\" == \"on\" ]; then\n\tcat << 'XDGDATAUNIX'\n\t\t\t_xdg_data_home=\"${XDG_DATA_HOME:-$HOME/.local/share}/$_xdg_app_name\"\nXDGDATAUNIX\nfi\n\nif [ \"$_arg_cache\" == \"on\" ]; then\n\tcat << 'XDGCACHEUNIX'\n\t\t\t_xdg_cache_home=\"${XDG_CACHE_HOME:-$HOME/.cache}/$_xdg_app_name\"\nXDGCACHEUNIX\nfi\n\ncat << 'XDGINITEND'\n\t\t\t;;\n\tesac\nXDGINITEND\n\n# Generate ensure_* calls\nif [ \"$_arg_config\" == \"on\" ]; then\n\techo \"\txdg_ensure_config_dir\";\nfi\nif [ \"$_arg_data\" == \"on\" ]; then\n\techo \"\txdg_ensure_data_dir\";\nfi\nif [ \"$_arg_cache\" == \"on\" ]; then\n\techo \"\txdg_ensure_cache_dir\";\nfi\n\necho \"}\"\necho \"\"\n\n# Generate getter functions\nif [ \"$_arg_config\" == \"on\" ]; then\n\tcat << 'XDGGETCONFIG'\n# Get the config directory path\nxdg_config_dir() {\n\techo \"$_xdg_config_home\";\n}\n\n# Ensure config directory exists\nxdg_ensure_config_dir() {\n\tif [ ! -d \"$_xdg_config_home\" ]; then\n\t\tmkdir -p \"$_xdg_config_home\";\n\tfi\n}\n\nXDGGETCONFIG\nfi\n\nif [ \"$_arg_data\" == \"on\" ]; then\n\tcat << 'XDGGETDATA'\n# Get the data directory path\nxdg_data_dir() {\n\techo \"$_xdg_data_home\";\n}\n\n# Ensure data directory exists\nxdg_ensure_data_dir() {\n\tif [ ! -d \"$_xdg_data_home\" ]; then\n\t\tmkdir -p \"$_xdg_data_home\";\n\tfi\n}\n\nXDGGETDATA\nfi\n\nif [ \"$_arg_cache\" == \"on\" ]; then\n\tcat << 'XDGGETCACHE'\n# Get the cache directory path\nxdg_cache_dir() {\n\techo \"$_xdg_cache_home\";\n}\n\n# Ensure cache directory exists\nxdg_ensure_cache_dir() {\n\tif [ ! -d \"$_xdg_cache_home\" ]; then\n\t\tmkdir -p \"$_xdg_cache_home\";\n\tfi\n}\n\nXDGGETCACHE\nfi\n\n# Generate load/save config functions if config is enabled\nif [ \"$_arg_config\" == \"on\" ]; then\n\tcat << XDGLOADSAVE\n# Get the full path to the config file\nxdg_config_file() {\n\techo \"\\$_xdg_config_home/\\$_xdg_config_file\";\n}\n\n# Load config file (sources it as bash variables)\n# Returns 0 if loaded, 1 if file doesn't exist\nxdg_load_config() {\n\tlocal _config_path=\"\\$_xdg_config_home/\\$_xdg_config_file\";\n\tif [ -f \"\\$_config_path\" ]; then\n\t\t# shellcheck source=/dev/null\n\t\tsource \"\\$_config_path\";\n\t\treturn 0;\n\tfi\n\treturn 1;\n}\n\n# Save a variable to the config file\n# Usage: xdg_save_config \"VAR_NAME\" \"value\"\n# Or: xdg_save_config \"VAR_NAME=value\"\nxdg_save_config() {\n\tlocal _config_path=\"\\$_xdg_config_home/\\$_xdg_config_file\";\n\tlocal _var_name;\n\tlocal _var_value;\n\t\n\tif [[ \"\\$1\" == *\"=\"* ]]; then\n\t\t_var_name=\"\\${1%%=*}\";\n\t\t_var_value=\"\\${1#*=}\";\n\telse\n\t\t_var_name=\"\\$1\";\n\t\t_var_value=\"\\$2\";\n\tfi\n\t\n\t# Ensure config directory exists\n\txdg_ensure_config_dir;\n\t\n\t# Create config file if it doesn't exist\n\tif [ ! -f \"\\$_config_path\" ]; then\n\t\ttouch \"\\$_config_path\";\n\tfi\n\t\n\t# Check if variable already exists in config\n\tif grep -q \"^\\${_var_name}=\" \"\\$_config_path\" 2>/dev/null; then\n\t\t# Update existing variable (portable sed)\n\t\tlocal _tmp_file=\"\\${_config_path}.tmp\";\n\t\tgrep -v \"^\\${_var_name}=\" \"\\$_config_path\" > \"\\$_tmp_file\";\n\t\techo \"\\${_var_name}=\\\"\\${_var_value}\\\"\" >> \"\\$_tmp_file\";\n\t\tmv \"\\$_tmp_file\" \"\\$_config_path\";\n\telse\n\t\t# Append new variable\n\t\techo \"\\${_var_name}=\\\"\\${_var_value}\\\"\" >> \"\\$_config_path\";\n\tfi\n}\n\n# Remove a variable from the config file\n# Usage: xdg_remove_config \"VAR_NAME\"\nxdg_remove_config() {\n\tlocal _config_path=\"\\$_xdg_config_home/\\$_xdg_config_file\";\n\tlocal _var_name=\"\\$1\";\n\t\n\tif [ -f \"\\$_config_path\" ]; then\n\t\tlocal _tmp_file=\"\\${_config_path}.tmp\";\n\t\tgrep -v \"^\\${_var_name}=\" \"\\$_config_path\" > \"\\$_tmp_file\";\n\t\tmv \"\\$_tmp_file\" \"\\$_config_path\";\n\tfi\n}\n\n# Get a value from the config file without sourcing the whole file\n# Usage: xdg_get_config \"VAR_NAME\"\nxdg_get_config() {\n\tlocal _config_path=\"\\$_xdg_config_home/\\$_xdg_config_file\";\n\tlocal _var_name=\"\\$1\";\n\t\n\tif [ -f \"\\$_config_path\" ]; then\n\t\tlocal _line;\n\t\t_line=\\$(grep \"^\\${_var_name}=\" \"\\$_config_path\" 2>/dev/null | head -1);\n\t\tif [ -n \"\\$_line\" ]; then\n\t\t\t# Extract value, handling quoted strings\n\t\t\tlocal _value=\"\\${_line#*=}\";\n\t\t\t# Remove surrounding quotes if present\n\t\t\t_value=\"\\${_value#\\\"}\";\n\t\t\t_value=\"\\${_value%\\\"}\";\n\t\t\t_value=\"\\${_value#\\'}\";\n\t\t\t_value=\"\\${_value%\\'}\";\n\t\t\techo \"\\$_value\";\n\t\t\treturn 0;\n\t\tfi\n\tfi\n\treturn 1;\n}\n\nXDGLOADSAVE\nfi\n",
  "/parseArger/bin/xdg/declaration": "#!/bin/bash\n\n# @parseArger-begin\n# @parseArger-help \"generate XDG base directory declaration\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger pos app-name \"application name for XDG directories\"\n# @parseArger flag config \"enable XDG_CONFIG_HOME support\" --on\n# @parseArger flag data \"enable XDG_DATA_HOME support\" --on\n# @parseArger flag cache \"enable XDG_CACHE_HOME support\"\n# @parseArger opt config-file \"config file name\" --default-value \"config\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/xdg\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_app_name=\n# OPTIONALS ARGUMENTS\n_arg_config_file=\"config\"\n# FLAGS\n_arg_config=\"on\"\n_arg_data=\"on\"\n_arg_cache=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"generate XDG base directory declaration:\"\n\techo -e \"\t<app-name>: application name for XDG directories\"\n\techo -e \"\t--config-file <config-file>: config file name [default: ' config ']\"\n\techo -e \"\t--config|--no-config: enable XDG_CONFIG_HOME support, on by default (use --no-config to turn it off)\"\n\techo -e \"\t--data|--no-data: enable XDG_DATA_HOME support, on by default (use --no-data to turn it off)\"\n\techo -e \"\t--cache|--no-cache: enable XDG_CACHE_HOME support\"\n\techo -e \"Usage :\n\t$0 <app-name> [--config-file <value>] [--[no-]config] [--[no-]data] [--[no-]cache]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--config-file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_config_file=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--config-file=*)\n\t\t\t\t_arg_config_file=\"${_key##--config-file=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--config)\n\t\t\t\t_arg_config=\"on\"\n\t\t\t\t;;\n\t\t\t--no-config)\n\t\t\t\t_arg_config=\"off\"\n\t\t\t\t;;\n\t\t\t--data)\n\t\t\t\t_arg_data=\"on\"\n\t\t\t\t;;\n\t\t\t--no-data)\n\t\t\t\t_arg_data=\"off\"\n\t\t\t\t;;\n\t\t\t--cache)\n\t\t\t\t_arg_cache=\"on\"\n\t\t\t\t;;\n\t\t\t--no-cache)\n\t\t\t\t_arg_cache=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"app-name\"\n\tif [ \"${_positionals_count}\" -gt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_app_name \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\tapp-name: ${_arg_app_name}\";\n\techo -e \"\\tconfig-file: ${_arg_config_file}\";\n\techo -e \"\\tconfig: ${_arg_config}\";\n\techo -e \"\\tdata: ${_arg_data}\";\n\techo -e \"\\tcache: ${_arg_cache}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\n# Build the declaration comment\noutStr=\"# @parse\";\noutStr+=\"Arger-xdg \\\"${_arg_app_name}\\\"\";\n\nif [ \"$_arg_config\" == \"on\" ]; then\n\toutStr+=\" --config\";\nelse\n\toutStr+=\" --no-config\";\nfi\n\nif [ \"$_arg_data\" == \"on\" ]; then\n\toutStr+=\" --data\";\nelse\n\toutStr+=\" --no-data\";\nfi\n\nif [ \"$_arg_cache\" == \"on\" ]; then\n\toutStr+=\" --cache\";\nelse\n\toutStr+=\" --no-cache\";\nfi\n\nif [ \"$_arg_config_file\" != \"config\" ]; then\n\toutStr+=\" --config-file \\\"${_arg_config_file}\\\"\";\nfi\n\necho \"$outStr\";\n",
  "/parseArger/bin/version/parser": "#!/bin/bash\n\n# @parseArger-begin\n# @parseArger-help \"create version parser\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos vernum \"your version number\"\n# @parseArger opt option \"version trigger option\" --default-value \"version\"\n# @parseArger opt short-option \"version trigger short option\" --default-value \"v\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/version\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_vernum=\"\";\n# OPTIONALS ARGUMENTS\n_arg_option=\"version\"\n_arg_short_option=\"v\"\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"create version parser:\"\n\techo -e \"\tvernum: your version number\"\n\techo -e \"\t--option <option>: version trigger option [default: ' version ']\"\n\techo -e \"\t--short-option <short-option>: version trigger short option [default: ' v ']\"\n\techo -e \"Usage :\n\t$0 <vernum> [--option <value>] [--short-option <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--option=*)\n\t\t\t\t_arg_option=\"${_key##--option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--short-option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short-option=*)\n\t\t\t\t_arg_short_option=\"${_key##--short-option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"vernum\"\n\tif [ \"${_positionals_count}\" -gt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_vernum \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\tvernum: ${_arg_vernum}\";\n\techo -e \"\\toption: ${_arg_option}\";\n\techo -e \"\\tshort-option: ${_arg_short_option}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\noutStr=\"\";\n\nif [ \"$_arg_option\" != \"\" ]; then\n\toutStr+=\"--$_arg_option\";\nfi\nif [ \"$_arg_short_option\" != \"\" ]; then\n\toutStr=\"-$_arg_short_option|$outStr\";\nfi\n\necho -e \"$outStr)\n\tprint_version;\n\texit 0;\n\t;;\"\n\nif [ \"$_arg_short_option\" != \"\" ]; then\n\techo -e \"-${_arg_short_option}*)\n\tprint_version;\n\texit 0;\n\t;;\";\nfi\n",
  "/parseArger/bin/version/declaration": "#!/bin/bash\n\n# @parseArger-begin\n# @parseArger-help \"create common version stuff\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos vernum \"your version number\"\n# @parseArger opt option \"version trigger option\" --default-value \"version\"\n# @parseArger opt short-option \"version trigger short option\" --default-value \"v\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/version\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_vernum=\"\";\n# OPTIONALS ARGUMENTS\n_arg_option=\"version\"\n_arg_short_option=\"v\"\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"create common version stuff:\"\n\techo -e \"\tvernum: your version number\"\n\techo -e \"\t--option <option>: version trigger option [default: ' version ']\"\n\techo -e \"\t--short-option <short-option>: version trigger short option [default: ' v ']\"\n\techo -e \"Usage :\n\t$0 <vernum> [--option <value>] [--short-option <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--option=*)\n\t\t\t\t_arg_option=\"${_key##--option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--short-option)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short_option=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short-option=*)\n\t\t\t\t_arg_short_option=\"${_key##--short-option=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"vernum\"\n\tif [ \"${_positionals_count}\" -gt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_vernum \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\tvernum: ${_arg_vernum}\";\n\techo -e \"\\toption: ${_arg_option}\";\n\techo -e \"\\tshort-option: ${_arg_short_option}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\noutStr=\"# @parse\";\noutStr+=\"Arger-version \\\"$_arg_vernum\\\"\";\n\nif [ \"$_arg_option\" != \"\" ]; then\n\toutStr+=\" --option \\\"$_arg_option\\\"\";\nfi\nif [ \"$_arg_short_option\" != \"\" ]; then\n\toutStr+=\" --short-option \\\"$_arg_short_option\\\"\";\nfi\n\necho \"$outStr\";\n",
  "/parseArger/bin/html-form": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"generate html form for a parsearger file\" --option \"help\" --short-option \"h\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos file \"file to process\"\n# @parseArger opt command \"command string, default to file \"\n# @parseArger opt action \"form action\"\n# @parseArger opt form-class \"form html class\"\n# @parseArger opt input-container-class \"input container class\" --default-value \"form-group\"\n# @parseArger opt input-class \"input class\" --default-value \"form-control\"\n# @parseArger opt label-class \"label class\" --default-value \"form-label\"\n# @parseArger opt select-class \"select class\" --default-value \"form-select\"\n# @parseArger opt checkbox-container-class \"checkbox and radio class\" --default-value \"form-check\" --alias radio-container-class\n# @parseArger opt checkbox-class \"checkbox and radio class\" --default-value \"form-check-input\" --alias radio-class\n# @parseArger opt checkbox-label-class \"checkbox and radio label class\" --default-value \"form-check-label\" --alias radio-label-class\n# @parseArger opt parent-form \"parent form for result\"\n# @parseArger flag form \"display form\" --on\n# @parseArger flag button \"display button\" --on\n# @parseArger flag js \"create javascript, --no-js forces --no-result\" --on\n# @parseArger flag result \"display result\" --on\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_file=\"\";\n# OPTIONALS ARGUMENTS\n_arg_command=\n_arg_action=\n_arg_form_class=\n_arg_input_container_class=\"form-group\"\n_arg_input_class=\"form-control\"\n_arg_label_class=\"form-label\"\n_arg_select_class=\"form-select\"\n_arg_checkbox_container_class=\"form-check\"\n_arg_checkbox_class=\"form-check-input\"\n_arg_checkbox_label_class=\"form-check-label\"\n_arg_parent_form=\n# FLAGS\n_arg_form=\"on\"\n_arg_button=\"on\"\n_arg_js=\"on\"\n_arg_result=\"on\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"generate html form for a parsearger file:\"\n\techo -e \"\tfile: file to process\"\n\techo -e \"\t--command <command>: command string, default to file \"\n\techo -e \"\t--action <action>: form action\"\n\techo -e \"\t--form-class <form-class>: form html class\"\n\techo -e \"\t--input-container-class <input-container-class>: input container class [default: ' form-group ']\"\n\techo -e \"\t--input-class <input-class>: input class [default: ' form-control ']\"\n\techo -e \"\t--label-class <label-class>: label class [default: ' form-label ']\"\n\techo -e \"\t--select-class <select-class>: select class [default: ' form-select ']\"\n\techo -e \"\t--checkbox-container-class|--radio-container-class <checkbox-container-class>: checkbox and radio class [default: ' form-check ']\"\n\techo -e \"\t--checkbox-class|--radio-class <checkbox-class>: checkbox and radio class [default: ' form-check-input ']\"\n\techo -e \"\t--checkbox-label-class|--radio-label-class <checkbox-label-class>: checkbox and radio label class [default: ' form-check-label ']\"\n\techo -e \"\t--parent-form <parent-form>: parent form for result\"\n\techo -e \"\t--form|--no-form: display form, on by default (use --no-form to turn it off)\"\n\techo -e \"\t--button|--no-button: display button, on by default (use --no-button to turn it off)\"\n\techo -e \"\t--js|--no-js: create javascript, --no-js forces --no-result, on by default (use --no-js to turn it off)\"\n\techo -e \"\t--result|--no-result: display result, on by default (use --no-result to turn it off)\"\n\techo -e \"Usage :\n\t$0 <file> [--command <value>] [--action <value>] [--form-class <value>] [--input-container-class <value>] [--input-class <value>] [--label-class <value>] [--select-class <value>] [--checkbox-container-class <value>] [--checkbox-class <value>] [--checkbox-label-class <value>] [--parent-form <value>] [--[no-]form] [--[no-]button] [--[no-]js] [--[no-]result]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--command)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_command=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--command=*)\n\t\t\t\t_arg_command=\"${_key##--command=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--action)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_action=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--action=*)\n\t\t\t\t_arg_action=\"${_key##--action=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--form-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_form_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--form-class=*)\n\t\t\t\t_arg_form_class=\"${_key##--form-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--input-container-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_input_container_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--input-container-class=*)\n\t\t\t\t_arg_input_container_class=\"${_key##--input-container-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--input-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_input_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--input-class=*)\n\t\t\t\t_arg_input_class=\"${_key##--input-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--label-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_label_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--label-class=*)\n\t\t\t\t_arg_label_class=\"${_key##--label-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--select-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_select_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--select-class=*)\n\t\t\t\t_arg_select_class=\"${_key##--select-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--radio-container-class|--checkbox-container-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_checkbox_container_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--checkbox-container-class=*)\n\t\t\t\t_arg_checkbox_container_class=\"${_key##--checkbox-container-class=}\"\n\t\t\t\t;;\n\t\t\t--radio-container-class=*)\n\t\t\t\t_arg_checkbox_container_class=\"${_key##--radio-container-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--radio-class|--checkbox-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_checkbox_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--checkbox-class=*)\n\t\t\t\t_arg_checkbox_class=\"${_key##--checkbox-class=}\"\n\t\t\t\t;;\n\t\t\t--radio-class=*)\n\t\t\t\t_arg_checkbox_class=\"${_key##--radio-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--radio-label-class|--checkbox-label-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_checkbox_label_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--checkbox-label-class=*)\n\t\t\t\t_arg_checkbox_label_class=\"${_key##--checkbox-label-class=}\"\n\t\t\t\t;;\n\t\t\t--radio-label-class=*)\n\t\t\t\t_arg_checkbox_label_class=\"${_key##--radio-label-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--parent-form)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_parent_form=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--parent-form=*)\n\t\t\t\t_arg_parent_form=\"${_key##--parent-form=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--form)\n\t\t\t\t_arg_form=\"on\"\n\t\t\t\t;;\n\t\t\t--no-form)\n\t\t\t\t_arg_form=\"off\"\n\t\t\t\t;;\n\t\t\t--button)\n\t\t\t\t_arg_button=\"on\"\n\t\t\t\t;;\n\t\t\t--no-button)\n\t\t\t\t_arg_button=\"off\"\n\t\t\t\t;;\n\t\t\t--js)\n\t\t\t\t_arg_js=\"on\"\n\t\t\t\t;;\n\t\t\t--no-js)\n\t\t\t\t_arg_js=\"off\"\n\t\t\t\t;;\n\t\t\t--result)\n\t\t\t\t_arg_result=\"on\"\n\t\t\t\t;;\n\t\t\t--no-result)\n\t\t\t\t_arg_result=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"file\"\n\tif [ \"${_positionals_count}\" -gt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_file \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\";\n\t\tlocal _regex=\"${!_match_var}\";\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\tfile: ${_arg_file}\";\n\techo -e \"\tcommand: ${_arg_command}\";\n\techo -e \"\taction: ${_arg_action}\";\n\techo -e \"\tform-class: ${_arg_form_class}\";\n\techo -e \"\tinput-container-class: ${_arg_input_container_class}\";\n\techo -e \"\tinput-class: ${_arg_input_class}\";\n\techo -e \"\tlabel-class: ${_arg_label_class}\";\n\techo -e \"\tselect-class: ${_arg_select_class}\";\n\techo -e \"\tcheckbox-container-class: ${_arg_checkbox_container_class}\";\n\techo -e \"\tcheckbox-class: ${_arg_checkbox_class}\";\n\techo -e \"\tcheckbox-label-class: ${_arg_checkbox_label_class}\";\n\techo -e \"\tparent-form: ${_arg_parent_form}\";\n\techo -e \"\tform: ${_arg_form}\";\n\techo -e \"\tbutton: ${_arg_button}\";\n\techo -e \"\tjs: ${_arg_js}\";\n\techo -e \"\tresult: ${_arg_result}\";\n\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nsource \"$_SCRIPT_DIR/utils\";\n\n_psthrcmncls=( \"--input-container-class\" \"${_arg_input_container_class}\" \"--input-class\" \"${_arg_input_class}\" \"--label-class\" \"${_arg_label_class}\" \"--select-class\" \"${_arg_select_class}\")\n_psthrfrmcls=()\nif [ \"$_arg_form_class\" != \"\" ]; then\n\t_psthrfrmcls=( \"--form-class\" \"${_arg_form_class}\")\nfi\n_psthrcbxcls=( \"--checkbox-container-class\" \"${_arg_checkbox_container_class}\" \"--checkbox-class\" \"${_arg_checkbox_class}\" \"--checkbox-label-class\" \"${_arg_checkbox_label_class}\")\n\nif [ \"$_arg_command\" == \"\" ]; then\n\t_arg_command=\"$_arg_file\";\nfi\n\n_pos=();\n_opt=();\n_flag=();\nparsearger_get_pos _pos \"$_arg_file\";\nparsearger_get_opt _opt \"$_arg_file\";\nparsearger_get_flag _flag \"$_arg_file\";\n\n_frmName=\"${_arg_file//\\//_}\";\n_frmName=\"${_frmName//./_}\";\n_frmName=\"${_frmName// /_}\";\n_frmName=\"${_frmName//:/_}\";\n_frmName=\"${_frmName//-/_}\";\n\noutput=\"\";\n\nif [ \"$_arg_form\" != \"off\" ]; then\n\toutput+=\"<form id=\\\"${_frmName}\\\"\";\n\tif [ \"$_arg_form_class\" != \"\" ]; then\n\t\toutput+=\" class=\\\"${_arg_form_class}\\\"\";\n\tfi\n\toutput+=\">\\n<h2>${_arg_command} form</h2>\\n\";\nfi\n_subcmd=\"\";\nfor _ipos in \"${_pos[@]}\"; do\n\tif [ \"$_ipos\" != \"\" ]; then\n\t\tisscmd=\"$(eval \"source $_SCRIPT_DIR/pos/is-subcmd $_ipos\")\";\n\t\tif [[ \"$isscmd\" == \"0\" ]]; then\n\t\t\t_subcmd=\"$_ipos\"\n\t\tfi\n\t\toutput+=\"$(eval \"source $_SCRIPT_DIR/pos/html ${_ipos} ${_psthrcmncls[*]} ${_psthrcbxcls[*]} ${_psthrfrmcls[*]}\")\";\n\tfi\ndone\nfor _iopt in \"${_opt[@]}\"; do\n\tif [ \"$_iopt\" != \"\" ]; then\n\t\toutput+=\"$(eval \"source $_SCRIPT_DIR/opt/html ${_iopt} ${_psthrcmncls[*]}\")\";\n\tfi\ndone\nfor _iflag in \"${_flag[@]}\"; do\n\tif [ \"$_iflag\" != \"\" ]; then\n\t\toutput+=\"$(eval \"source $_SCRIPT_DIR/flag/html ${_iflag} ${_psthrcbxcls[*]}\")\";\n\tfi\ndone\n\nif [ \"$_arg_form\" != \"off\" ]; then\n\tif [ \"$_arg_button\" != \"off\" ]; then\n\t\toutput+=\"<button id=\\\"${_frmName}_parse_btn\\\">Parse</button>\";\n\tfi\n\tif [ \"$_arg_result\" != \"off\" ]; then\n\t\toutput+=\"\\n\\t<pre id=\\\"${_frmName}_result\\\" contenteditable=true ></pre>\";\n\t\toutput+=\"\\n\\t<pre id=\\\"${_frmName}_server_response\\\"></pre>\";\n\tfi\n\toutput+=\"\\n</form>\";\n\tif [ \"${_subcmd}\" != \"\" ]; then\n\t\toutput+=\"$(eval \"source $_SCRIPT_DIR/pos/subcmd-html ${_ipos} ${_psthrcmncls[*]} ${_psthrcbxcls[*]} ${_psthrfrmcls[*]} --parent-form \\\"${_frmName}\\\"\")\"\n\tfi\nfi\n\n\nif [ \"$_arg_js\" != \"off\" ]; then\n\toutput+=\"\\n<script type=\\\"text/javascript\\\">\n\tfunction ${_frmName}_parse(__form) { \n\t\tlet ${_frmName}_frm = new FormData(__form);\n\t\tlet out = '\";\n\t\tif [ \"$_arg_parent_form\" == \"\" ]; then\n\t\t\toutput+=\"${_arg_command}\";\n\t\tfi\n\t\toutput+=\"';\n\t\tfor(const inp of ${_frmName}_frm.keys()) {\n\t\t\tconst ielt = document.getElementById(inp);\n\t\t\tswitch(ielt.getAttribute('pa-type')) {\n\t\t\t\tcase 'pos':\n\t\t\t\t\tif (/[\\s!@#$%^&*()_+=[\\]{};':\\\"\\\\\\\\|,.<>/?]/.test(${_frmName}_frm.get(inp))) {\n\t\t\t\t\t\tout+=' \\\"'+${_frmName}_frm.get(inp)+'\\\"';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout+=' '+${_frmName}_frm.get(inp);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'opt':\n\t\t\t\t\tif(${_frmName}_frm.get(inp) !== '') {\n\t\t\t\t\t\tif (ielt.hasAttribute('pa-repeat')) {\n\t\t\t\t\t\t\tfor(const val of ${_frmName}_frm.get(inp).split(\\`\n\\`)) {\n\t\t\t\t\t\t\t\tout+=' --'+inp+' \\\"'+val+'\\\"';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout+=' --'+inp+' \\\"'+${_frmName}_frm.get(inp)+'\\\"';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'flag':\n\t\t\t\t\tif(ielt.checked === true) {\n\t\t\t\t\t\tout+=' --'+inp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout+=' --no-'+inp;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\";\n\t\tif [ \"$_arg_parent_form\" != \"\" ]; then\n\t\t\toutput+=\"\n\t\t// document.getElementById('${_arg_parent_form}_parse_btn').parentNode.dispatchEvent(new Event('submit'));\n\t\tdocument.getElementById('${_arg_parent_form}_parse_btn').click();\n\t\tout=document.getElementById('${_arg_parent_form}_result').innerHTML+out;\n\t\tdocument.getElementById('${_arg_parent_form}_result').innerHTML=out;\n\t\t\";\n\t\tfi\n\t\toutput+=\"\n\t\tdocument.getElementById('${_frmName}_result').innerHTML=out;\n\t}\";\n\tif [ \"$_arg_result\" != \"off\" ] && [ \"$_arg_form\" != \"off\" ]; then\n\t\toutput+=\"\\ndocument.getElementById('${_frmName}').addEventListener('submit', function(e) {\n\t\t\t\te.preventDefault();\n\t\t\t\te.target.checkValidity();\n\t\t\t\t${_frmName}_parse(e.target);\n\t\t\t\tif ((window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') \n\t\t\t\t\t&& (window.location.protocol === 'http:' || window.location.protocol === 'https:')\n\t\t\t\t\t&& (window.location.port !== '80' && window.location.port !== '443')) {\n\t\t\t\t\tfetch(window.location.protocol+'//' + window.location.hostname + ':' + window.location.port + '/form', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\tbody:document.getElementById('${_arg_parent_form}_result').innerHTML.replace(/${_arg_command} /g, '')\n\t\t\t\t\t})\n\t\t\t\t\t\t.then(response => response.text())\n\t\t\t\t\t\t.then(result => {\n\t\t\t\t\t\t\tdocument.getElementById('${_frmName}_server_response').innerHTML = result;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\t\tdocument.getElementById('${_frmName}_server_response').innerHTML = error;\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\";\n\tfi\n\toutput+=\"\\n</script>\";\nfi\n\necho -e \"$output\";\n",
  "/parseArger/bin/project": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"generate or parse a project\" --option \"help\" --short-option \"h\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-leftovers leftovers\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos name \"project name\"\n# @parseArger pos target \"specific stuff on a project\" --optional --subcommand-directory \"bin/_project\" --subcommand --one-of \"git-init\" --one-of \"installer\" --one-of \"git-init\" --one-of \"mkfile\" --one-of \"webserver\"\n# @parseArger opt description \"project description\" --alias project-help\n# @parseArger opt directory \"output directory, ./<project_name> by default\" --short d --alias dir --complete \"directory\"\n# @parseArger opt project-subcommand-dir \"subcommand script directory\" --default-value \"bin\" --alias subcommand-directory\n# @parseArger opt project-subcommand \"project subcommand, forces has-subcommand\" --repeat\n# @parseArger opt completely \"generate bash completion, filenames (.yaml and .bash) if value is specified\"\n# @parseArger opt document \"generate documentation, filename (.md) if value is specified\" --default-value \"on\"\n# @parseArger opt html-form \"generate html-form, filename (.html) if value is specified\" --default-value \"on\"\n# @parseArger opt cp \"file or directory to copy to the project directory\" --repeat --complete \"file\" --complete \"directory\"\n# @parseArger opt installer-git-service \"git service\" --default-value \"github.com\" --alias git-provider\n# @parseArger opt installer-git-repo \"git repo eg DimitriGilbert/parseArger\" --alias git-repo\n# @parseArger opt git-add \"stuff to add to git\" --repeat\n# @parseArger opt git-commit \"commit, force --git-add\" --alias commit\n# @parseArger flag readme \"create a basic readme\" --on\n# @parseArger flag git \"git init\" --on\n# @parseArger flag makefile \"generate a makefile\" --on\n# @parseArger flag web-server \"add web server\" --on\n# @parseArger flag bashunit \"add bashunit lib to the project\"\n# @parseArger flag unit-tests \"add unit tests to the project, forces --bashunit\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_name=\"\";\n_arg_target=\"\";\n_one_of_arg_target=(\"git-init\" \"installer\" \"git-init\" \"mkfile\" \"webserver\" \"webserver\" );\n_optional_positionals+=(\"_arg_target\");\n_arg_subcommand_arg=\"_arg_target\";\n__subcommand=();\n# OPTIONALS ARGUMENTS\n_arg_description=\n_arg_directory=\n_arg_project_subcommand_dir=\"bin\"\n_arg_project_subcommand=()\n_arg_completely=\n_arg_document=\"on\"\n_arg_html_form=\"on\"\n_arg_cp=()\n_arg_installer_git_service=\"github.com\"\n_arg_installer_git_repo=\n_arg_git_add=()\n_arg_git_commit=\n# FLAGS\n_arg_readme=\"on\"\n_arg_git=\"on\"\n_arg_makefile=\"on\"\n_arg_web_server=\"on\"\n_arg_bashunit=\"off\"\n_arg_unit_tests=\"off\"\n# NESTED\n# LEFTOVERS\n_arg_leftovers=()\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [ \"$__cli_arg_count\" -ge 2 ]; then\n\t\t# echo \"$0 sub command help\n\t#\"\n\t\t_triggerSCHelp=0;\n\t\t_helpHasBeenPrinted=0;\n\telse\n\t\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"generate or parse a project:\"\n\techo -e \"\tname: project name\"\n\techo -e \"\ttarget: specific stuff on a project, optional [one of 'git-init' 'installer' 'git-init' 'mkfile' 'webserver' 'webserver']\"\n\techo -e \"\t--description|--project-help <description>: project description\"\n\techo -e \"\t-d, --directory|--dir <directory>: output directory, ./<project_name> by default\"\n\techo -e \"\t--project-subcommand-dir|--subcommand-directory <project-subcommand-dir>: subcommand script directory [default: ' bin ']\"\n\techo -e \"\t--project-subcommand <project-subcommand>: project subcommand, forces has-subcommand, repeatable\"\n\techo -e \"\t--completely <completely>: generate bash completion, filenames (.yaml and .bash) if value is specified\"\n\techo -e \"\t--document <document>: generate documentation, filename (.md) if value is specified [default: ' on ']\"\n\techo -e \"\t--html-form <html-form>: generate html-form, filename (.html) if value is specified [default: ' on ']\"\n\techo -e \"\t--cp <cp>: file or directory to copy to the project directory, repeatable\"\n\techo -e \"\t--installer-git-service|--git-provider <installer-git-service>: git service [default: ' github.com ']\"\n\techo -e \"\t--installer-git-repo|--git-repo <installer-git-repo>: git repo eg DimitriGilbert/parseArger\"\n\techo -e \"\t--git-add <git-add>: stuff to add to git, repeatable\"\n\techo -e \"\t--git-commit|--commit <git-commit>: commit, force --git-add\"\n\techo -e \"\t--readme|--no-readme: create a basic readme, on by default (use --no-readme to turn it off)\"\n\techo -e \"\t--git|--no-git: git init, on by default (use --no-git to turn it off)\"\n\techo -e \"\t--makefile|--no-makefile: generate a makefile, on by default (use --no-makefile to turn it off)\"\n\techo -e \"\t--web-server|--no-web-server: add web server, on by default (use --no-web-server to turn it off)\"\n\techo -e \"\t--bashunit|--no-bashunit: add bashunit lib to the project\"\n\techo -e \"\t--unit-tests|--no-unit-tests: add unit tests to the project, forces --bashunit\"\n\techo -e \"Usage :\n\t$0 <name> [target] [--description <value>] [--directory <value>] [--project-subcommand-dir <value>] [--project-subcommand <value>] [--completely <value>] [--document <value>] [--html-form <value>] [--cp <value>] [--installer-git-service <value>] [--installer-git-repo <value>] [--git-add <value>] [--git-commit <value>] [--[no-]readme] [--[no-]git] [--[no-]makefile] [--[no-]web-server] [--[no-]bashunit] [--[no-]unit-tests]\";\n\tfi\n\n\tfi\n\t\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--project-help|--description)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_description=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--description=*)\n\t\t\t\t_arg_description=\"${_key##--description=}\"\n\t\t\t\t;;\n\t\t\t--project-help=*)\n\t\t\t\t_arg_description=\"${_key##--project-help=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-d|--dir|--directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_directory=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--directory=*)\n\t\t\t\t_arg_directory=\"${_key##--directory=}\"\n\t\t\t\t;;\n\t\t\t--dir=*)\n\t\t\t\t_arg_directory=\"${_key##--dir=}\"\n\t\t\t\t;;\n\t\t\t-d*)\n\t\t\t\t_arg_directory=\"${_key##-d}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--subcommand-directory|--project-subcommand-dir)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_project_subcommand_dir=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--project-subcommand-dir=*)\n\t\t\t\t_arg_project_subcommand_dir=\"${_key##--project-subcommand-dir=}\"\n\t\t\t\t;;\n\t\t\t--subcommand-directory=*)\n\t\t\t\t_arg_project_subcommand_dir=\"${_key##--subcommand-directory=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--project-subcommand)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_project_subcommand+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--project-subcommand=*)\n\t\t\t\t_arg_project_subcommand+=(\"${_key##--project-subcommand=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--completely)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_completely=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--completely=*)\n\t\t\t\t_arg_completely=\"${_key##--completely=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--document)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_document=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--document=*)\n\t\t\t\t_arg_document=\"${_key##--document=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--html-form)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_html_form=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--html-form=*)\n\t\t\t\t_arg_html_form=\"${_key##--html-form=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--cp)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_cp+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--cp=*)\n\t\t\t\t_arg_cp+=(\"${_key##--cp=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--git-provider|--installer-git-service)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_installer_git_service=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--installer-git-service=*)\n\t\t\t\t_arg_installer_git_service=\"${_key##--installer-git-service=}\"\n\t\t\t\t;;\n\t\t\t--git-provider=*)\n\t\t\t\t_arg_installer_git_service=\"${_key##--git-provider=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--git-repo|--installer-git-repo)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_installer_git_repo=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--installer-git-repo=*)\n\t\t\t\t_arg_installer_git_repo=\"${_key##--installer-git-repo=}\"\n\t\t\t\t;;\n\t\t\t--git-repo=*)\n\t\t\t\t_arg_installer_git_repo=\"${_key##--git-repo=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--git-add)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_git_add+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--git-add=*)\n\t\t\t\t_arg_git_add+=(\"${_key##--git-add=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--commit|--git-commit)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_git_commit=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--git-commit=*)\n\t\t\t\t_arg_git_commit=\"${_key##--git-commit=}\"\n\t\t\t\t;;\n\t\t\t--commit=*)\n\t\t\t\t_arg_git_commit=\"${_key##--commit=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--readme)\n\t\t\t\t_arg_readme=\"on\"\n\t\t\t\t;;\n\t\t\t--no-readme)\n\t\t\t\t_arg_readme=\"off\"\n\t\t\t\t;;\n\t\t\t--git)\n\t\t\t\t_arg_git=\"on\"\n\t\t\t\t;;\n\t\t\t--no-git)\n\t\t\t\t_arg_git=\"off\"\n\t\t\t\t;;\n\t\t\t--makefile)\n\t\t\t\t_arg_makefile=\"on\"\n\t\t\t\t;;\n\t\t\t--no-makefile)\n\t\t\t\t_arg_makefile=\"off\"\n\t\t\t\t;;\n\t\t\t--web-server)\n\t\t\t\t_arg_web_server=\"on\"\n\t\t\t\t;;\n\t\t\t--no-web-server)\n\t\t\t\t_arg_web_server=\"off\"\n\t\t\t\t;;\n\t\t\t--bashunit)\n\t\t\t\t_arg_bashunit=\"on\"\n\t\t\t\t;;\n\t\t\t--no-bashunit)\n\t\t\t\t_arg_bashunit=\"off\"\n\t\t\t\t;;\n\t\t\t--unit-tests)\n\t\t\t\t_arg_unit_tests=\"on\"\n\t\t\t\t;;\n\t\t\t--no-unit-tests)\n\t\t\t\t_arg_unit_tests=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"name\"\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_name _arg_target \";\n\t_leftovers_count=$((${#_positionals[@]} - 2))\n\tfor ((ii = 0; ii < _leftovers_count; ii++));do\n\t\t_positional_names=\"$_positional_names _arg_leftovers[$((ii + 0))]\";\n\tdone\n\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\tif ! [[ \"$_positional_name\" =~ \"_arg_leftovers\" ]];then\n\t\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\t\tlocal _match_var=\"_match${_positional_name}\";\n\t\t\tlocal _regex=\"${!_match_var}\";\n\t\t\tif [ -n \"$_regex\" ]; then\n\t\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\t\tfi\n\t\t\t\n\t\t\tif [ \"$_arg_subcommand_arg\" == \"$_positional_name\" ];then\n\t\t\t\tif [ -f \"${1}\" ];then\n\t\t\t\t\t__subcommand+=(\"${1}\");\n\t\t\t\telif [ -f \"$_SCRIPT_DIR/${1}\" ];then\n\t\t\t\t\t__subcommand+=(\"$_SCRIPT_DIR/${1}\");\n\t\t\t\telif [[ \"\" == $(basename \"$_SCRIPT_DIR\")* ]];then\n\t\t\t\t\tcmdToSub=\"$(basename \"$_SCRIPT_DIR\")\";\n\t\t\t\t\tcmdsubDir=\"\";\n\t\t\t\t\t__subcommand+=(\"$_SCRIPT_DIR${cmdsubDir#\"${cmdToSub}\"}${1}\");\n\t\t\t\telse\n\t\t\t\t\t__subcommand+=(\"$_SCRIPT_DIR/${1}\");\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\tname: ${_arg_name}\";\n\techo -e \"\ttarget: ${_arg_target}\";\n\techo -e \"\tdescription: ${_arg_description}\";\n\techo -e \"\tdirectory: ${_arg_directory}\";\n\techo -e \"\tproject-subcommand-dir: ${_arg_project_subcommand_dir}\";\n\techo -e \"\tproject-subcommand: ${_arg_project_subcommand[*]}\";\n\techo -e \"\tcompletely: ${_arg_completely}\";\n\techo -e \"\tdocument: ${_arg_document}\";\n\techo -e \"\thtml-form: ${_arg_html_form}\";\n\techo -e \"\tcp: ${_arg_cp[*]}\";\n\techo -e \"\tinstaller-git-service: ${_arg_installer_git_service}\";\n\techo -e \"\tinstaller-git-repo: ${_arg_installer_git_repo}\";\n\techo -e \"\tgit-add: ${_arg_git_add[*]}\";\n\techo -e \"\tgit-commit: ${_arg_git_commit}\";\n\techo -e \"\treadme: ${_arg_readme}\";\n\techo -e \"\tgit: ${_arg_git}\";\n\techo -e \"\tmakefile: ${_arg_makefile}\";\n\techo -e \"\tweb-server: ${_arg_web_server}\";\n\techo -e \"\tbashunit: ${_arg_bashunit}\";\n\techo -e \"\tunit-tests: ${_arg_unit_tests}\";\n\techo -e \"\tleftovers: ${_arg_leftovers[*]}\";\n\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\nif [ \"$_triggerSCHelp\" == \"0\" ];then\n\t__subcommand+=(\"--help\");\nfi\nif [ \"$_verbose_level\" -ne \"0\" ];then\n\t__subcommand+=(\"--verbose\" \"$_verbose_level\");\nfi\n\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\nsource \"$_SCRIPT_DIR/utils\";\n\nif [ \"$_arg_target\" != \"\" ]; then\n\t__subcommand+=(\"$_arg_name\");\n\tlog \"${__subcommand[*]}\" 2;\n\t__subcommand+=(\"${_arg_leftovers[@]}\");\n\tif [ \"$_arg_installer_git_repo\" != \"\" ]; then\n\t\t__subcommand+=(\"--git-repo\" \"$_arg_installer_git_repo\");\n\tfi\n\t\"${__subcommand[@]}\";\nelif [ \"$_helpHasBeenPrinted\" == \"0\" ]; then\n\tprint_help;\nelse\n\tif [ \"$_arg_directory\" == \"\" ]; then\n\t\tlog \"No directory specified\" 3;\n\t\t_arg_directory=\"$(pwd)/$_arg_name\";\n\tfi\n\n\tif [ \"$_arg_description\" == \"\" ]; then\n\t\tlog \"No description specified\" 3;\n\t\t_arg_description=\"$_arg_name, a ParseArger project\";\n\tfi\n\n\tif [ ! -d \"$_arg_directory\" ]; then\n\t\tlog \"Creating $_arg_directory\" 2;\n\t\tmkdir -p \"$_arg_directory\";\n\tfi\n\n\tcd \"$_arg_directory\";\n\n\tpaBin=\"$_SCRIPT_DIR/../parseArger\";\n\n\tmainBin=\"$_arg_name\"\n\tgenMainCmd=(\"$paBin\" generate --help-message \"$_arg_description\" --output \"$mainBin\");\n\n\tif [ \"${#_arg_project_subcommand[@]}\" -gt 0 ]; then\n\t\tlog \"Generating subcommands\" 4;\n\t\t\n\t\tif [ ! -d \"./${_arg_project_subcommand_dir}\" ]; then\n\t\t\tlog \"Creating ./${_arg_project_subcommand_dir}\" 2;\n\t\t\tmkdir -p \"./${_arg_project_subcommand_dir}\";\n\t\tfi\n\t\t\n\t\tgenMainCmd+=(--leftovers \n\t\t\t--pos \"target '$_arg_name subcommand' --subcommand-use-leftovers --subcommand-run --subcommand-directory '${_arg_project_subcommand_dir}'\"\n\t\t);\n\t\t\n\t\tfor sbcmd in \"${_arg_project_subcommand[@]}\"; do\n\t\t\tif [ ! -f \"./${_arg_project_subcommand_dir}/$sbcmd\" ]; then\n\t\t\t\tlog \"Generating ./${_arg_project_subcommand_dir}/$sbcmd\" 1;\n\t\t\t\t\"$paBin\" generate --help-message \"$_arg_name $sbcmd command\" --output \"./${_arg_project_subcommand_dir}/$sbcmd\";\n\t\t\telse \n\t\t\t\tlog \"Parsing ./${_arg_project_subcommand_dir}/$sbcmd\" 1;\n\t\t\t\t\"$paBin\" parse -i \"./${_arg_project_subcommand_dir}/$sbcmd\";\n\t\t\tfi\n\t\tdone\n\n\tfi\n\n\tif [ \"${#_arg_cp[@]}\" -gt 0 ]; then\n\t\tlog \"Copying files and directories\" 4;\n\t\tfor cp in \"${_arg_cp[@]}\"; do\n\t\t\tif [ -d \"$cp\" ]; then\n\t\t\t\tlog \"copying directory $cp\" 2;\n\t\t\t\tcp -r \"$cp\" \"./\";\n\t\t\telif [ -f \"$cp\" ]; then\n\t\t\t\tlog \"copying $cp\" 2;\n\t\t\t\tcp \"$cp\" \"./\"\n\t\t\telse\n\t\t\t\tlog \"No such file or directory :\\n$cp\" -1;\n\t\t\tfi\n\t\tdone\n\tfi\n\n\tif [ ! -f \"$mainBin\" ]; then\n\t\tlog \"Generating main command\" 4;\n\t\tlog \"${genMainCmd[*]}\" 1;\n\t\t\"${genMainCmd[@]}\";\n\telse \n\t\tlog \"Parsing main command\" 4;\n\t\t\"$paBin\" parse -i \"$mainBin\";\n\tfi\n\n\tif [ \"$_arg_completely\" != \"\" ]; then\n\t\tlog \"Generating completions\" 4;\n\t\tpacCmd=(\"$paBin\" completely \"$_arg_name\" \"$mainBin\");\n\t\tif [ \"$_arg_completely\" != \"on\" ]; then\n\t\t\tpacCmd+=(--yaml-file  \"${_arg_completely}.yaml\" --completion-file \"${_arg_completely}.bash\");\n\t\tfi\n\t\tlog \"${pacCmd[*]}\" 1;\n\t\t\"${pacCmd[@]}\";\n\tfi\n\n\tif [ \"$_arg_document\" != \"\" ]; then\n\t\tlog \"Generating documentation\" 4;\n\t\tif [ \"$_arg_document\" == \"on\" ]; then\n\t\t\t_arg_document=\"documentation\";\n\t\tfi\n\t\t\n\t\tif [ ! -f \"${_arg_document}.md\" ]; then\n\t\t\tpadCmd=(\"$paBin\" document --file \"./$mainBin\" --out \"${_arg_document}.md\");\n\n\t\t\tlog \"${padCmd[*]}\" 1;\n\t\t\t\"${padCmd[@]}\";\n\t\telse\n\t\t\tlog \"documentation already exists\" -1;\n\t\tfi\n\tfi\n\n\tif [ \"$_arg_html_form\" != \"\" ]; then\n\t\tlog \"Generating html form\" 4;\n\t\tif [ \"$_arg_html_form\" == \"on\" ]; then\n\t\t\t_arg_html_form=\"form\";\n\t\tfi\n\t\t\n\t\tif [ ! -f \"${_arg_html_form}.html\" ]; then\n\t\t\t\n\t\t\tpahCmd=(\"$paBin\" html-form \"$mainBin\" --output \"${_arg_html_form}.html\");\n\n\t\t\tlog \"${pahCmd[*]}\" 1;\n\t\t\t\"${pahCmd[@]}\";\n\t\telse\n\t\t\tlog \"html form already exists\" -1;\n\t\tfi\n\tfi\n\n\tif [ \"$_arg_readme\" != \"off\" ]; then\n\t\tlog \"Generating readme\" 4;\n\t\t\n\t\tif [ ! -f \"${_arg_readme}\" ]; then\n\t\t\techo -e \"# $_arg_name\\n\\n$_arg_description\\n\" > readme.md;\n\t\telse\n\t\t\tlog \"readme already exists\" -1;\n\t\tfi\n\tfi\n\n\tif [ \"$_arg_makefile\" == \"on\" ]; then\n\t\tlog \"Generating makefile\" 4;\n\t\tif [ ! -f \"makefile\" ]; then\n\t\t\tgenMkf=(\"$_SCRIPT_DIR/_project/mkfile\" \"$_arg_name\");\n\t\t\t\"${genMkf[@]}\";\n\t\telse\n\t\t\tlog \"makefile already exists\" -1;\n\t\tfi\n\tfi\n\n\tif [ \"$_arg_web_server\" == \"on\" ]; then\n\t\tlog \"Generating web server\" 4;\n\t\tsource \"$_SCRIPT_DIR/_project/webserver\" \"$_arg_name\";\n\tfi\n\n\tif [ \"$_arg_installer_git_repo\" != \"\" ]; then\n\t\tlog \"Generating installer\" 4;\n\t\tgenIns=(\"$_SCRIPT_DIR/_project/installer\" \"$_arg_name\" --git-service \"$_arg_installer_git_service\" --git-repo \"$_arg_installer_git_repo\" --parsearger \"$paBin\");\n\t\t\"${genIns[@]}\";\n\tfi\n\n\tif [ \"$_arg_unit_tests\" == \"on\" ]; then\n\t\tlog \"Generating unit tests\" 4;\n\t\tmkdir tests;\n\t\tsed \"${_SCRIPT_DIR}/../templates/test_file\" \\\n\t\t\t-e \"s|__program_name__|$_arg_name|g\" \\\n\t\t\t-e \"s|__bin_name__|$_arg_name|g\" \\\n\t\t\t-e \"s|__program_name_upper__|${_arg_name^^}|g\" >> \"tests/000_${_arg_name}.test.sh\";\n\t\t\n\t\tif [ \"${#_arg_project_subcommand[@]}\" -gt 0 ]; then\n\t\t\t_tfile_index=1;\n\t\t\tfor sbcmd in \"${_arg_project_subcommand[@]}\"; do\n\t\t\t\t_t_name=\"${_arg_name}_${sbcmd}\";\n\t\t\t\tsed \"${_SCRIPT_DIR}/../templates/test_file\" \\\n\t\t\t\t\t-e \"s|__program_name__|$_t_name|g\" \\\n\t\t\t\t\t-e \"s|__bin_name__|$_arg_name $sbcmd|g\" \\\n\t\t\t\t\t-e \"s|__program_name_upper__|${_t_name^^}|g\" >> \"tests/00${_tfile_index}_${_t_name}.test.sh\";\n\t\t\t\t_tfile_index=$((_tfile_index + 1));\n\t\t\tdone\n\t\tfi\n\n\t\t_arg_bashunit=\"on\";\n\tfi\n\n\tif [ \"$_arg_bashunit\" != \"off\" ]; then\n\t\tlog \"Adding bashunit\" 4;\n\t\tbashunitInstallStr=$(curl -s https://bashunit.typeddevs.com/install.sh | bash);\n\t\tlog \"$bashunitInstallStr\" 4;\n\tfi\n\n\tif [ \"$_arg_git\" != \"off\" ] || [ \"${#_arg_git_add[@]}\" -gt 0 ] || [ \"$_arg_git_commit\" != \"\" ]; then\n\t\tlog \"Initializing git\" 4;\n\t\tgitInc=(\"$_SCRIPT_DIR/_project/git-init\");\n\t\tif [ \"${#_arg_git_add[@]}\" -gt 0 ]; then\n\t\t\tfor add in \"${_arg_git_add[@]}\"; do\n\t\t\t\tgitInc+=(--add \"$add\");\n\t\t\tdone\n\t\tfi\n\t\tif [ \"$_arg_git_commit\" != \"\" ]; then\n\t\t\tgitInc+=(--commit \"'$_arg_git_commit'\");\n\t\tfi\n\t\t\"${gitInc[@]}\";\n\n\t\tif [ \"$_arg_installer_git_repo\" != \"\" ]; then\n\t\t\tlog \"Adding remote origin\" 4;\n\t\t\tgit remote add origin \"git@${_arg_installer_git_service}:${_arg_installer_git_repo}.git\"\n\t\tfi\n\tfi\nfi\n",
  "/parseArger/bin/parse": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parse an existing parseArger script and add arguments, options, flag, etc...\" --option \"help\" --short-option \"h\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-set export PARSEARGER_ROOT_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\"/..;pwd -P);\nexport PARSEARGER_ROOT_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\"/..;pwd -P);\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos file \"file to parse\"\n# @parseArger opt pos \"add positional argument declaration\" --short p --repeat\n# @parseArger opt opt \"add optional arg declaration\" --short o --repeat\n# @parseArger opt flag \"add flag declaration\" --short f --repeat\n# @parseArger opt set \"add declare var\" --short s --repeat\n# @parseArger opt source \"add file to source\" --short l --repeat\n# @parseArger opt set-version \"set version\"\n# @parseArger opt dependencies \"set a dependency\" --repeat\n# @parseArger opt nested \"nested option declaration\" --repeat\n# @parseArger flag inplace \"replace parseArger generated content in place\" --short i\n# @parseArger flag leftovers \"enable leftovers\"\n# @parseArger flag parse-leftovers \"enable parsing of leftovers\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_file=\"\";\n# OPTIONALS ARGUMENTS\n_arg_pos=()\n_arg_opt=()\n_arg_flag=()\n_arg_set=()\n_arg_source=()\n_arg_set_version=\n_arg_dependencies=()\n_arg_nested=()\n# FLAGS\n_arg_inplace=\"off\"\n_arg_leftovers=\"off\"\n_arg_parse_leftovers=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parse an existing parseArger script and add arguments, options, flag, etc...:\"\n\techo -e \"\tfile: file to parse\"\n\techo -e \"\t-p, --pos <pos>: add positional argument declaration, repeatable\"\n\techo -e \"\t-o, --opt <opt>: add optional arg declaration, repeatable\"\n\techo -e \"\t-f, --flag <flag>: add flag declaration, repeatable\"\n\techo -e \"\t-s, --set <set>: add declare var, repeatable\"\n\techo -e \"\t-l, --source <source>: add file to source, repeatable\"\n\techo -e \"\t--set-version <set-version>: set version\"\n\techo -e \"\t--dependencies <dependencies>: set a dependency, repeatable\"\n\techo -e \"\t--nested <nested>: nested option declaration, repeatable\"\n\techo -e \"\t-i|--inplace|--no-inplace: replace parseArger generated content in place\"\n\techo -e \"\t--leftovers|--no-leftovers: enable leftovers\"\n\techo -e \"\t--parse-leftovers|--no-parse-leftovers: enable parsing of leftovers\"\n\techo -e \"Usage :\n\t$0 <file> [--pos <value>] [--opt <value>] [--flag <value>] [--set <value>] [--source <value>] [--set-version <value>] [--dependencies <value>] [--nested <value>] [--[no-]inplace] [--[no-]leftovers] [--[no-]parse-leftovers]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t-p|--pos)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_pos+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--pos=*)\n\t\t\t\t_arg_pos+=(\"${_key##--pos=}\")\n\t\t\t\t;;\n\t\t\t-p*)\n\t\t\t\t_arg_pos+=(\"${_key##-p}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-o|--opt)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_opt+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--opt=*)\n\t\t\t\t_arg_opt+=(\"${_key##--opt=}\")\n\t\t\t\t;;\n\t\t\t-o*)\n\t\t\t\t_arg_opt+=(\"${_key##-o}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-f|--flag)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_flag+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--flag=*)\n\t\t\t\t_arg_flag+=(\"${_key##--flag=}\")\n\t\t\t\t;;\n\t\t\t-f*)\n\t\t\t\t_arg_flag+=(\"${_key##-f}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-s|--set)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_set+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--set=*)\n\t\t\t\t_arg_set+=(\"${_key##--set=}\")\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_set+=(\"${_key##-s}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-l|--source)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_source+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--source=*)\n\t\t\t\t_arg_source+=(\"${_key##--source=}\")\n\t\t\t\t;;\n\t\t\t-l*)\n\t\t\t\t_arg_source+=(\"${_key##-l}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--set-version)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_set_version=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--set-version=*)\n\t\t\t\t_arg_set_version=\"${_key##--set-version=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--dependencies)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_dependencies+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--dependencies=*)\n\t\t\t\t_arg_dependencies+=(\"${_key##--dependencies=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--nested)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_nested+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--nested=*)\n\t\t\t\t_arg_nested+=(\"${_key##--nested=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-i|--inplace)\n\t\t\t\t_arg_inplace=\"on\"\n\t\t\t\t;;\n\t\t\t--no-inplace)\n\t\t\t\t_arg_inplace=\"off\"\n\t\t\t\t;;\n\t\t\t--leftovers)\n\t\t\t\t_arg_leftovers=\"on\"\n\t\t\t\t;;\n\t\t\t--no-leftovers)\n\t\t\t\t_arg_leftovers=\"off\"\n\t\t\t\t;;\n\t\t\t--parse-leftovers)\n\t\t\t\t_arg_parse_leftovers=\"on\"\n\t\t\t\t;;\n\t\t\t--no-parse-leftovers)\n\t\t\t\t_arg_parse_leftovers=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"file\"\n\tif [ \"${_positionals_count}\" -gt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 1 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_file \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\";\n\t\tlocal _regex=\"${!_match_var}\";\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\tfile: ${_arg_file}\";\n\techo -e \"\tpos: ${_arg_pos[*]}\";\n\techo -e \"\topt: ${_arg_opt[*]}\";\n\techo -e \"\tflag: ${_arg_flag[*]}\";\n\techo -e \"\tset: ${_arg_set[*]}\";\n\techo -e \"\tsource: ${_arg_source[*]}\";\n\techo -e \"\tset-version: ${_arg_set_version}\";\n\techo -e \"\tdependencies: ${_arg_dependencies[*]}\";\n\techo -e \"\tnested: ${_arg_nested[*]}\";\n\techo -e \"\tinplace: ${_arg_inplace}\";\n\techo -e \"\tleftovers: ${_arg_leftovers}\";\n\techo -e \"\tparse-leftovers: ${_arg_parse_leftovers}\";\n\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\nSCRIPT_ROOT_DIR=\"/parseArger/bin\";\nsource \"$SCRIPT_ROOT_DIR/utils\";\n\nparseHelpMessage() {\n\techo \"$1\";\n}\n\npaStart=\"# @parse\"\npaStart+=\"Arger\"\n\n_help=\"$(parsearger_get_help \"$_arg_file\")\";\n_version=\"$(parsearger_get_version \"$_arg_file\")\";\n_leftovers=\"$(parsearger_get_leftovers \"$_arg_file\")\";\n_parse_leftovers=\"$(parsearger_get_parse_leftovers \"$_arg_file\")\";\n_set=();\n_source=();\n_pos=();\n_opt=();\n_flag=();\n_nested=();\n_dependencies=();\nparsearger_get_set _set \"$_arg_file\";\nparsearger_get_source _source \"$_arg_file\";\nparsearger_get_pos _pos \"$_arg_file\";\nparsearger_get_opt _opt \"$_arg_file\";\nparsearger_get_flag _flag \"$_arg_file\";\nparsearger_get_nested _nested \"$_arg_file\";\nparsearger_get_dependencies _dependencies \"$_arg_file\";\n\n# echo \"_help: $_help\";\n# echo \"_set: ${_set[@]}\";\n# echo \"_leftovers: $_leftovers\";\n# echo \"_pos: ${_pos[@]}\";\n# echo \"_opt: ${_opt[@]}\";\n# echo \"_flag: ${_flag[@]}\";\n# echo \"_nested: ${_nested[@]}\";\n\ncmdGen=(\"--no-bang\");\n\nif [[ \"${_arg_set_version}\" != \"\" ]]; then\n\t# TODO: get versopn opt name and short\n\tcmdGen+=(\"--set-version\" \"${_arg_set_version}\");\nelif [[ \"${_version}\" != \"\" ]]; then\n\t_version=\"--set-version ${_version//--option/--version-opt-name}\";\n\t_version=\"${_version//--short-option/--version-short-option}\";\n\t_version=\"${_version//\\\"/}\";\n\t# echo \"$_version\";\n\tread -a vergen <<< \"$_version\";\n\tcmdGen+=(\"${vergen[@]}\");\nfi\n\nif [ \"$_help\" != \"\" ]; then\n  cmdGen+=(\"--help-message\" \"$(eval \"parseHelpMessage $_help\")\");\nfi\n\nif [ \"${_set[*]}\" != \"\" ] && [ \"${#_set[@]}\" -gt \"0\" ]; then\n  for __set in \"${_set[@]}\"; do\n    cmdGen+=(\"--set\" \"$__set\");\n  done\nfi\nif [[ \"${#_arg_set[@]}\" -gt 0 ]]; then\n\tfor __n_set in \"${_arg_set[@]}\"; do\n\t\tcmdGen+=(\"--set\" \"$__n_set\")\n\tdone\nfi\n\nif [ \"${_source[*]}\" != \"\" ] && [ \"${#_source[@]}\" -gt \"0\" ]; then\n  for __source in \"${_source[@]}\"; do\n    cmdGen+=(\"--source\" \"$__source\");\n  done\nfi\nif [[ \"${#_arg_source[@]}\" -gt 0 ]]; then\n\tfor __n_source in \"${_arg_source[@]}\"; do\n\t\tcmdGen+=(\"--source\" \"$__n_source\")\n\tdone\nfi\n\nif [ \"$_arg_leftovers\" != \"off\" ] || [ \"$_leftovers\" != \"\" ]; then\n  cmdGen+=(\"--leftovers\" \"--leftovers-name\" \"${_leftovers:-\"leftovers\"}\");\nfi\nif [ \"$_arg_parse_leftovers\" != \"off\" ] || [ \"$_parse_leftovers\" != \"\" ]; then\n\tcmdGen+=(\"--parse-leftovers\");\nfi\n\nif [ \"${_pos[*]}\" != \"\" ] && [ \"${#_pos[@]}\" -gt \"0\" ]; then\n  for __pos in \"${_pos[@]}\"; do\n    cmdGen+=(\"--pos\" \"$__pos\");\n  done\nfi\nif [[ \"${#_arg_pos[@]}\" -gt 0 ]]; then\n\tfor __n_pos in \"${_arg_pos[@]}\"; do\n\t\tcmdGen+=(\"--pos\" \"$__n_pos\")\n\tdone\nfi\n\nif [ \"${_opt[*]}\" != \"\" ] && [ \"${#_opt[@]}\" -gt \"0\" ]; then\n  for __opt in \"${_opt[@]}\"; do\n    cmdGen+=(\"--opt\" \"$__opt\");\n  done\nfi\nif [[ \"${#_arg_opt[@]}\" -gt 0 ]]; then\n\tfor __n_opt in \"${_arg_opt[@]}\"; do\n\t\tcmdGen+=(\"--opt\" \"$__n_opt\")\n\tdone\nfi\n\nif [ \"${_flag[*]}\" != \"\" ] && [ \"${#_flag[@]}\" -gt \"0\" ]; then\n  for __flag in \"${_flag[@]}\"; do\n    cmdGen+=(\"--flag\" \"$__flag\");\n  done\nfi\nif [[ \"${#_arg_flag[@]}\" -gt 0 ]]; then\n\tfor __n_flag in \"${_arg_flag[@]}\"; do\n\t\tcmdGen+=(\"--flag\" \"$__n_flag\")\n\tdone\nfi\n\nif [ \"${_nested[*]}\" != \"\" ] && [ \"${#_nested[@]}\" -gt \"0\" ]; then\n  for __nested in \"${_nested[@]}\"; do\n    cmdGen+=(\"--nested\" \"$__nested\");\n  done\nfi\nif [[ \"${#_arg_nested[@]}\" -gt 0 ]]; then\n\tfor __n_nested in \"${_arg_nested[@]}\"; do\n\t\tcmdGen+=(\"--nested\" \"$__n_nested\")\n\tdone\nfi\n\nif [ \"${_dependencies[*]}\" != \"\" ] && [ \"${#_dependencies[@]}\" -gt \"0\" ]; then\n  for __dependencies in \"${_dependencies[@]}\"; do\n    cmdGen+=(--dependencies \"$__dependencies\");\n  done\nfi\nif [[ \"${#_arg_dependencies[@]}\" -gt 0 ]]; then\n\tfor __n_dependencies in \"${_arg_dependencies[@]}\"; do\n\t\tcmdGen+=(--dependencies \"$__n_dependencies\")\n\tdone\nfi\n\n# XDG\n_xdg=\"$(parsearger_get_xdg \"$_arg_file\")\";\nif [ \"$_xdg\" != \"\" ]; then\n\t# Parse the XDG line to extract arguments\n\t# Format: \"appname\" --config --data --no-cache --config-file \"custom\"\n\t# Use eval to properly handle quoted strings\n\teval \"xdgArgs=($_xdg)\";\n\t# First arg is the app name\n\tcmdGen+=(--xdg \"${xdgArgs[0]}\");\n\t# Transform remaining args: --config -> --xdg-config, --no-cache -> --no-xdg-cache\n\tfor ((i=1; i<${#xdgArgs[@]}; i++)); do\n\t\t_xarg=\"${xdgArgs[$i]}\";\n\t\tcase \"$_xarg\" in\n\t\t\t--config) cmdGen+=(--xdg-config) ;;\n\t\t\t--no-config) cmdGen+=(--no-xdg-config) ;;\n\t\t\t--data) cmdGen+=(--xdg-data) ;;\n\t\t\t--no-data) cmdGen+=(--no-xdg-data) ;;\n\t\t\t--cache) cmdGen+=(--xdg-cache) ;;\n\t\t\t--no-cache) cmdGen+=(--no-xdg-cache) ;;\n\t\t\t--config-file) \n\t\t\t\tcmdGen+=(--xdg-config-file);\n\t\t\t\ti=$((i+1));\n\t\t\t\tcmdGen+=(\"${xdgArgs[$i]}\");\n\t\t\t\t;;\n\t\t\t*) cmdGen+=(\"$_xarg\") ;;\n\t\tesac\n\tdone\nfi\n\ntmpGen=\"$(mktemp)\";\nsource \"$SCRIPT_ROOT_DIR/generate\" \"${cmdGen[@]}\" > \"$tmpGen\";\n\ntmpMrk=\"tmpMrk\"\ntmpMrk=\"___${tmpMrk}___parsearger\"\n# https://unix.stackexchange.com/a/485670 <3\nparsedGen=\"$(sed -e \"/${paStart}-end/a ${tmpMrk}\" -e \"/${paStart}-begin/,/${paStart}-end/d\" \"$_arg_file\" | sed -e \"/${tmpMrk}/r ${tmpGen}\" -e \"/${tmpMrk}/d\")\";\n\nrm \"$tmpGen\";\n\nif [ \"$_arg_inplace\" == \"on\" ]; then\n  echo \"$parsedGen\" > \"$_arg_file\";\nelse \n  echo \"$parsedGen\";\nfi\n",
  "/parseArger/bin/nested/help": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger help string for options\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"nested option namespace\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt one-of \"accepted values for keys\" --repeat\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/nested\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_one_of=()\n_arg_complete=()\n_arg_complete_custom=()\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger help string for options:\"\n\techo -e \"\targ-name: nested option namespace\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--one-of <one-of>: accepted values for keys, repeatable\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--one-of <value>] [--complete <value>] [--complete-custom <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-\"0\"}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\noptHelp=\"--${_arg_arg_name}[-<key>]\";\n\noptHelp+=\" <${_arg_arg_name}-key-value>: nested, ${_arg_description}\";\n\necho -e \"\\techo -e \\\"\\t${optHelp}\\\"\";\n",
  "/parseArger/bin/nested/more-completely": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger declaration string for options\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"nested option namespace\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt one-of \"accepted values for keys\" --repeat\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/nested\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_one_of=()\n_arg_complete=()\n_arg_complete_custom=()\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger declaration string for options:\"\n\techo -e \"\targ-name: nested option namespace\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--one-of <one-of>: accepted values for keys, repeatable\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--one-of <value>] [--complete <value>] [--complete-custom <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-\"0\"}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\n\nif [ \"${#_arg_complete[@]}\" -gt 0 ] || [ \"${#_arg_complete_custom[@]}\" -gt 0 ]; then\n\techo \"${_arg_prefix}*--${_arg_arg_name}:\";\n\n\t_cpstr=\"\";\n\tif [ \"${#_arg_complete[@]}\" -gt 0 ]; then\n\t\tfor _cmpl in \"${_arg_complete[@]}\"; do\n\t\t\t_cpstr+=\"- <${_cmpl}>\\n\";\n\t\tdone\n\tfi\n\tif [ \"${#_arg_complete_custom[@]}\" -gt 0 ]; then\n\t\tfor _cmpl in \"${_arg_complete_custom[@]}\"; do\n\t\t\t_cpstr+=\"- \\$(${_cmpl})\\n\";\n\t\tdone\n\tfi\n\techo -e \"${_cpstr}\";\nfi\n",
  "/parseArger/bin/nested/html": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"option to html form\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"nested option namespace\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt one-of \"accepted values for keys\" --repeat\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt input-container-class \"input container class\" --default-value \"form-group\"\n# @parseArger opt input-class \"input class\" --default-value \"form-control\"\n# @parseArger opt label-class \"label class\" --default-value \"form-label\"\n# @parseArger opt select-class \"select class\" --default-value \"form-select\"\n# @parseArger opt checkbox-container-class \"checkbox and radio class\" --default-value \"form-check\" --alias radio-container-class\n# @parseArger opt checkbox-class \"checkbox and radio class\" --default-value \"form-check-input\" --alias radio-class\n# @parseArger opt checkbox-label-class \"checkbox and radio label class\" --default-value \"form-check-label\" --alias radio-label-class\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/nested\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_one_of=()\n_arg_complete=()\n_arg_complete_custom=()\n_arg_input_container_class=\"form-group\"\n_arg_input_class=\"form-control\"\n_arg_label_class=\"form-label\"\n_arg_select_class=\"form-select\"\n_arg_checkbox_container_class=\"form-check\"\n_arg_checkbox_class=\"form-check-input\"\n_arg_checkbox_label_class=\"form-check-label\"\n# FLAGS\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"option to html form:\"\n\techo -e \"\targ-name: nested option namespace\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--one-of <one-of>: accepted values for keys, repeatable\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--input-container-class <input-container-class>: input container class [default: ' form-group ']\"\n\techo -e \"\t--input-class <input-class>: input class [default: ' form-control ']\"\n\techo -e \"\t--label-class <label-class>: label class [default: ' form-label ']\"\n\techo -e \"\t--select-class <select-class>: select class [default: ' form-select ']\"\n\techo -e \"\t--checkbox-container-class|--radio-container-class <checkbox-container-class>: checkbox and radio class [default: ' form-check ']\"\n\techo -e \"\t--checkbox-class|--radio-class <checkbox-class>: checkbox and radio class [default: ' form-check-input ']\"\n\techo -e \"\t--checkbox-label-class|--radio-label-class <checkbox-label-class>: checkbox and radio label class [default: ' form-check-label ']\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--one-of <value>] [--complete <value>] [--complete-custom <value>] [--input-container-class <value>] [--input-class <value>] [--label-class <value>] [--select-class <value>] [--checkbox-container-class <value>] [--checkbox-class <value>] [--checkbox-label-class <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--input-container-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_input_container_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--input-container-class=*)\n\t\t\t\t_arg_input_container_class=\"${_key##--input-container-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--input-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_input_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--input-class=*)\n\t\t\t\t_arg_input_class=\"${_key##--input-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--label-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_label_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--label-class=*)\n\t\t\t\t_arg_label_class=\"${_key##--label-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--select-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_select_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--select-class=*)\n\t\t\t\t_arg_select_class=\"${_key##--select-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--radio-container-class|--checkbox-container-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_checkbox_container_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--checkbox-container-class=*)\n\t\t\t\t_arg_checkbox_container_class=\"${_key##--checkbox-container-class=}\"\n\t\t\t\t;;\n\t\t\t--radio-container-class=*)\n\t\t\t\t_arg_checkbox_container_class=\"${_key##--radio-container-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--radio-class|--checkbox-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_checkbox_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--checkbox-class=*)\n\t\t\t\t_arg_checkbox_class=\"${_key##--checkbox-class=}\"\n\t\t\t\t;;\n\t\t\t--radio-class=*)\n\t\t\t\t_arg_checkbox_class=\"${_key##--radio-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--radio-label-class|--checkbox-label-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_checkbox_label_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--checkbox-label-class=*)\n\t\t\t\t_arg_checkbox_label_class=\"${_key##--checkbox-label-class=}\"\n\t\t\t\t;;\n\t\t\t--radio-label-class=*)\n\t\t\t\t_arg_checkbox_label_class=\"${_key##--radio-label-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\targ-name: ${_arg_arg_name}\";\n\techo -e \"\tdescription: ${_arg_description}\";\n\techo -e \"\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\tinput-container-class: ${_arg_input_container_class}\";\n\techo -e \"\tinput-class: ${_arg_input_class}\";\n\techo -e \"\tlabel-class: ${_arg_label_class}\";\n\techo -e \"\tselect-class: ${_arg_select_class}\";\n\techo -e \"\tcheckbox-container-class: ${_arg_checkbox_container_class}\";\n\techo -e \"\tcheckbox-class: ${_arg_checkbox_class}\";\n\techo -e \"\tcheckbox-label-class: ${_arg_checkbox_label_class}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\ninptCmn=\"pa-type=\\\"opt\\\" name=\\\"${_arg_arg_name}\\\" id=\\\"${_arg_arg_name}\\\"\";\n\nif [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n\tinpuStr=\"<select class=\\\" class=\\\"${_arg_select_class}\\\"\\\" ${inptCmn}>\\n\";\n\tfor oof in \"${_arg_one_of[@]}\"; do\n\t\tinpuStr+=\"\\n\\t\\t<option value=\\\"${oof}\\\"\";\n\t\tif [ \"${#_arg_default_value[@]}\" -gt 0 ] && [ \"${_arg_default_value[0]}\" == \"$oof\" ]; then\n\t\t\tinpuStr+=\" selected\";\n\t\tfi\n\t\tinpuStr+=\">${oof}</option>\";\n\tdone\n\tinpuStr+=\"\\n\\t</select>\";\n# elif [ \"${_arg_repeat}\" == \"on\" ]; then\n# \tinpuStr=\"<textarea ${inptCmn} type=\\\"text\\\" pa-repeat class=\\\"${_arg_input_class}\\\">\";\n# \tif [ \"${#_arg_default_value[@]}\" -gt 0 ]; then\n# \t\tinpuStr+=\"${_arg_default_value[0]}\";\n# \tfi\n# \tinpuStr+=\"</textarea>\";\nelse\n\tinpuStr=\"<input class=\\\"${_arg_input_class}\\\" ${inptCmn} type=\\\"text\\\"\";\n\tif [ \"${#_arg_default_value[@]}\" -gt 0 ]; then\n\t\tinpuStr+=\" value=\\\"${_arg_default_value[0]}\\\"\";\n\tfi\n\tinpuStr+=\" />\";\nfi\n\necho -e \"<div class=\\\"${_arg_input_container_class}\\\">\n\t<label for=\\\"${_arg_arg_name}\\\" class=\\\"${_arg_label_class}\\\">${_arg_arg_name}</label>\n\t<span class=\\\"input-help\\\">${_arg_description}</span>\n\t${inpuStr}\n</div>\";\n",
  "/parseArger/bin/nested/completely": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger declaration string for nested options\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"nested option namespace\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt one-of \"accepted values for keys\" --repeat\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/nested\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_one_of=()\n_arg_complete=()\n_arg_complete_custom=()\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger declaration string for nested options:\"\n\techo -e \"\targ-name: nested option namespace\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--one-of <one-of>: accepted values for keys, repeatable\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--one-of <value>] [--complete <value>] [--complete-custom <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-\"0\"}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\n\necho \"- --${_arg_arg_name}\";\necho \"- --${_arg_arg_name}-\";\n",
  "/parseArger/bin/nested/init": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger init string for options\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"nested option namespace\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt one-of \"accepted values for keys\" --repeat\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/nested\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_one_of=()\n_arg_complete=()\n_arg_complete_custom=()\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger init string for options:\"\n\techo -e \"\targ-name: nested option namespace\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--one-of <one-of>: accepted values for keys, repeatable\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--one-of <value>] [--complete <value>] [--complete-custom <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-\"0\"}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\n_arg_arg_name=\"${_arg_arg_name//-/_}\"\noutStr=\"_arg_${_arg_arg_name}=\ndeclare -A _arg_ns_${_arg_arg_name};\";\n\nif [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n    outStr+=\"\\n_one_of_arg_${_arg_arg_name//-/_}=(\";\n    for i in \"${_arg_one_of[@]}\"; do\n        outStr+=\"\\\"$i\\\" \";\n    done\n    outStr+=\");\";\nfi\n\necho -e \"$outStr\";\n",
  "/parseArger/bin/nested/parser": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger parsing string for options\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"nested option namespace\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt one-of \"accepted values for keys\" --repeat\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/nested\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_one_of=()\n_arg_complete=()\n_arg_complete_custom=()\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger parsing string for options:\"\n\techo -e \"\targ-name: nested option namespace\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--one-of <one-of>: accepted values for keys, repeatable\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--one-of <value>] [--complete <value>] [--complete-custom <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-\"0\"}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\noptMissingValueError=\"Missing value for the option: \"\noptParser=\"--${_arg_arg_name})\\n\\t\";\n\nsetOptStr=\"_arg_${_arg_arg_name//-/_}=\\\"\\$2\\\"\";\n\n# TODO\n# if [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n# \tsetOptStr+=\"\\n\\tif [[ \\\"\\${#_one_of_arg_${_arg_arg_name//-/_}[@]}\\\" -gt 0 ]];then [[ \\\"\\${_one_of_arg_${_arg_arg_name//-/_}[*]}\\\" =~ (^|[[:space:]])\\\"\\$_arg_${_arg_arg_name//-/_}\\\"(\\$|[[:space:]]) ]] || die \\\"$_arg_arg_name must be one of: ${_arg_one_of[*]}\\\";fi\";\n# fi\n\noptParser+=\"test \\$# -lt 2 && die \\\"${optMissingValueError}'\\$_key'\\\" 1\n\t${setOptStr}\n\tshift\n\t;;\n\";\n\nsetvalstr=\"=\\\"\\${_key##--${_arg_arg_name}=}\\\"\"\noptParser=\"${optParser}--${_arg_arg_name}=*)\n\t_arg_${_arg_arg_name//-/_}${setvalstr}\";\n\n# TODO\n# if [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n# \toptParser+=\"\n# \tif [[ \\\"\\${#_one_of_arg_${_arg_arg_name//-/_}[@]}\\\" -gt 0 ]];then [[ \\\"\\${_one_of_arg_${_arg_arg_name//-/_}[*]}\\\" =~ (^|[[:space:]])\\\"\\$_arg_${_arg_arg_name//-/_}\\\"(\\$|[[:space:]]) ]] || die \\\"$_arg_arg_name must be one of: ${_arg_one_of[*]}\\\";fi\";\n# fi\n\noptParser+=\"\n\t;;\n\";\n\n# TODO : support some kind of serialization to have array in _arg_ns_*[$_ns_key]\noptParser+=\"--${_arg_arg_name}-*)\n\t_ns_key=\\\"\\${_key##--${_arg_arg_name}-}\\\";\n\ttest \\$# -lt 2 && die \\\"${optMissingValueError}'\\$_key-\\$_ns_key'\\\" 1;\n\t_arg_ns_${_arg_arg_name//-/_}[\\$_ns_key]=\\\"\\$2\\\";\n\tshift;\n\t;;\n\";\n\necho -e \"${optParser}\";\n",
  "/parseArger/bin/nested/docopt-help": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger docOpt string for option\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"nested option namespace\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt one-of \"accepted values for keys\" --repeat\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/nested\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_one_of=()\n_arg_complete=()\n_arg_complete_custom=()\n# FLAGS\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger docOpt string for option:\"\n\techo -e \"\targ-name: nested option namespace\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--one-of <one-of>: accepted values for keys, repeatable\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--one-of <value>] [--complete <value>] [--complete-custom <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-\"0\"}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\noptHelp=\"--${_arg_arg_name}[-<key>] ${_arg_arg_name}\";\n\noptHelp=\"${optHelp}\\t${_arg_description}\";\n\necho -e \"${optHelp}\";\n",
  "/parseArger/bin/nested/declaration": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger declaration string for options\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt default-value \"value\" --short d --repeat\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt alias \"option alias\" --repeat\n# @parseArger opt empty-value \"value for empty option\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag empty \"use option as flag\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/nested\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_default_value=()\n_arg_short=\n_arg_alias=()\n_arg_empty_value=\n_arg_complete=()\n_arg_complete_custom=()\n# FLAGS\n_arg_repeat=\"off\"\n_arg_empty=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger declaration string for options:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t-d, --default-value <default-value>: value, repeatable\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--alias <alias>: option alias, repeatable\"\n\techo -e \"\t--empty-value <empty-value>: value for empty option\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--empty|--no-empty: use option as flag\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--default-value <value>] [--short <value>] [--alias <value>] [--empty-value <value>] [--complete <value>] [--complete-custom <value>] [--[no-]repeat] [--[no-]empty]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-\"0\"}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-d|--default-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_default_value+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--default-value=*)\n\t\t\t\t_arg_default_value+=(\"${_key##--default-value=}\")\n\t\t\t\t;;\n\t\t\t-d*)\n\t\t\t\t_arg_default_value+=(\"${_key##-d}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--empty-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_empty_value=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--empty-value=*)\n\t\t\t\t_arg_empty_value=\"${_key##--empty-value=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--empty)\n\t\t\t\t_arg_empty=\"on\"\n\t\t\t\t;;\n\t\t\t--no-empty)\n\t\t\t\t_arg_empty=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tdefault-value: ${_arg_default_value[*]}\";\n\techo -e \"\\tshort: ${_arg_short}\";\n\techo -e \"\\talias: ${_arg_alias[*]}\";\n\techo -e \"\\tempty-value: ${_arg_empty_value}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\\trepeat: ${_arg_repeat}\";\n\techo -e \"\\tempty: ${_arg_empty}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\noutStr=\"# @parse\"\noutStr+=\"Arger nested $_arg_arg_name \\\"${_arg_description}\\\"\"\n\nif [ \"$_arg_short\" != \"\" ]; then\n  outStr+=\" --short $_arg_short\"\nfi\n\nif [ \"${#_arg_default_value[@]}\" -gt \"0\" ]; then\n\tif [ \"$_arg_repeat\" != \"off\" ]; then\n\t\tfor dfv in \"${_arg_default_value[@]}\"; do\n\t\t\toutStr+=\" --default-value \\\"$dfv\\\"\"\n\t\tdone\n\telse\n\t\toutStr+=\" --default-value \\\"${_arg_default_value[0]}\\\"\"\n\tfi\nfi\n\nif [ \"$_arg_repeat\" != \"off\" ] || [ \"$_arg_repeat_min\" != \"1\" ] || [ \"$_arg_repeat_max\" != \"\" ]; then\n  outStr+=\" --repeat\"\nfi\nif [ \"$_arg_repeat_min\" != \"1\" ]; then\n  outStr+=\" --repeat-min  $_arg_repeat_min\"\nfi\nif [ \"$_arg_repeat_max\" != \"\" ]; then\n  outStr+=\" --repeat-max  $_arg_repeat_max\"\nfi\n\nif [ \"${#_arg_alias[@]}\" -gt 0 ]; then\n\tfor ali in \"${_arg_alias[@]}\"; do\n \toutStr+=\" --alias $ali\"\n\tdone\nfi\n\nif [ \"${#_arg_complete[@]}\" != \"off\" ]; then\n\tfor _c in \"${_arg_complete[@]}\"; do\n\t\toutStr+=\" --complete \\\"$_c\\\"\";\n\tdone\nfi\n\nif [ \"${#_arg_complete_custom[@]}\" != \"off\" ]; then\n\tfor _c in \"${_arg_complete_custom[@]}\"; do\n\t\toutStr+=\" --complete-custom \\\"$_c\\\"\";\n\tdone\nfi\n\nif [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n\tfor _oof in \"${_arg_one_of[@]}\"; do\n\t\toutStr+=\" --one-of \\\"$_oof\\\"\";\n\tdone\nfi\n\necho \"$outStr\";\n",
  "/parseArger/bin/opt/help": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger help string for options\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt default-value \"value\" --short d --repeat\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt alias \"option alias\" --repeat\n# @parseArger opt empty-value \"value for empty option\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt env \"environment variable name\"\n# @parseArger opt match \"regex match validation\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag empty \"use option as flag\"\n# @parseArger flag required \"make option mandatory\" --short q\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/opt\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_default_value=()\n_arg_short=\n_arg_alias=()\n_arg_empty_value=\n_arg_complete=()\n_arg_complete_custom=()\n_arg_env=\n_arg_match=\n# FLAGS\n_arg_repeat=\"off\"\n_arg_empty=\"off\"\n_arg_required=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger help string for options:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t-d, --default-value <default-value>: value, repeatable\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--alias <alias>: option alias, repeatable\"\n\techo -e \"\t--empty-value <empty-value>: value for empty option\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--env <env>: environment variable name\"\n\techo -e \"\t--match <match>: regex match validation\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--empty|--no-empty: use option as flag\"\n\techo -e \"\t-q|--required|--no-required: make option mandatory\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--default-value <value>] [--short <value>] [--alias <value>] [--empty-value <value>] [--complete <value>] [--complete-custom <value>] [--env <value>] [--match <value>] [--[no-]repeat] [--[no-]empty] [--[no-]required]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-d|--default-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_default_value+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--default-value=*)\n\t\t\t\t_arg_default_value+=(\"${_key##--default-value=}\")\n\t\t\t\t;;\n\t\t\t-d*)\n\t\t\t\t_arg_default_value+=(\"${_key##-d}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--empty-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_empty_value=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--empty-value=*)\n\t\t\t\t_arg_empty_value=\"${_key##--empty-value=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--env)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_env=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--env=*)\n\t\t\t\t_arg_env=\"${_key##--env=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--match)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_match=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--match=*)\n\t\t\t\t_arg_match=\"${_key##--match=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--empty)\n\t\t\t\t_arg_empty=\"on\"\n\t\t\t\t;;\n\t\t\t--no-empty)\n\t\t\t\t_arg_empty=\"off\"\n\t\t\t\t;;\n\t\t\t-q|--required)\n\t\t\t\t_arg_required=\"on\"\n\t\t\t\t;;\n\t\t\t--no-required)\n\t\t\t\t_arg_required=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t--quiet)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\"\n\t\tlocal _regex=\"${!_match_var}\"\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\targ-name: ${_arg_arg_name}\";\n\techo -e \"\tdescription: ${_arg_description}\";\n\techo -e \"\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\tdefault-value: ${_arg_default_value[*]}\";\n\techo -e \"\tshort: ${_arg_short}\";\n\techo -e \"\talias: ${_arg_alias[*]}\";\n\techo -e \"\tempty-value: ${_arg_empty_value}\";\n\techo -e \"\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\tenv: ${_arg_env}\";\n\techo -e \"\tmatch: ${_arg_match}\";\n\techo -e \"\trepeat: ${_arg_repeat}\";\n\techo -e \"\tempty: ${_arg_empty}\";\n\techo -e \"\trequired: ${_arg_required}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\noptHelp=\"--${_arg_arg_name}\";\n\nif [[ \"${#_arg_alias[@]}\" -gt 0 ]]; then\n\tfor ali in \"${_arg_alias[@]}\"; do\n\t\toptHelp+=\"|--${ali}\"\n\tdone\nfi\n\noptHelp+=\" <${_arg_arg_name}>: ${_arg_description}\";\n\nif [ \"$_arg_short\" != \"\" ]; then\n  optHelp=\"-${_arg_short}, ${optHelp}\";\nfi\n\nif [ \"$_arg_repeat_min\" -gt \"1\" ] || [ \"$_arg_repeat_max\" != \"\" ]; then\n\t_arg_repeat=\"on\";\nfi\n\nif [ \"$_arg_repeat\" != \"off\" ]; then\n\toptHelp+=\", repeatable\";\nfi\n\nif [ \"$_arg_empty\" != \"off\" ] || [ \"$_arg_empty_value\" != \"\" ]; then\n\toptHelp+=\", can be empty\";\nfi\n\nif [ \"${#_arg_default_value[@]}\" -gt 0 ]; then\n\toptHelp+=\" [default: '\";\n\tif [ \"$_arg_repeat\" != \"off\" ]; then\n\t\toptHelp+=\"(\";\n\tfi\n\toptHelp+=\" ${_arg_default_value[*]} \";\n\tif [ \"$_arg_repeat\" != \"off\" ]; then\n\t\toptHelp+=\")\";\n\tfi\n\toptHelp+=\"']\";\nfi\n\nif [ \"$_arg_empty_value\" != \"\" ]; then\n\toptHelp+=\" [empty value: '${_arg_empty_value}']\";\nfi\n\nif [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n\toptHelp+=\" [one of\";\n\tfor _oof in \"${_arg_one_of[@]}\"; do\n\t\toptHelp+=\" '$_oof'\";\n\tdone\n\toptHelp+=\"]\";\nfi\n\nif [ \"$_arg_required\" == \"on\" ]; then\n\toptHelp+=\" (REQUIRED)\";\nfi\n\necho -e \"\\techo -e \\\"\\t${optHelp}\\\"\";\n",
  "/parseArger/bin/opt/more-completely": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger declaration string for options\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt default-value \"value\" --short d --repeat\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt alias \"option alias\" --repeat\n# @parseArger opt empty-value \"value for empty option\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt prefix \"completely prefix\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag empty \"use option as flag\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/opt\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_default_value=()\n_arg_short=\n_arg_alias=()\n_arg_empty_value=\n_arg_complete=()\n_arg_complete_custom=()\n_arg_prefix=\n# FLAGS\n_arg_repeat=\"off\"\n_arg_empty=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger declaration string for options:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t-d, --default-value <default-value>: value, repeatable\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--alias <alias>: option alias, repeatable\"\n\techo -e \"\t--empty-value <empty-value>: value for empty option\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--prefix <prefix>: completely prefix\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--empty|--no-empty: use option as flag\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--default-value <value>] [--short <value>] [--alias <value>] [--empty-value <value>] [--complete <value>] [--complete-custom <value>] [--prefix <value>] [--[no-]repeat] [--[no-]empty]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-d|--default-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_default_value+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--default-value=*)\n\t\t\t\t_arg_default_value+=(\"${_key##--default-value=}\")\n\t\t\t\t;;\n\t\t\t-d*)\n\t\t\t\t_arg_default_value+=(\"${_key##-d}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--empty-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_empty_value=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--empty-value=*)\n\t\t\t\t_arg_empty_value=\"${_key##--empty-value=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--prefix)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_prefix=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--prefix=*)\n\t\t\t\t_arg_prefix=\"${_key##--prefix=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--empty)\n\t\t\t\t_arg_empty=\"on\"\n\t\t\t\t;;\n\t\t\t--no-empty)\n\t\t\t\t_arg_empty=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tdefault-value: ${_arg_default_value[*]}\";\n\techo -e \"\\tshort: ${_arg_short}\";\n\techo -e \"\\talias: ${_arg_alias[*]}\";\n\techo -e \"\\tempty-value: ${_arg_empty_value}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\\tprefix: ${_arg_prefix}\";\n\techo -e \"\\trepeat: ${_arg_repeat}\";\n\techo -e \"\\tempty: ${_arg_empty}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\n\nif [ \"${#_arg_complete[@]}\" -gt 0 ] || [ \"${#_arg_complete_custom[@]}\" -gt 0 ]; then\n\techo \"${_arg_prefix}*--${_arg_arg_name}:\";\n\n\t_cpstr=\"\";\n\tif [ \"${#_arg_complete[@]}\" -gt 0 ]; then\n\t\tfor _cmpl in \"${_arg_complete[@]}\"; do\n\t\t\t_cpstr+=\"- <${_cmpl}>\\n\";\n\t\tdone\n\tfi\n\tif [ \"${#_arg_complete_custom[@]}\" -gt 0 ]; then\n\t\tfor _cmpl in \"${_arg_complete_custom[@]}\"; do\n\t\t\t_cpstr+=\"- \\$(${_cmpl})\\n\";\n\t\tdone\n\tfi\n\techo -e \"${_cpstr}\";\n\n\tif [ \"${#_arg_alias[@]}\" -gt 0 ]; then\n\t\tfor ali in \"${_arg_alias[@]}\"; do\n\t\t\techo \"${_arg_prefix}*--${ali}:\";\n\t\t\techo -e \"${_cpstr}\";\n\t\tdone\n\tfi\nfi\n",
  "/parseArger/bin/opt/html": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"option to html form\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt default-value \"value\" --short d --repeat\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt alias \"option alias\" --repeat\n# @parseArger opt empty-value \"value for empty option\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt input-container-class \"input container class\" --default-value \"form-group\"\n# @parseArger opt input-class \"input class\" --default-value \"form-control\"\n# @parseArger opt label-class \"label class\" --default-value \"form-label\"\n# @parseArger opt select-class \"select class\" --default-value \"form-select\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag empty \"use option as flag\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/opt\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_default_value=()\n_arg_short=\n_arg_alias=()\n_arg_empty_value=\n_arg_complete=()\n_arg_complete_custom=()\n_arg_input_container_class=\"form-group\"\n_arg_input_class=\"form-control\"\n_arg_label_class=\"form-label\"\n_arg_select_class=\"form-select\"\n# FLAGS\n_arg_repeat=\"off\"\n_arg_empty=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"option to html form:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t-d, --default-value <default-value>: value, repeatable\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--alias <alias>: option alias, repeatable\"\n\techo -e \"\t--empty-value <empty-value>: value for empty option\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--input-container-class <input-container-class>: input container class [default: ' form-group ']\"\n\techo -e \"\t--input-class <input-class>: input class [default: ' form-control ']\"\n\techo -e \"\t--label-class <label-class>: label class [default: ' form-label ']\"\n\techo -e \"\t--select-class <select-class>: select class [default: ' form-select ']\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--empty|--no-empty: use option as flag\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--default-value <value>] [--short <value>] [--alias <value>] [--empty-value <value>] [--complete <value>] [--complete-custom <value>] [--input-container-class <value>] [--input-class <value>] [--label-class <value>] [--select-class <value>] [--[no-]repeat] [--[no-]empty]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-d|--default-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_default_value+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--default-value=*)\n\t\t\t\t_arg_default_value+=(\"${_key##--default-value=}\")\n\t\t\t\t;;\n\t\t\t-d*)\n\t\t\t\t_arg_default_value+=(\"${_key##-d}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--empty-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_empty_value=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--empty-value=*)\n\t\t\t\t_arg_empty_value=\"${_key##--empty-value=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--input-container-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_input_container_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--input-container-class=*)\n\t\t\t\t_arg_input_container_class=\"${_key##--input-container-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--input-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_input_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--input-class=*)\n\t\t\t\t_arg_input_class=\"${_key##--input-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--label-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_label_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--label-class=*)\n\t\t\t\t_arg_label_class=\"${_key##--label-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--select-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_select_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--select-class=*)\n\t\t\t\t_arg_select_class=\"${_key##--select-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--empty)\n\t\t\t\t_arg_empty=\"on\"\n\t\t\t\t;;\n\t\t\t--no-empty)\n\t\t\t\t_arg_empty=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tdefault-value: ${_arg_default_value[*]}\";\n\techo -e \"\\tshort: ${_arg_short}\";\n\techo -e \"\\talias: ${_arg_alias[*]}\";\n\techo -e \"\\tempty-value: ${_arg_empty_value}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\\tinput-container-class: ${_arg_input_container_class}\";\n\techo -e \"\\tinput-class: ${_arg_input_class}\";\n\techo -e \"\\tlabel-class: ${_arg_label_class}\";\n\techo -e \"\\tselect-class: ${_arg_select_class}\";\n\techo -e \"\\trepeat: ${_arg_repeat}\";\n\techo -e \"\\tempty: ${_arg_empty}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nif [ \"$_arg_repeat_min\" -gt \"1\" ] || [ \"$_arg_repeat_max\" != \"\" ]; then\n\t_arg_repeat=\"on\";\nfi\n\ninptCmn=\"pa-type=\\\"opt\\\" name=\\\"${_arg_arg_name}\\\" id=\\\"${_arg_arg_name}\\\"\";\n\nif [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n\tinpuStr=\"<select class=\\\" class=\\\"${_arg_select_class}\\\"\\\" ${inptCmn}>\\n\";\n\tfor oof in \"${_arg_one_of[@]}\"; do\n\t\tinpuStr+=\"\\n\\t\\t<option value=\\\"${oof}\\\"\";\n\t\tif [ \"${#_arg_default_value[@]}\" -gt 0 ] && [ \"${_arg_default_value[0]}\" == \"$oof\" ]; then\n\t\t\tinpuStr+=\" selected\";\n\t\tfi\n\t\tinpuStr+=\">${oof}</option>\";\n\tdone\n\tinpuStr+=\"\\n\\t</select>\";\nelif [ \"${_arg_repeat}\" == \"on\" ]; then\n\tinpuStr=\"<textarea ${inptCmn} type=\\\"text\\\" pa-repeat class=\\\"${_arg_input_class}\\\">\";\n\tif [ \"${#_arg_default_value[@]}\" -gt 0 ]; then\n\t\tinpuStr+=\"${_arg_default_value[0]}\";\n\tfi\n\tinpuStr+=\"</textarea>\";\nelse\n\tinpuStr=\"<input class=\\\"${_arg_input_class}\\\" ${inptCmn} type=\\\"text\\\"\";\n\tif [ \"${#_arg_default_value[@]}\" -gt 0 ]; then\n\t\tinpuStr+=\" value=\\\"${_arg_default_value[0]}\\\"\";\n\tfi\n\tinpuStr+=\" />\";\nfi\n\necho -e \"<div class=\\\"${_arg_input_container_class}\\\">\n\t<label for=\\\"${_arg_arg_name}\\\" class=\\\"${_arg_label_class}\\\">${_arg_arg_name}</label>\n\t<span class=\\\"input-help\\\">${_arg_description}</span>\n\t${inpuStr}\n</div>\";\n",
  "/parseArger/bin/opt/completely": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger declaration string for options\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt default-value \"value\" --short d --repeat\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt alias \"option alias\" --repeat\n# @parseArger opt empty-value \"value for empty option\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag empty \"use option as flag\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/opt\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_default_value=()\n_arg_short=\n_arg_alias=()\n_arg_empty_value=\n_arg_complete=()\n_arg_complete_custom=()\n# FLAGS\n_arg_repeat=\"off\"\n_arg_empty=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger declaration string for options:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t-d, --default-value <default-value>: value, repeatable\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--alias <alias>: option alias, repeatable\"\n\techo -e \"\t--empty-value <empty-value>: value for empty option\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--empty|--no-empty: use option as flag\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--default-value <value>] [--short <value>] [--alias <value>] [--empty-value <value>] [--complete <value>] [--complete-custom <value>] [--[no-]repeat] [--[no-]empty]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-d|--default-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_default_value+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--default-value=*)\n\t\t\t\t_arg_default_value+=(\"${_key##--default-value=}\")\n\t\t\t\t;;\n\t\t\t-d*)\n\t\t\t\t_arg_default_value+=(\"${_key##-d}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--empty-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_empty_value=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--empty-value=*)\n\t\t\t\t_arg_empty_value=\"${_key##--empty-value=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--empty)\n\t\t\t\t_arg_empty=\"on\"\n\t\t\t\t;;\n\t\t\t--no-empty)\n\t\t\t\t_arg_empty=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tdefault-value: ${_arg_default_value[*]}\";\n\techo -e \"\\tshort: ${_arg_short}\";\n\techo -e \"\\talias: ${_arg_alias[*]}\";\n\techo -e \"\\tempty-value: ${_arg_empty_value}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\\trepeat: ${_arg_repeat}\";\n\techo -e \"\\tempty: ${_arg_empty}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\n\necho \"- --${_arg_arg_name}\";\n\nfor ali in \"${_arg_alias[@]}\"; do\n\techo \"- --${ali}\";\ndone\n\nif [ \"$_arg_short\" != \"\" ]; then\n\techo \"- -${_arg_short}\";\nfi\n",
  "/parseArger/bin/opt/init": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger init string for options\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n# @parseArger-leftovers leftovers --parse\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt default-value \"value\" --short d --repeat\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt alias \"option alias\" --repeat\n# @parseArger opt empty-value \"value for empty option\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt env \"environment variable name\"\n# @parseArger opt match \"regex match validation\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag empty \"use option as flag\"\n# @parseArger flag required \"make option mandatory\" --short q\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/opt\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_default_value=()\n_arg_short=\n_arg_alias=()\n_arg_empty_value=\n_arg_complete=()\n_arg_complete_custom=()\n_arg_env=\n_arg_match=\n# FLAGS\n_arg_repeat=\"off\"\n_arg_empty=\"off\"\n_arg_required=\"off\"\n# NESTED\n# LEFTOVERS\n_arg_leftovers=()\n# LEFTOVERS\n\tdeclare -A _arg_parsed_leftovers\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger init string for options:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t-d, --default-value <default-value>: value, repeatable\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--alias <alias>: option alias, repeatable\"\n\techo -e \"\t--empty-value <empty-value>: value for empty option\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--env <env>: environment variable name\"\n\techo -e \"\t--match <match>: regex match validation\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--empty|--no-empty: use option as flag\"\n\techo -e \"\t-q|--required|--no-required: make option mandatory\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--default-value <value>] [--short <value>] [--alias <value>] [--empty-value <value>] [--complete <value>] [--complete-custom <value>] [--env <value>] [--match <value>] [--[no-]repeat] [--[no-]empty] [--[no-]required]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-d|--default-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_default_value+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--default-value=*)\n\t\t\t\t_arg_default_value+=(\"${_key##--default-value=}\")\n\t\t\t\t;;\n\t\t\t-d*)\n\t\t\t\t_arg_default_value+=(\"${_key##-d}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--empty-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_empty_value=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--empty-value=*)\n\t\t\t\t_arg_empty_value=\"${_key##--empty-value=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--env)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_env=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--env=*)\n\t\t\t\t_arg_env=\"${_key##--env=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--match)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_match=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--match=*)\n\t\t\t\t_arg_match=\"${_key##--match=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--empty)\n\t\t\t\t_arg_empty=\"on\"\n\t\t\t\t;;\n\t\t\t--no-empty)\n\t\t\t\t_arg_empty=\"off\"\n\t\t\t\t;;\n\t\t\t-q|--required)\n\t\t\t\t_arg_required=\"on\"\n\t\t\t\t;;\n\t\t\t--no-required)\n\t\t\t\t_arg_required=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t--quiet)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t# parsing leftovers\n\t\t\t--*)\n\t\t\t\tif [[ \"$2\" =~ ^--([^=]+)(=(.*))?$ ]] || [ \"$2\" = \"\" ]; then\n\t\t\t\t\t_arg_parsed_leftovers[\"${1#--}\"]=\"on\"\n\t\t\t\telif [[ \"$1\" =~ ^--([^=]+)=(.*)$ ]]; then\n\t\t\t\t\t_arg_parsed_leftovers[\"${BASH_REMATCH[1]}\"]=\"${BASH_REMATCH[2]}\";\n\t\t\t\telse\n\t\t\t\t\t_arg_parsed_leftovers[\"${1#--}\"]=\"${2}\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\t_leftovers_count=$((${#_positionals[@]} - 2))\n\tfor ((ii = 0; ii < _leftovers_count; ii++));do\n\t\t_positional_names=\"$_positional_names _arg_leftovers[$((ii + 0))]\";\n\tdone\n\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\tif ! [[ \"$_positional_name\" =~ \"_arg_leftovers\" ]];then\n\t\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\t\teval \"local _regex=\\$(eval \\\"echo \\\\\\\"\\\\\\$_match\\${_positional_name}\\\\\\\"\\\");if [ \\\"\\$_regex\\\" != \\\"\\\" ];then [[ \\\"\\${1}\\\" =~ \\$_regex ]] || die \\\\\\\"\\\\\\${_positional_name} does not match pattern: \\$_regex\\\\\\\";fi\";\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\targ-name: ${_arg_arg_name}\";\n\techo -e \"\tdescription: ${_arg_description}\";\n\techo -e \"\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\tdefault-value: ${_arg_default_value[*]}\";\n\techo -e \"\tshort: ${_arg_short}\";\n\techo -e \"\talias: ${_arg_alias[*]}\";\n\techo -e \"\tempty-value: ${_arg_empty_value}\";\n\techo -e \"\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\tenv: ${_arg_env}\";\n\techo -e \"\tmatch: ${_arg_match}\";\n\techo -e \"\trepeat: ${_arg_repeat}\";\n\techo -e \"\tempty: ${_arg_empty}\";\n\techo -e \"\trequired: ${_arg_required}\";\n\techo -e \"\tleftovers: ${_arg_leftovers[*]}\";\n\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\n_arg_arg_name=\"${_arg_arg_name//-/_}\"\noutStr=\"_arg_${_arg_arg_name}=\";\n\n# Handle --env\ndefault_val_str=\"\"\nif [ \"${#_arg_default_value[@]}\" -gt 0 ]; then\n    if [ \"$_arg_repeat\" == \"off\" ]; then\n        default_val_str=\"${_arg_default_value[*]}\";\n    else\n        # For arrays with default values, we just init the array.\n        # Env vars for arrays are tricky, let's skip env for arrays for now or handle simple cases.\n        # If env is set, we might want to split it? Too complex for now.\n        :\n    fi\nfi\n\nif [ \"$_arg_env\" != \"\" ] && [ \"$_arg_repeat\" == \"off\" ]; then\n    # if env var is set, use it, else use default\n    if [ \"$default_val_str\" != \"\" ]; then\n        outStr+=\"\\\"\\${${_arg_env}:-$default_val_str}\\\"\";\n    else\n        outStr+=\"\\\"\\${${_arg_env}}\\\"\";\n    fi\nelse\n    # Existing logic\n    if [ \"$_arg_repeat\" != \"off\" ]; then\n        outStr+=\"(\";\n    fi\n\n    if [ \"${#_arg_default_value[@]}\" -gt 0 ]; then\n        if [ \"$_arg_repeat\" == \"off\" ]; then\n            outStr+=\"\\\"${_arg_default_value[*]}\\\"\";\n        else\n            for idfv in \"${_arg_default_value[@]}\"; do\n                outStr+=\"\\\"$idfv\\\" \";\n            done\n        fi\n    fi\n\n    if [ \"$_arg_repeat\" != \"off\" ]; then\n        outStr+=\")\";\n    fi\nfi\n\nif [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n    outStr+=\"\\n_one_of_arg_${_arg_arg_name//-/_}=(\";\n    for i in \"${_arg_one_of[@]}\"; do\n        outStr+=\"\\\"$i\\\" \";\n    done\n    outStr+=\");\";\nfi\n\nif [ \"$_arg_required\" == \"on\" ]; then\n    outStr+=\"\\n_required_arg_${_arg_arg_name//-/_}=\\\"on\\\";\";\nfi\n\necho -e \"$outStr\";",
  "/parseArger/bin/opt/parser": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger parsing string for options\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt default-value \"value\" --short d --repeat\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt alias \"option alias\" --repeat\n# @parseArger opt empty-value \"value for empty option\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt env \"environment variable name\"\n# @parseArger opt match \"regex match validation\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag empty \"use option as flag\"\n# @parseArger flag required \"make option mandatory\" --short q\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/opt\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_default_value=()\n_arg_short=\n_arg_alias=()\n_arg_empty_value=\n_arg_complete=()\n_arg_complete_custom=()\n_arg_env=\n_arg_match=\n# FLAGS\n_arg_repeat=\"off\"\n_arg_empty=\"off\"\n_arg_required=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger parsing string for options:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t-d, --default-value <default-value>: value, repeatable\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--alias <alias>: option alias, repeatable\"\n\techo -e \"\t--empty-value <empty-value>: value for empty option\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--env <env>: environment variable name\"\n\techo -e \"\t--match <match>: regex match validation\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--empty|--no-empty: use option as flag\"\n\techo -e \"\t-q|--required|--no-required: make option mandatory\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--default-value <value>] [--short <value>] [--alias <value>] [--empty-value <value>] [--complete <value>] [--complete-custom <value>] [--env <value>] [--match <value>] [--[no-]repeat] [--[no-]empty] [--[no-]required]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-d|--default-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_default_value+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--default-value=*)\n\t\t\t\t_arg_default_value+=(\"${_key##--default-value=}\")\n\t\t\t\t;;\n\t\t\t-d*)\n\t\t\t\t_arg_default_value+=(\"${_key##-d}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--empty-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_empty_value=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--empty-value=*)\n\t\t\t\t_arg_empty_value=\"${_key##--empty-value=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--env)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_env=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--env=*)\n\t\t\t\t_arg_env=\"${_key##--env=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--match)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_match=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--match=*)\n\t\t\t\t_arg_match=\"${_key##--match=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--empty)\n\t\t\t\t_arg_empty=\"on\"\n\t\t\t\t;;\n\t\t\t--no-empty)\n\t\t\t\t_arg_empty=\"off\"\n\t\t\t\t;;\n\t\t\t-q|--required)\n\t\t\t\t_arg_required=\"on\"\n\t\t\t\t;;\n\t\t\t--no-required)\n\t\t\t\t_arg_required=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t--quiet)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\targ-name: ${_arg_arg_name}\";\n\techo -e \"\tdescription: ${_arg_description}\";\n\techo -e \"\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\tdefault-value: ${_arg_default_value[*]}\";\n\techo -e \"\tshort: ${_arg_short}\";\n\techo -e \"\talias: ${_arg_alias[*]}\";\n\techo -e \"\tempty-value: ${_arg_empty_value}\";\n\techo -e \"\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\tenv: ${_arg_env}\";\n\techo -e \"\tmatch: ${_arg_match}\";\n\techo -e \"\trepeat: ${_arg_repeat}\";\n\techo -e \"\tempty: ${_arg_empty}\";\n\techo -e \"\trequired: ${_arg_required}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\noptMissingValueError=\"Missing value for the option: \"\noptParser=\"--${_arg_arg_name})\";\n\nif [[ \"${#_arg_alias[@]}\" -gt 0 ]]; then\n\tfor ali in \"${_arg_alias[@]}\"; do\n\t\toptParser=\"--${ali}|${optParser}\"\n\tdone\nfi\n\nif [ \"$_arg_short\" != \"\" ]; then\n  optParser=\"-${_arg_short}|${optParser}\";\nfi\n\noptParser=\"${optParser}\\n\\t\";\n\nsetOptStr=\"_arg_${_arg_arg_name//-/_}\";\nif [ \"$_arg_repeat\" == \"on\" ]; then\n\tsetOptStr=\"${setOptStr}+=(\\\"\\$2\\\")\";\nelse\n\tsetOptStr=\"${setOptStr}=\\\"\\$2\\\"\";\nfi\n\nif [ \"$_arg_match\" != \"\" ]; then\n    setOptStr=\"local _regex='${_arg_match}';if [[ -n \\\"\\$_regex\\\" ]] && [[ ! \\\"\\$2\\\" =~ \\$_regex ]]; then die \\\"${_arg_arg_name} does not match pattern: \\$_regex\\\"; fi; ${setOptStr}\"\nfi\n\nif [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n\tsetOptStr+=\"\\n\\tif [[ \\\"\\${#_one_of_arg_${_arg_arg_name//-/_}[@]}\\\" -gt 0 ]];then [[ \\\"\\${_one_of_arg_${_arg_arg_name//-/_}[*]}\\\" =~ (^|[[:space:]])\\\"\\$_arg_${_arg_arg_name//-/_}\\\"(\\$|[[:space:]]) ]] || die \\\"$_arg_arg_name must be one of: ${_arg_one_of[*]}\\\";fi\";\nfi\n\nif [ \"$_arg_empty\" == \"on\" ] || [ \"$_arg_empty_value\" != \"\" ]; then\n  if [ \"$_arg_empty_value\" == \"\" ]; then\n    _arg_empty_value=\"on\"\n  fi\n\t# TODO: not working if not last element of command\n  optParser=\"${optParser}if [ \\$# -lt 2 ];then\n\t\t_arg_${_arg_arg_name//-/_}=\\\"${_arg_empty_value}\\\";\n\telse\n\t\t${setOptStr};\n\tfi\n\t;;\n\";\nelse\n  optParser=\"${optParser}test \\$# -lt 2 && die \\\"${optMissingValueError}'\\$_key'\\\" 1\n\t${setOptStr}\n\tshift\n\t;;\n\";\nfi\n\nif [ \"$_arg_repeat_min\" -gt \"1\" ] || [ \"$_arg_repeat_max\" != \"\" ]; then\n\t_arg_repeat=\"on\";\nfi\n\nif [ \"$_arg_repeat\" == \"on\" ]; then\n\tsetvalstr=\"+=(\\\"\\${_key##--${_arg_arg_name}=}\\\")\"\nelse\n\tsetvalstr=\"=\\\"\\${_key##--${_arg_arg_name}=}\\\"\"\nfi\noptParser=\"${optParser}--${_arg_arg_name}=*)\"\nif [ \"$_arg_match\" != \"\" ]; then\n    optParser+=\"\n    local _regex='${_arg_match}';if [[ -n \\\"\\$_regex\\\" ]] && [[ ! \\\"\\${_key##--${_arg_arg_name}=}\\\" =~ \\$_regex ]]; then die \\\"${_arg_arg_name} does not match pattern: \\$_regex\\\"; fi;\"\nfi\noptParser+=\"\n\t_arg_${_arg_arg_name//-/_}${setvalstr}\";\n\nif [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n\toptParser+=\"\n\tif [[ \\\"\\${#_one_of_arg_${_arg_arg_name//-/_}[@]}\\\" -gt 0 ]];then [[ \\\"\\${_one_of_arg_${_arg_arg_name//-/_}[*]}\\\" =~ (^|[[:space:]])\\\"\\$_arg_${_arg_arg_name//-/_}\\\"(\\$|[[:space:]]) ]] || die \\\"$_arg_arg_name must be one of: ${_arg_one_of[*]}\\\";fi\";\nfi\n\noptParser+=\"\n\t;;\n\";\n\nif [[ \"${#_arg_alias[@]}\" -gt 0 ]]; then\n\tfor ali in \"${_arg_alias[@]}\"; do\n\t\tif [ \"$_arg_repeat\" == \"on\" ]; then\n\t\t\tsetvalstr=\"+=(\\\"\\${_key##--${ali}=}\\\")\"\n\t\telse\n\t\t\tsetvalstr=\"=\\\"\\${_key##--${ali}=}\\\"\"\n\t\tfi\n\t\toptParser=\"${optParser}--${ali}=*)\"\n        if [ \"$_arg_match\" != \"\" ]; then\n            optParser+=\"\n            local _regex='${_arg_match}';if [[ -n \\\"\\$_regex\\\" ]] && [[ ! \\\"\\${_key##--${ali}=}\\\" =~ \\$_regex ]]; then die \\\"${_arg_arg_name} does not match pattern: \\$_regex\\\"; fi;\"\n        fi\n        optParser+=\"\n\t_arg_${_arg_arg_name//-/_}${setvalstr}\";\n\n\t\tif [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n\t\t\toptParser+=\"\n\tif [[ \\\"\\${#_one_of_arg_${_arg_arg_name//-/_}[@]}\\\" -gt 0 ]];then [[ \\\"\\${_one_of_arg_${_arg_arg_name//-/_}[*]}\\\" =~ (^|[[:space:]])\\\"\\$_arg_${_arg_arg_name//-/_}\\\"(\\$|[[:space:]]) ]] || die \\\"$_arg_arg_name must be one of: ${_arg_one_of[*]}\\\";fi\";\n\t\tfi\n\n\t\toptParser+=\"\n\t;;\n\";\n\tdone\nfi\n\nif [ \"$_arg_short\" != \"\" ]; then\n\tif [ \"$_arg_repeat\" == \"on\" ]; then\n\t\tsetvalsstr=\"+=(\\\"\\${_key##-${_arg_short}}\\\")\"\n\telse\n\t\tsetvalsstr=\"=\\\"\\${_key##-${_arg_short}}\\\"\"\n\tfi\n  optParser=\"${optParser}-${_arg_short}*)\"\n  if [ \"$_arg_match\" != \"\" ]; then\n      optParser+=\"\n      local _regex='${_arg_match}';if [[ -n \\\"\\$_regex\\\" ]] && [[ ! \\\"\\${_key##-${_arg_short}}\\\" =~ \\$_regex ]]; then die \\\"${_arg_arg_name} does not match pattern: \\$_regex\\\"; fi;\"\n  fi\n  optParser+=\"\n\t_arg_${_arg_arg_name//-/_}${setvalsstr}\";\nif [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n\toptParser+=\"\n\tif [[ \\\"\\${#_one_of_arg_${_arg_arg_name//-/_}[@]}\\\" -gt 0 ]];then [[ \\\"\\${_one_of_arg_${_arg_arg_name//-/_}[*]}\\\" =~ (^|[[:space:]])\\\"\\$_arg_${_arg_arg_name//-/_}\\\"(\\$|[[:space:]]) ]] || die \\\"$_arg_arg_name must be one of: ${_arg_one_of[*]}\\\";fi\";\nfi\n\noptParser+=\"\n\t;;\n\";\nfi\n\necho -e \"${optParser}\";\n",
  "/parseArger/bin/opt/is-repeating": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"is the option repeating\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt default-value \"value\" --short d --repeat\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt alias \"option alias\" --repeat\n# @parseArger opt empty-value \"value for empty option\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt env \"environment variable name\"\n# @parseArger opt match \"regex match validation\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag empty \"use option as flag\"\n# @parseArger flag required \"make option mandatory\" --short q\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/opt\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_default_value=()\n_arg_short=\n_arg_alias=()\n_arg_empty_value=\n_arg_complete=()\n_arg_complete_custom=()\n_arg_env=\n_arg_match=\n# FLAGS\n_arg_repeat=\"off\"\n_arg_empty=\"off\"\n_arg_required=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"is the option repeating:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t-d, --default-value <default-value>: value, repeatable\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--alias <alias>: option alias, repeatable\"\n\techo -e \"\t--empty-value <empty-value>: value for empty option\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--env <env>: environment variable name\"\n\techo -e \"\t--match <match>: regex match validation\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--empty|--no-empty: use option as flag\"\n\techo -e \"\t-q|--required|--no-required: make option mandatory\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--default-value <value>] [--short <value>] [--alias <value>] [--empty-value <value>] [--complete <value>] [--complete-custom <value>] [--env <value>] [--match <value>] [--[no-]repeat] [--[no-]empty] [--[no-]required]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-d|--default-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_default_value+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--default-value=*)\n\t\t\t\t_arg_default_value+=(\"${_key##--default-value=}\")\n\t\t\t\t;;\n\t\t\t-d*)\n\t\t\t\t_arg_default_value+=(\"${_key##-d}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--empty-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_empty_value=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--empty-value=*)\n\t\t\t\t_arg_empty_value=\"${_key##--empty-value=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--env)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_env=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--env=*)\n\t\t\t\t_arg_env=\"${_key##--env=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--match)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_match=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--match=*)\n\t\t\t\t_arg_match=\"${_key##--match=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--empty)\n\t\t\t\t_arg_empty=\"on\"\n\t\t\t\t;;\n\t\t\t--no-empty)\n\t\t\t\t_arg_empty=\"off\"\n\t\t\t\t;;\n\t\t\t-q|--required)\n\t\t\t\t_arg_required=\"on\"\n\t\t\t\t;;\n\t\t\t--no-required)\n\t\t\t\t_arg_required=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t--quiet)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\"\n\t\tlocal _regex=\"${!_match_var}\"\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\targ-name: ${_arg_arg_name}\";\n\techo -e \"\tdescription: ${_arg_description}\";\n\techo -e \"\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\tdefault-value: ${_arg_default_value[*]}\";\n\techo -e \"\tshort: ${_arg_short}\";\n\techo -e \"\talias: ${_arg_alias[*]}\";\n\techo -e \"\tempty-value: ${_arg_empty_value}\";\n\techo -e \"\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\tenv: ${_arg_env}\";\n\techo -e \"\tmatch: ${_arg_match}\";\n\techo -e \"\trepeat: ${_arg_repeat}\";\n\techo -e \"\tempty: ${_arg_empty}\";\n\techo -e \"\trequired: ${_arg_required}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nif [ \"$_arg_repeat_min\" -gt \"1\" ] || [ \"$_arg_repeat_max\" != \"\" ]; then\n\t_arg_repeat=\"on\";\nfi\n\nif [ \"$_arg_repeat\" != \"off\" ]; then\n  echo \"0\";\n\texit 0;\nfi\n\necho \"1\";\nexit 1;\n",
  "/parseArger/bin/opt/check-required": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"check if option is required\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt default-value \"value\" --short d --repeat\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt alias \"option alias\" --repeat\n# @parseArger opt empty-value \"value for empty option\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt env \"environment variable name\"\n# @parseArger opt match \"regex match validation\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag empty \"use option as flag\"\n# @parseArger flag required \"make option mandatory\" --short q\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/opt\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_default_value=()\n_arg_short=\n_arg_alias=()\n_arg_empty_value=\n_arg_complete=()\n_arg_complete_custom=()\n_arg_env=\n_arg_match=\n# FLAGS\n_arg_repeat=\"off\"\n_arg_empty=\"off\"\n_arg_required=\"off\"\n# NESTED\n# LEFTOVERS\n_arg_leftovers=()\n# LEFTOVERS\n\tdeclare -A _arg_parsed_leftovers\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"check if option is required:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t-d, --default-value <default-value>: value, repeatable\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--alias <alias>: option alias, repeatable\"\n\techo -e \"\t--empty-value <empty-value>: value for empty option\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--env <env>: environment variable name\"\n\techo -e \"\t--match <match>: regex match validation\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--empty|--no-empty: use option as flag\"\n\techo -e \"\t-q|--required|--no-required: make option mandatory\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--default-value <value>] [--short <value>] [--alias <value>] [--empty-value <value>] [--complete <value>] [--complete-custom <value>] [--env <value>] [--match <value>] [--[no-]repeat] [--[no-]empty] [--[no-]required]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-d|--default-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_default_value+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--default-value=*)\n\t\t\t\t_arg_default_value+=(\"${_key##--default-value=}\")\n\t\t\t\t;;\n\t\t\t-d*)\n\t\t\t\t_arg_default_value+=(\"${_key##-d}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--empty-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_empty_value=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--empty-value=*)\n\t\t\t\t_arg_empty_value=\"${_key##--empty-value=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--env)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_env=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--env=*)\n\t\t\t\t_arg_env=\"${_key##--env=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--match)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_match=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--match=*)\n\t\t\t\t_arg_match=\"${_key##--match=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--empty)\n\t\t\t\t_arg_empty=\"on\"\n\t\t\t\t;;\n\t\t\t--no-empty)\n\t\t\t\t_arg_empty=\"off\"\n\t\t\t\t;;\n\t\t\t-q|--required)\n\t\t\t\t_arg_required=\"on\"\n\t\t\t\t;;\n\t\t\t--no-required)\n\t\t\t\t_arg_required=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\t_leftovers_count=$((${#_positionals[@]} - 2))\n\tfor ((ii = 0; ii < _leftovers_count; ii++));do\n\t\t_positional_names=\"$_positional_names _arg_leftovers[$((ii + 0))]\";\n\tdone\n\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\tif ! [[ \"$_positional_name\" =~ \"_arg_leftovers\" ]];then\n\t\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\t\tlocal _match_var=\"_match${_positional_name}\";\n\t\t\tlocal _regex=\"${!_match_var}\";\n\t\t\tif [ -n \"$_regex\" ]; then\n\t\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\t\tfi\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\targ-name: ${_arg_arg_name}\";\n\techo -e \"\tdescription: ${_arg_description}\";\n\techo -e \"\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\tdefault-value: ${_arg_default_value[*]}\";\n\techo -e \"\tshort: ${_arg_short}\";\n\techo -e \"\talias: ${_arg_alias[*]}\";\n\techo -e \"\tempty-value: ${_arg_empty_value}\";\n\techo -e \"\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\tenv: ${_arg_env}\";\n\techo -e \"\tmatch: ${_arg_match}\";\n\techo -e \"\trepeat: ${_arg_repeat}\";\n\techo -e \"\tempty: ${_arg_empty}\";\n\techo -e \"\trequired: ${_arg_required}\";\n\techo -e \"\tleftovers: ${_arg_leftovers[*]}\";\n\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nif [ \"$_arg_required\" == \"on\" ]; then\n    if [[ ! \"$_arg_arg_name\" =~ ^[a-zA-Z_][a-zA-Z0-9_-]*$ ]]; then\n        die \"Invalid argument name: $_arg_arg_name\"\n    fi\n    echo \"if [ -z \\\"\\$_arg_${_arg_arg_name//-/_}\\\" ]; then die \\\"Missing required option: ${_arg_arg_name}\\\"; fi;\"\nfi\n",
  "/parseArger/bin/opt/docopt-help": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger docOpt string for option\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt default-value \"value\" --short d --repeat\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt alias \"option alias\" --repeat\n# @parseArger opt empty-value \"value for empty option\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag empty \"use option as flag\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/opt\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_default_value=()\n_arg_short=\n_arg_alias=()\n_arg_empty_value=\n_arg_complete=()\n_arg_complete_custom=()\n# FLAGS\n_arg_repeat=\"off\"\n_arg_empty=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger docOpt string for option:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t-d, --default-value <default-value>: value, repeatable\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--alias <alias>: option alias, repeatable\"\n\techo -e \"\t--empty-value <empty-value>: value for empty option\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--empty|--no-empty: use option as flag\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--default-value <value>] [--short <value>] [--alias <value>] [--empty-value <value>] [--complete <value>] [--complete-custom <value>] [--[no-]repeat] [--[no-]empty]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-d|--default-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_default_value+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--default-value=*)\n\t\t\t\t_arg_default_value+=(\"${_key##--default-value=}\")\n\t\t\t\t;;\n\t\t\t-d*)\n\t\t\t\t_arg_default_value+=(\"${_key##-d}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--empty-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_empty_value=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--empty-value=*)\n\t\t\t\t_arg_empty_value=\"${_key##--empty-value=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--empty)\n\t\t\t\t_arg_empty=\"on\"\n\t\t\t\t;;\n\t\t\t--no-empty)\n\t\t\t\t_arg_empty=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\\tdefault-value: ${_arg_default_value[*]}\";\n\techo -e \"\\tshort: ${_arg_short}\";\n\techo -e \"\\talias: ${_arg_alias[*]}\";\n\techo -e \"\\tempty-value: ${_arg_empty_value}\";\n\techo -e \"\\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\\trepeat: ${_arg_repeat}\";\n\techo -e \"\\tempty: ${_arg_empty}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\noptHelp=\"--${_arg_arg_name} ${_arg_arg_name}\";\n\nif [ \"$_arg_short\" != \"\" ]; then\n  optHelp=\"-${_arg_short} ${_arg_arg_name}, ${optHelp}\";\nfi\n\noptHelp=\"${optHelp}\\t${_arg_description}\";\n\nif [ \"${#_arg_default_value[@]}\" -gt 0 ]; then\n\toptHelp=\"${optHelp} [default: ${_arg_default_value[*]}]\";\nfi\n\necho -e \"${optHelp}\";\n",
  "/parseArger/bin/opt/declaration": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger declaration string for options\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt repeat-min \"minimum repeatition forces repeat\" --default-value \"1\"\n# @parseArger opt repeat-max \"maximum repeatition forces repeat\"\n# @parseArger opt one-of \"accepted values\" --repeat\n# @parseArger opt default-value \"value\" --short d --repeat\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt alias \"option alias\" --repeat\n# @parseArger opt empty-value \"value for empty option\"\n# @parseArger opt complete \"bash built-in completely function\" --repeat\n# @parseArger opt complete-custom \"completely custom dynamic suggestion\" --repeat\n# @parseArger opt env \"environment variable name\"\n# @parseArger opt match \"regex match validation\"\n# @parseArger flag repeat \"repeatable\" --short r\n# @parseArger flag empty \"use option as flag\"\n# @parseArger flag required \"make option mandatory\" --short q\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/opt\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_repeat_min=\"1\"\n_arg_repeat_max=\n_arg_one_of=()\n_arg_default_value=()\n_arg_short=\n_arg_alias=()\n_arg_empty_value=\n_arg_complete=()\n_arg_complete_custom=()\n_arg_env=\n_arg_match=\n# FLAGS\n_arg_repeat=\"off\"\n_arg_empty=\"off\"\n_arg_required=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger declaration string for options:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t--repeat-min <repeat-min>: minimum repeatition forces repeat [default: ' 1 ']\"\n\techo -e \"\t--repeat-max <repeat-max>: maximum repeatition forces repeat\"\n\techo -e \"\t--one-of <one-of>: accepted values, repeatable\"\n\techo -e \"\t-d, --default-value <default-value>: value, repeatable\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--alias <alias>: option alias, repeatable\"\n\techo -e \"\t--empty-value <empty-value>: value for empty option\"\n\techo -e \"\t--complete <complete>: bash built-in completely function, repeatable\"\n\techo -e \"\t--complete-custom <complete-custom>: completely custom dynamic suggestion, repeatable\"\n\techo -e \"\t--env <env>: environment variable name\"\n\techo -e \"\t--match <match>: regex match validation\"\n\techo -e \"\t-r|--repeat|--no-repeat: repeatable\"\n\techo -e \"\t--empty|--no-empty: use option as flag\"\n\techo -e \"\t-q|--required|--no-required: make option mandatory\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--repeat-min <value>] [--repeat-max <value>] [--one-of <value>] [--default-value <value>] [--short <value>] [--alias <value>] [--empty-value <value>] [--complete <value>] [--complete-custom <value>] [--env <value>] [--match <value>] [--[no-]repeat] [--[no-]empty] [--[no-]required]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--repeat-min)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_min=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-min=*)\n\t\t\t\t_arg_repeat_min=\"${_key##--repeat-min=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repeat-max)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repeat_max=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repeat-max=*)\n\t\t\t\t_arg_repeat_max=\"${_key##--repeat-max=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--one-of)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_one_of+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--one-of=*)\n\t\t\t\t_arg_one_of+=(\"${_key##--one-of=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-d|--default-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_default_value+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--default-value=*)\n\t\t\t\t_arg_default_value+=(\"${_key##--default-value=}\")\n\t\t\t\t;;\n\t\t\t-d*)\n\t\t\t\t_arg_default_value+=(\"${_key##-d}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--empty-value)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_empty_value=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--empty-value=*)\n\t\t\t\t_arg_empty_value=\"${_key##--empty-value=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete=*)\n\t\t\t\t_arg_complete+=(\"${_key##--complete=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--complete-custom)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_complete_custom+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--complete-custom=*)\n\t\t\t\t_arg_complete_custom+=(\"${_key##--complete-custom=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--env)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_env=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--env=*)\n\t\t\t\t_arg_env=\"${_key##--env=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--match)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_match=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--match=*)\n\t\t\t\t_arg_match=\"${_key##--match=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-r|--repeat)\n\t\t\t\t_arg_repeat=\"on\"\n\t\t\t\t;;\n\t\t\t--no-repeat)\n\t\t\t\t_arg_repeat=\"off\"\n\t\t\t\t;;\n\t\t\t--empty)\n\t\t\t\t_arg_empty=\"on\"\n\t\t\t\t;;\n\t\t\t--no-empty)\n\t\t\t\t_arg_empty=\"off\"\n\t\t\t\t;;\n\t\t\t-q|--required)\n\t\t\t\t_arg_required=\"on\"\n\t\t\t\t;;\n\t\t\t--no-required)\n\t\t\t\t_arg_required=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\"\n\t\tlocal _regex=\"${!_match_var}\"\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\targ-name: ${_arg_arg_name}\";\n\techo -e \"\tdescription: ${_arg_description}\";\n\techo -e \"\trepeat-min: ${_arg_repeat_min}\";\n\techo -e \"\trepeat-max: ${_arg_repeat_max}\";\n\techo -e \"\tone-of: ${_arg_one_of[*]}\";\n\techo -e \"\tdefault-value: ${_arg_default_value[*]}\";\n\techo -e \"\tshort: ${_arg_short}\";\n\techo -e \"\talias: ${_arg_alias[*]}\";\n\techo -e \"\tempty-value: ${_arg_empty_value}\";\n\techo -e \"\tcomplete: ${_arg_complete[*]}\";\n\techo -e \"\tcomplete-custom: ${_arg_complete_custom[*]}\";\n\techo -e \"\tenv: ${_arg_env}\";\n\techo -e \"\tmatch: ${_arg_match}\";\n\techo -e \"\trepeat: ${_arg_repeat}\";\n\techo -e \"\tempty: ${_arg_empty}\";\n\techo -e \"\trequired: ${_arg_required}\";\n\n}\n\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\noutStr=\"# @parse\"\noutStr+=\"Arger opt $_arg_arg_name \\\"${_arg_description}\\\"\"\n\nif [ \"$_arg_short\" != \"\" ]; then\n  outStr+=\" --short $_arg_short\"\nfi\n\nif [ \"${#_arg_default_value[@]}\" -gt \"0\" ]; then\n\tif [ \"$_arg_repeat\" != \"off\" ]; then\n\t\tfor dfv in \"${_arg_default_value[@]}\"; do\n\t\t\toutStr+=\" --default-value \\\"$dfv\\\"\"\n\t\tdone\n\telse\n\t\toutStr+=\" --default-value \\\"${_arg_default_value[0]}\\\"\"\n\tfi\nfi\n\nif [ \"$_arg_repeat\" != \"off\" ] || [ \"$_arg_repeat_min\" -gt \"1\" ] || [ \"$_arg_repeat_max\" != \"\" ]; then\n  outStr+=\" --repeat\"\nfi\nif [ \"$_arg_repeat_min\" -gt \"1\" ]; then\n  outStr+=\" --repeat-min  $_arg_repeat_min\"\nfi\nif [ \"$_arg_repeat_max\" != \"\" ]; then\n  outStr+=\" --repeat-max  $_arg_repeat_max\"\nfi\n\nif [ \"${#_arg_alias[@]}\" -gt 0 ]; then\n\tfor ali in \"${_arg_alias[@]}\"; do\n \toutStr+=\" --alias $ali\"\n\tdone\nfi\n\nif [ \"${#_arg_complete[@]}\" != \"off\" ]; then\n\tfor _c in \"${_arg_complete[@]}\"; do\n\t\toutStr+=\" --complete \\\"$_c\\\"\";\n\tdone\nfi\n\nif [ \"${#_arg_complete_custom[@]}\" != \"off\" ]; then\n\tfor _c in \"${_arg_complete_custom[@]}\"; do\n\t\toutStr+=\" --complete-custom \\\"$_c\\\"\";\n\tdone\nfi\n\nif [ \"${#_arg_one_of[@]}\" -gt 0 ]; then\n\tfor _oof in \"${_arg_one_of[@]}\"; do\n\t\toutStr+=\" --one-of \\\"$_oof\\\"\";\n\tdone\nfi\n\necho \"$outStr\";\n",
  "/parseArger/bin/flag/help": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"I send an SOS to the world\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt no-name \"value for the negation\"\n# @parseArger opt alias \"flag alias\" --repeat\n# @parseArger opt no-alias \"flag negation alias\" --repeat\n# @parseArger flag on \"on by default\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/flag\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_short=\n_arg_no_name=\n_arg_alias=()\n_arg_no_alias=()\n# FLAGS\n_arg_on=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"I send an SOS to the world:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--no-name <no-name>: value for the negation\"\n\techo -e \"\t--alias <alias>: flag alias, repeatable\"\n\techo -e \"\t--no-alias <no-alias>: flag negation alias, repeatable\"\n\techo -e \"\t--on|--no-on: on by default\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--short <value>] [--no-name <value>] [--alias <value>] [--no-alias <value>] [--[no-]on]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--no-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_no_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--no-name=*)\n\t\t\t\t_arg_no_name=\"${_key##--no-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--no-alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_no_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--no-alias=*)\n\t\t\t\t_arg_no_alias+=(\"${_key##--no-alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--on)\n\t\t\t\t_arg_on=\"on\"\n\t\t\t\t;;\n\t\t\t--no-on)\n\t\t\t\t_arg_on=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\tshort: ${_arg_short}\";\n\techo -e \"\\tno-name: ${_arg_no_name}\";\n\techo -e \"\\talias: ${_arg_alias[*]}\";\n\techo -e \"\\tno-alias: ${_arg_no_alias[*]}\";\n\techo -e \"\\ton: ${_arg_on}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nif [ \"$_arg_no_name\" == \"\" ]; then\n\t_arg_no_name=\"no-${_arg_arg_name}\";\nfi\noptHelp=\"--${_arg_arg_name}|--${_arg_no_name}: ${_arg_description}\";\n\nif [ \"$_arg_short\" != \"\" ]; then\n  optHelp=\"-${_arg_short}|${optHelp}\";\nfi\nif [ \"$_arg_on\" != \"off\" ]; then\n  optHelp=\"$optHelp, on by default (use --${_arg_no_name} to turn it off)\";\nfi\nif [ \"${#_arg_alias[@]}\" -gt 0 ]; then\n\toptHelp+=\"\n\t\taliases:\";\n\tfor ali in \"${_arg_alias[@]}\"; do\n\t\toptHelp+=\" --${ali},\";\n\tdone\nfi\nif [ \"${#_arg_no_alias[@]}\" -gt 0 ]; then\n\toptHelp+=\"\n\t\tno-aliases:\";\n\tfor ali in \"${_arg_no_alias[@]}\"; do\n\t\toptHelp+=\" --${ali},\";\n\tdone\nfi\n\necho -e \"\techo -e \\\"\\t${optHelp}\\\"\";\n",
  "/parseArger/bin/flag/html": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger init string for flags\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt no-name \"value for the negation\"\n# @parseArger opt alias \"flag alias\" --repeat\n# @parseArger opt no-alias \"flag negation alias\" --repeat\n# @parseArger opt checkbox-container-class \"checkbox and radio class\" --default-value \"form-check\" --alias radio-container-class\n# @parseArger opt checkbox-class \"checkbox and radio class\" --default-value \"form-check-input\" --alias radio-class\n# @parseArger opt checkbox-label-class \"checkbox and radio label class\" --default-value \"form-check-label\" --alias radio-label-class\n# @parseArger flag on \"on by default\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/flag\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_short=\n_arg_no_name=\n_arg_alias=()\n_arg_no_alias=()\n_arg_checkbox_container_class=\"form-check\"\n_arg_checkbox_class=\"form-check-input\"\n_arg_checkbox_label_class=\"form-check-label\"\n# FLAGS\n_arg_on=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger init string for flags:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--no-name <no-name>: value for the negation\"\n\techo -e \"\t--alias <alias>: flag alias, repeatable\"\n\techo -e \"\t--no-alias <no-alias>: flag negation alias, repeatable\"\n\techo -e \"\t--checkbox-container-class|--radio-container-class <checkbox-container-class>: checkbox and radio class [default: ' form-check ']\"\n\techo -e \"\t--checkbox-class|--radio-class <checkbox-class>: checkbox and radio class [default: ' form-check-input ']\"\n\techo -e \"\t--checkbox-label-class|--radio-label-class <checkbox-label-class>: checkbox and radio label class [default: ' form-check-label ']\"\n\techo -e \"\t--on|--no-on: on by default\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--short <value>] [--no-name <value>] [--alias <value>] [--no-alias <value>] [--checkbox-container-class <value>] [--checkbox-class <value>] [--checkbox-label-class <value>] [--[no-]on]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--no-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_no_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--no-name=*)\n\t\t\t\t_arg_no_name=\"${_key##--no-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--no-alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_no_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--no-alias=*)\n\t\t\t\t_arg_no_alias+=(\"${_key##--no-alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--radio-container-class|--checkbox-container-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_checkbox_container_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--checkbox-container-class=*)\n\t\t\t\t_arg_checkbox_container_class=\"${_key##--checkbox-container-class=}\"\n\t\t\t\t;;\n\t\t\t--radio-container-class=*)\n\t\t\t\t_arg_checkbox_container_class=\"${_key##--radio-container-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--radio-class|--checkbox-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_checkbox_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--checkbox-class=*)\n\t\t\t\t_arg_checkbox_class=\"${_key##--checkbox-class=}\"\n\t\t\t\t;;\n\t\t\t--radio-class=*)\n\t\t\t\t_arg_checkbox_class=\"${_key##--radio-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--radio-label-class|--checkbox-label-class)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_checkbox_label_class=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--checkbox-label-class=*)\n\t\t\t\t_arg_checkbox_label_class=\"${_key##--checkbox-label-class=}\"\n\t\t\t\t;;\n\t\t\t--radio-label-class=*)\n\t\t\t\t_arg_checkbox_label_class=\"${_key##--radio-label-class=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--on)\n\t\t\t\t_arg_on=\"on\"\n\t\t\t\t;;\n\t\t\t--no-on)\n\t\t\t\t_arg_on=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\tshort: ${_arg_short}\";\n\techo -e \"\\tno-name: ${_arg_no_name}\";\n\techo -e \"\\talias: ${_arg_alias[*]}\";\n\techo -e \"\\tno-alias: ${_arg_no_alias[*]}\";\n\techo -e \"\\tcheckbox-container-class: ${_arg_checkbox_container_class}\";\n\techo -e \"\\tcheckbox-class: ${_arg_checkbox_class}\";\n\techo -e \"\\tcheckbox-label-class: ${_arg_checkbox_label_class}\";\n\techo -e \"\\ton: ${_arg_on}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\ninpuStr=\"<input class=\\\"${_arg_checkbox_class}\\\" type=\\\"checkbox\\\" role=\\\"switch\\\" name=\\\"${_arg_arg_name}\\\" id=\\\"${_arg_arg_name}\\\" value=\\\"${_arg_arg_name}\\\" pa-type=\\\"flag\\\" \";\nif [ \"${_arg_on}\" == \"on\" ];then\n\tinpuStr+=\" checked\";\nfi\ninpuStr+=\"/>\";\n\necho -e \"<div class=\\\"${_arg_checkbox_container_class}\\\">\n\t<label for=\\\"${_arg_arg_name}\\\" class=\\\"${_arg_checkbox_label_class}\\\">${_arg_arg_name}</label>\n\t<i class=\\\"input-help\\\">${_arg_description}</i>\n\t${inpuStr}\n</div>\";\n",
  "/parseArger/bin/flag/completely": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger init string for flags\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt no-name \"value for the negation\"\n# @parseArger opt alias \"flag alias\" --repeat\n# @parseArger opt no-alias \"flag negation alias\" --repeat\n# @parseArger flag on \"on by default\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/flag\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_short=\n_arg_no_name=\n_arg_alias=()\n_arg_no_alias=()\n# FLAGS\n_arg_on=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger init string for flags:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--no-name <no-name>: value for the negation\"\n\techo -e \"\t--alias <alias>: flag alias, repeatable\"\n\techo -e \"\t--no-alias <no-alias>: flag negation alias, repeatable\"\n\techo -e \"\t--on|--no-on: on by default\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--short <value>] [--no-name <value>] [--alias <value>] [--no-alias <value>] [--[no-]on]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--no-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_no_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--no-name=*)\n\t\t\t\t_arg_no_name=\"${_key##--no-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--no-alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_no_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--no-alias=*)\n\t\t\t\t_arg_no_alias+=(\"${_key##--no-alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--on)\n\t\t\t\t_arg_on=\"on\"\n\t\t\t\t;;\n\t\t\t--no-on)\n\t\t\t\t_arg_on=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\tshort: ${_arg_short}\";\n\techo -e \"\\tno-name: ${_arg_no_name}\";\n\techo -e \"\\talias: ${_arg_alias[*]}\";\n\techo -e \"\\tno-alias: ${_arg_no_alias[*]}\";\n\techo -e \"\\ton: ${_arg_on}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nif [ \"$_arg_no_name\" == \"\" ]; then\n\t_arg_no_name=\"no-${_arg_arg_name}\";\nfi\necho \"- --${_arg_arg_name}\";\necho \"- --${_arg_no_name}\";\n\nfor ali in \"${_arg_alias[@]}\"; do\n\techo \"- --${ali}\";\ndone\n\nfor nali in \"${_arg_no_alias[@]}\"; do\n\techo \"- --${nali}\";\ndone\n\nif [ \"$_arg_short\" != \"\" ]; then\n\techo \"- -${_arg_short}\";\nfi\n",
  "/parseArger/bin/flag/init": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger init string for flags\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt no-name \"value for the negation\"\n# @parseArger opt alias \"flag alias\" --repeat\n# @parseArger opt no-alias \"flag negation alias\" --repeat\n# @parseArger flag on \"on by default\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/flag\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_short=\n_arg_no_name=\n_arg_alias=()\n_arg_no_alias=()\n# FLAGS\n_arg_on=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger init string for flags:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--no-name <no-name>: value for the negation\"\n\techo -e \"\t--alias <alias>: flag alias, repeatable\"\n\techo -e \"\t--no-alias <no-alias>: flag negation alias, repeatable\"\n\techo -e \"\t--on|--no-on: on by default\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--short <value>] [--no-name <value>] [--alias <value>] [--no-alias <value>] [--[no-]on]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--no-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_no_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--no-name=*)\n\t\t\t\t_arg_no_name=\"${_key##--no-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--no-alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_no_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--no-alias=*)\n\t\t\t\t_arg_no_alias+=(\"${_key##--no-alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--on)\n\t\t\t\t_arg_on=\"on\"\n\t\t\t\t;;\n\t\t\t--no-on)\n\t\t\t\t_arg_on=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\tshort: ${_arg_short}\";\n\techo -e \"\\tno-name: ${_arg_no_name}\";\n\techo -e \"\\talias: ${_arg_alias[*]}\";\n\techo -e \"\\tno-alias: ${_arg_no_alias[*]}\";\n\techo -e \"\\ton: ${_arg_on}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\n\noutStr=\"_arg_${_arg_arg_name//-/_}=\";\n\nif [ \"$_arg_on\" == \"on\" ]; then\n  outStr+=\"\\\"on\\\"\";\nelse\n  outStr+=\"\\\"off\\\"\";\nfi\n\necho -e \"$outStr\";\n",
  "/parseArger/bin/flag/parser": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger parsing string for flags\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt no-name \"value for the negation\"\n# @parseArger opt alias \"flag alias\" --repeat\n# @parseArger opt no-alias \"flag negation alias\" --repeat\n# @parseArger flag on \"on by default\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/flag\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_short=\n_arg_no_name=\n_arg_alias=()\n_arg_no_alias=()\n# FLAGS\n_arg_on=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger parsing string for flags:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--no-name <no-name>: value for the negation\"\n\techo -e \"\t--alias <alias>: flag alias, repeatable\"\n\techo -e \"\t--no-alias <no-alias>: flag negation alias, repeatable\"\n\techo -e \"\t--on|--no-on: on by default\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--short <value>] [--no-name <value>] [--alias <value>] [--no-alias <value>] [--[no-]on]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--no-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_no_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--no-name=*)\n\t\t\t\t_arg_no_name=\"${_key##--no-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--no-alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_no_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--no-alias=*)\n\t\t\t\t_arg_no_alias+=(\"${_key##--no-alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--on)\n\t\t\t\t_arg_on=\"on\"\n\t\t\t\t;;\n\t\t\t--no-on)\n\t\t\t\t_arg_on=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\tshort: ${_arg_short}\";\n\techo -e \"\\tno-name: ${_arg_no_name}\";\n\techo -e \"\\talias: ${_arg_alias[*]}\";\n\techo -e \"\\tno-alias: ${_arg_no_alias[*]}\";\n\techo -e \"\\ton: ${_arg_on}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nif [ \"$_arg_no_name\" == \"\" ]; then\n\t_arg_no_name=\"no-${_arg_arg_name}\";\nfi\noptParser=\"--${_arg_arg_name}\";\n\nif [ \"${#_arg_alias[@]}\" -gt 0 ]; then\n\tfor ali in \"${_arg_alias[@]}\"; do\n\t\toptParser=\"${optParser}|--${ali}\";\n\tdone\nfi\n\nif [ \"$_arg_short\" != \"\" ]; then\n  optParser=\"-${_arg_short}|${optParser}\";\nfi\n\noptParser=\"${optParser})\n\t_arg_${_arg_arg_name//-/_}=\\\"on\\\"\n\t;;\";\noptParser=\"${optParser}\n--${_arg_no_name}\";\n\nif [ \"${#_arg_no_alias[@]}\" -gt 0 ]; then\n\tfor n_ali in \"${_arg_no_alias[@]}\"; do\n\t\toptParser=\"${optParser}|--${n_ali}\";\n\tdone\nfi\n\necho -e \"${optParser})\n\t_arg_${_arg_arg_name//-/_}=\\\"off\\\"\n\t;;\";\n",
  "/parseArger/bin/flag/docopt-help": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger docopt string for flags\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt no-name \"value for the negation\"\n# @parseArger opt alias \"flag alias\" --repeat\n# @parseArger opt no-alias \"flag negation alias\" --repeat\n# @parseArger flag on \"on by default\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/flag\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_short=\n_arg_no_name=\n_arg_alias=()\n_arg_no_alias=()\n# FLAGS\n_arg_on=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger docopt string for flags:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--no-name <no-name>: value for the negation\"\n\techo -e \"\t--alias <alias>: flag alias, repeatable\"\n\techo -e \"\t--no-alias <no-alias>: flag negation alias, repeatable\"\n\techo -e \"\t--on|--no-on: on by default\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--short <value>] [--no-name <value>] [--alias <value>] [--no-alias <value>] [--[no-]on]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--no-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_no_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--no-name=*)\n\t\t\t\t_arg_no_name=\"${_key##--no-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--no-alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_no_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--no-alias=*)\n\t\t\t\t_arg_no_alias+=(\"${_key##--no-alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--on)\n\t\t\t\t_arg_on=\"on\"\n\t\t\t\t;;\n\t\t\t--no-on)\n\t\t\t\t_arg_on=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\tshort: ${_arg_short}\";\n\techo -e \"\\tno-name: ${_arg_no_name}\";\n\techo -e \"\\talias: ${_arg_alias[*]}\";\n\techo -e \"\\tno-alias: ${_arg_no_alias[*]}\";\n\techo -e \"\\ton: ${_arg_on}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\noptHelp=\"--${_arg_arg_name} ${_arg_arg_name}\";\n\nif [ \"$_arg_short\" != \"\" ]; then\n  optHelp=\"-${_arg_short} ${_arg_arg_name}, ${optHelp}\";\nfi\n\noptHelp=\"${optHelp}\\t${_arg_description}\";\n\nif [ \"$_arg_on\" != \"off\" ]; then\n  optHelp=\"$optHelp, on by default (use --no-${_arg_arg_name} to turn it off)\";\nfi\n\necho -e \"$optHelp\";\n",
  "/parseArger/bin/flag/declaration": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parseArger declaration string for flags\" --option \"help\" --short-option \"h\"\n# @parseArger-version \"0.1\" --option \"version\" --short-option \"v\"\n# @parseArger-verbose --option \"verbose\" --level \"0\"\n# @parseArger-declarations\n# @parseArger pos arg-name \"positional argument name\"\n# @parseArger pos description \"positional argument description\"\n# @parseArger opt short \"short form\" --short s\n# @parseArger opt no-name \"value for the negation\"\n# @parseArger opt alias \"flag alias\" --repeat\n# @parseArger opt no-alias \"flag negation alias\" --repeat\n# @parseArger flag on \"on by default\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/bin/flag\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\ndie()\n{\n\tlocal _ret=\"${2:-1}\"\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_arg_arg_name=\"\";\n_arg_description=\"\";\n# OPTIONALS ARGUMENTS\n_arg_short=\n_arg_no_name=\n_arg_alias=()\n_arg_no_alias=()\n# FLAGS\n_arg_on=\"off\"\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parseArger declaration string for flags:\"\n\techo -e \"\targ-name: positional argument name\"\n\techo -e \"\tdescription: positional argument description\"\n\techo -e \"\t-s, --short <short>: short form\"\n\techo -e \"\t--no-name <no-name>: value for the negation\"\n\techo -e \"\t--alias <alias>: flag alias, repeatable\"\n\techo -e \"\t--no-alias <no-alias>: flag negation alias, repeatable\"\n\techo -e \"\t--on|--no-on: on by default\"\n\techo -e \"Usage :\n\t$0 <arg-name> <description> [--short <value>] [--no-name <value>] [--alias <value>] [--no-alias <value>] [--[no-]on]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t-s|--short)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_short=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--short=*)\n\t\t\t\t_arg_short=\"${_key##--short=}\"\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_short=\"${_key##-s}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--no-name)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_no_name=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--no-name=*)\n\t\t\t\t_arg_no_name=\"${_key##--no-name=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--alias=*)\n\t\t\t\t_arg_alias+=(\"${_key##--alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--no-alias)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_no_alias+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--no-alias=*)\n\t\t\t\t_arg_no_alias+=(\"${_key##--no-alias=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--on)\n\t\t\t\t_arg_on=\"on\"\n\t\t\t\t;;\n\t\t\t--no-on)\n\t\t\t\t_arg_on=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v|--version)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-v*)\n\t\t\t\tprint_version;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\telse\n\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\tshift;\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\t\n\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"arg-name description\"\n\tif [ \"${_positionals_count}\" -gt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 2 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 2 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"_arg_arg_name _arg_description \";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\\targ-name: ${_arg_arg_name}\";\n\techo -e \"\\tdescription: ${_arg_description}\";\n\techo -e \"\\tshort: ${_arg_short}\";\n\techo -e \"\\tno-name: ${_arg_no_name}\";\n\techo -e \"\\talias: ${_arg_alias[*]}\";\n\techo -e \"\\tno-alias: ${_arg_no_alias[*]}\";\n\techo -e \"\\ton: ${_arg_on}\";\n\n}\n\nprint_version()\n{\n\techo \"0.1\";\n}\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\noutStr=\"# @parse\";\noutStr=\"${outStr}Arger flag $_arg_arg_name \\\"${_arg_description}\\\"\"\n\nif [ \"$_arg_short\" != \"\" ]; then\n  outStr=\"$outStr --short $_arg_short\"\nfi\nif [ \"$_arg_on\" != \"off\" ]; then\n  outStr=\"$outStr --on\"\nfi\nif [ \"$_arg_no_name\" != \"\" ]; then\n  outStr=\"$outStr --no-name $_arg_no_name\"\nfi\nif [ \"${#_arg_alias[@]}\" -gt 0 ]; then\n\tfor ali in \"${_arg_alias[@]}\"; do\n\t\toutStr=\"$outStr --alias $ali\";\n\tdone\nfi\nif [ \"${#_arg_no_alias[@]}\" -gt 0 ]; then\n\tfor ali in \"${_arg_no_alias[@]}\"; do\n\t\toutStr=\"$outStr --no-alias $ali\";\n\tdone\nfi\n\necho \"$outStr\";\n",
  "/parseArger/lib/bashunit_ext": "#!/bin/bash\n\nfunction filemd5() {\n  md5sum \"$1\" | cut -d' ' -f1;\n}\n\nfunction assert_files_equals () {\n  local f1=\"$1\";\n  local f2=\"$2\";\n  local md1=$(filemd5 \"$f1\");\n  local md2=$(filemd5 \"$f2\");\n  assert_equals \"$md1\" \"$md2\";\n}",
  "/parseArger/lib/bashunit": "#!/bin/bash\n\nfunction assert_equals() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ \"$expected\" != \"$actual\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"but got\" \"${actual}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_equals_ignore_colors() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  local actual_without_colors\n  actual_without_colors=$(echo -e \"$actual\" | sed \"s/\\x1B\\[[0-9;]*[JKmsu]//g\")\n\n  assert_equals \"$expected\" \"$actual_without_colors\" \"$label\"\n}\n\nfunction assert_empty() {\n  local expected=\"$1\"\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ \"$expected\" != \"\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"to be empty\" \"but got\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_not_empty() {\n  local expected=\"$1\"\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ \"$expected\" == \"\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"to not be empty\" \"but got\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_not_equals() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ \"$expected\" == \"$actual\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"but got\" \"${actual}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_contains() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if ! [[ $actual == *\"$expected\"* ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual}\" \"to contain\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_contains_ignore_case() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  shopt -s nocasematch\n\n  if ! [[ $actual =~ $expected ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual}\" \"to contain\" \"${expected}\"\n\n    shopt -u nocasematch\n    return\n  fi\n\n  shopt -u nocasematch\n  state::add_assertions_passed\n}\n\nfunction assert_not_contains() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ $actual == *\"$expected\"* ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual}\" \"to not contain\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_matches() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if ! [[ $actual =~ $expected ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual}\" \"to match\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_not_matches() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ $actual =~ $expected ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual}\" \"to not match\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_exit_code() {\n  local actual_exit_code=${3-\"$?\"}\n  local expected_exit_code=\"$1\"\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ \"$actual_exit_code\" -ne \"$expected_exit_code\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual_exit_code}\" \"to be\" \"${expected_exit_code}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_successful_code() {\n  local actual_exit_code=${3-\"$?\"}\n  local expected_exit_code=0\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ \"$actual_exit_code\" -ne \"$expected_exit_code\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual_exit_code}\" \"to be exactly\" \"${expected_exit_code}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_general_error() {\n  local actual_exit_code=${3-\"$?\"}\n  local expected_exit_code=1\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ $actual_exit_code -ne \"$expected_exit_code\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual_exit_code}\" \"to be exactly\" \"${expected_exit_code}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_command_not_found() {\n  local actual_exit_code=${3-\"$?\"}\n  local expected_exit_code=127\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ $actual_exit_code -ne \"$expected_exit_code\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual_exit_code}\" \"to be exactly\" \"${expected_exit_code}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_string_starts_with() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if ! [[ $actual =~ ^\"$expected\"* ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual}\" \"to start with\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_string_not_starts_with() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ $actual =~ ^\"$expected\"* ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual}\" \"to not start with\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_string_ends_with() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if ! [[ $actual =~ .*\"$expected\"$ ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual}\" \"to end with\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_string_not_ends_with() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ $actual =~ .*\"$expected\"$ ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual}\" \"to not end with\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_less_than() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if ! [[ \"$actual\" -lt \"$expected\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual}\" \"to be less than\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_less_or_equal_than() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if ! [[ \"$actual\" -le \"$expected\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual}\" \"to be less or equal than\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_greater_than() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if ! [[ \"$actual\" -gt \"$expected\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual}\" \"to be greater than\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_greater_or_equal_than() {\n  local expected=\"$1\"\n  local actual=\"$2\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if ! [[ \"$actual\" -ge \"$expected\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual}\" \"to be greater or equal than\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n#!/bin/bash\n\nfunction assert_array_contains() {\n  local expected=\"$1\"\n  local label\n  label=\"$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")\"\n  shift\n\n  local actual=(\"${@}\")\n\n  if ! [[ \"${actual[*]}\" == *\"$expected\"* ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual[*]}\" \"to contain\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_array_not_contains() {\n  local expected=\"$1\"\n  label=\"$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")\"\n  shift\n  local actual=(\"$@\")\n\n  if [[ \"${actual[*]}\" == *\"$expected\"* ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${actual[*]}\" \"to not contain\" \"${expected}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n#!/bin/bash\n\nfunction assert_file_exists() {\n  local expected=\"$1\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ ! -f \"$expected\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"to exist but\" \"do not exist\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_file_not_exists() {\n  local expected=\"$1\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ -f \"$expected\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"to not exist but\" \"the file exists\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_is_file() {\n  local expected=\"$1\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ ! -f \"$expected\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"to be a file\" \"but is not a file\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_is_file_empty() {\n  local expected=\"$1\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ -s \"$expected\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"to be empty\" \"but is not empty\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n#!/bin/bash\n\nfunction assert_directory_exists() {\n  local expected=\"$1\"\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ ! -d \"$expected\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"to exist but\" \"do not exist\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_directory_not_exists() {\n  local expected=\"$1\"\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ -d \"$expected\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"to not exist but\" \"the directory exists\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_is_directory() {\n  local expected=\"$1\"\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ ! -d \"$expected\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"to be a directory\" \"but is not a directory\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_is_directory_empty() {\n  local expected=\"$1\"\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ ! -d \"$expected\" || -n \"$(ls -A \"$expected\")\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"to be empty\" \"but is not empty\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_is_directory_not_empty() {\n  local expected=\"$1\"\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ ! -d \"$expected\" || -z \"$(ls -A \"$expected\")\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"to not be empty\" \"but is empty\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_is_directory_readable() {\n  local expected=\"$1\"\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ ! -d \"$expected\" || ! -r \"$expected\" || ! -x \"$expected\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"to be readable\" \"but is not readable\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_is_directory_not_readable() {\n  local expected=\"$1\"\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ ! -d \"$expected\" ]] || [[ -r \"$expected\" && -x \"$expected\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"to be not readable\" \"but is readable\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_is_directory_writable() {\n  local expected=\"$1\"\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ ! -d \"$expected\" || ! -w \"$expected\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"to be writable\" \"but is not writable\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_is_directory_not_writable() {\n  local expected=\"$1\"\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ ! -d \"$expected\" || -w \"$expected\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"to be not writable\" \"but is writable\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n#!/bin/bash\n\nfunction assert_match_snapshot() {\n  local actual\n  actual=$(echo -n \"$1\" | tr -d '\\r')\n  local directory\n    directory=\"./$(dirname \"${BASH_SOURCE[1]}\")/snapshots\"\n  local test_file\n    test_file=\"$(helper::normalize_variable_name \"$(basename \"${BASH_SOURCE[1]}\")\")\"\n  local snapshot_name\n    snapshot_name=\"$(helper::normalize_variable_name \"${FUNCNAME[1]}\").snapshot\"\n  local snapshot_file\n  snapshot_file=\"${directory}/${test_file}.${snapshot_name}\"\n\n  if [[ ! -f \"$snapshot_file\" ]]; then\n    mkdir -p \"$directory\"\n    echo \"$actual\" > \"$snapshot_file\"\n\n    state::add_assertions_snapshot\n    return\n  fi\n\n  local snapshot\n  snapshot=$(tr -d '\\r' < \"$snapshot_file\")\n\n  if [[ \"$actual\" != \"$snapshot\" ]]; then\n    local label\n    label=$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")\n\n    state::add_assertions_failed\n    console_results::print_failed_snapshot_test \"$label\" \"$snapshot_file\"\n\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\n#!/bin/bash\n\n#!/bin/bash\n\n# shellcheck disable=SC2034\n_OS=\"Unknown\"\n\nif [[ \"$(uname)\" == \"Linux\" ]]; then\n  _OS=\"Linux\"\nelif [[ \"$(uname)\" == \"Darwin\" ]]; then\n  _OS=\"OSX\"\nelif [[ $(uname) == *\"MINGW\"* ]]; then\n  _OS=\"Windows\"\nfi\n#!/bin/bash\n\n# shellcheck disable=SC2034\n_COLOR_DEFAULT=$'\\e[0m'\n_COLOR_BOLD=$'\\e[1m'\n_COLOR_FAINT=$'\\e[2m'\n_COLOR_FAILED=$'\\e[31m'\n_COLOR_PASSED=$'\\e[32m'\n_COLOR_SKIPPED=$'\\e[33m'\n_COLOR_INCOMPLETE=$'\\e[36m'\n_COLOR_SNAPSHOT=$'\\e[34m'\n_COLOR_RETURN_ERROR=$'\\e[41m'\n_COLOR_RETURN_SUCCESS=$'\\e[42m'\n_COLOR_RETURN_SKIPPED=$'\\e[43m'\n_COLOR_RETURN_INCOMPLETE=$'\\e[46m'\n_COLOR_RETURN_SNAPSHOT=$'\\e[44m'\n#!/bin/bash\n\nfunction console_header::print_version() {\n  if [[ $HEADER_ASCII_ART == true ]]; then\n    cat <<EOF\n _               _                   _\n| |__   __ _ ___| |__  __ __ ____ (_) |_\n| '_ \\ / _' / __| '_ \\| | | | '_ \\| | __|\n| |_) | (_| \\__ \\ | | | |_| | | | | | |_\n|_.__/ \\__,_|___/_| |_|\\___/|_| |_|_|\\__|\nEOF\n    printf \"%s\\n\\n\" \"$BASHUNIT_VERSION\"\n  else\n    printf \"${_COLOR_BOLD}${_COLOR_PASSED}bashunit${_COLOR_DEFAULT} - %s\\n\" \"$BASHUNIT_VERSION\"\n  fi\n}\n\nfunction console_header::print_version_with_env() {\n    local should_print_ascii=\"true\"\n    if [[ \"$SHOW_HEADER\" != \"$should_print_ascii\" ]]; then\n      return\n    fi\n    console_header::print_version\n}\n\nfunction console_header::print_help() {\n    cat <<EOF\nbashunit [arguments] [options]\n\nArguments:\n  Specifies the directory or file containing the tests to run.\n  If a directory is specified, it will execute the tests within files ending with test.sh.\n  If you use wildcards, bashunit will run any tests it finds.\n\nOptions:\n  -f|--filer <filter>\n    Filters the tests to run based on the test name.\n\n  -s|simple || -v|verbose\n    Enables simplified or verbose output to the console.\n\n  -S|--stop-on-failure\n    Force to stop the runner right after encountering one failing test.\n\n  -e|--env <file-path>\n    Load a custom env file overriding the .env environment variables.\n\n  --version\n    Displays the current version of bashunit.\n\n  --help\n    This message.\n\nSee more: https://bashunit.typeddevs.com/command-line\nEOF\n}\n#!/bin/bash\n\n_START_TIME=$(date +%s%N);\n_SUCCESSFUL_TEST_COUNT=0\n\nfunction console_results::render_result() {\n  if [[ \"$(state::is_duplicated_test_functions_found)\" == true ]]; then\n    console_results::print_execution_time\n    printf \"%s%s%s\\n\" \"${_COLOR_RETURN_ERROR}\" \"Duplicate test functions found\" \"${_COLOR_DEFAULT}\"\n    printf \"File with duplicate functions: %s\\n\" \"$(state::get_file_with_duplicated_function_names)\"\n    printf \"Duplicate functions: %s\\n\" \"$(state::get_duplicated_function_names)\"\n    exit 1\n  fi\n\n  echo \"\"\n\n  local total_tests=0\n  ((total_tests+=$(state::get_tests_passed)))\n  ((total_tests+=$(state::get_tests_skipped)))\n  ((total_tests+=$(state::get_tests_incomplete)))\n  ((total_tests+=$(state::get_tests_snapshot)))\n  ((total_tests+=$(state::get_tests_failed)))\n\n  local total_assertions=0\n  ((total_assertions+=$(state::get_assertions_passed)))\n  ((total_assertions+=$(state::get_assertions_skipped)))\n  ((total_assertions+=$(state::get_assertions_incomplete)))\n  ((total_assertions+=$(state::get_assertions_snapshot)))\n  ((total_assertions+=$(state::get_assertions_failed)))\n\n  printf \"%sTests:     %s\" \"$_COLOR_FAINT\" \"$_COLOR_DEFAULT\"\n  if [[ \"$(state::get_tests_passed)\" -gt 0 ]] || [[ \"$(state::get_assertions_passed)\" -gt 0 ]]; then\n    printf \" %s%s passed%s,\" \"$_COLOR_PASSED\" \"$(state::get_tests_passed)\" \"$_COLOR_DEFAULT\"\n  fi\n  if [[ \"$(state::get_tests_skipped)\" -gt 0 ]] || [[ \"$(state::get_assertions_skipped)\" -gt 0 ]]; then\n    printf \" %s%s skipped%s,\" \"$_COLOR_SKIPPED\" \"$(state::get_tests_skipped)\" \"$_COLOR_DEFAULT\"\n  fi\n  if [[ \"$(state::get_tests_incomplete)\" -gt 0 ]] || [[ \"$(state::get_assertions_incomplete)\" -gt 0 ]]; then\n    printf \" %s%s incomplete%s,\" \"$_COLOR_INCOMPLETE\" \"$(state::get_tests_incomplete)\" \"$_COLOR_DEFAULT\"\n  fi\n  if [[ \"$(state::get_tests_snapshot)\" -gt 0 ]] || [[ \"$(state::get_assertions_snapshot)\" -gt 0 ]]; then\n    printf \" %s%s snapshot%s,\" \"$_COLOR_SNAPSHOT\" \"$(state::get_tests_snapshot)\" \"$_COLOR_DEFAULT\"\n  fi\n  if [[ \"$(state::get_tests_failed)\" -gt 0 ]] || [[ \"$(state::get_assertions_failed)\" -gt 0 ]]; then\n    printf \" %s%s failed%s,\" \"$_COLOR_FAILED\" \"$(state::get_tests_failed)\" \"$_COLOR_DEFAULT\"\n  fi\n  printf \" %s total\\n\" \"$total_tests\"\n\n  printf \"%sAssertions:%s\" \"$_COLOR_FAINT\" \"$_COLOR_DEFAULT\"\n  if [[ \"$(state::get_tests_passed)\" -gt 0 ]] || [[ \"$(state::get_assertions_passed)\" -gt 0 ]]; then\n      printf \" %s%s passed%s,\" \"$_COLOR_PASSED\" \"$(state::get_assertions_passed)\" \"$_COLOR_DEFAULT\"\n  fi\n  if [[ \"$(state::get_tests_skipped)\" -gt 0 ]] || [[ \"$(state::get_assertions_skipped)\" -gt 0 ]]; then\n    printf \" %s%s skipped%s,\" \"$_COLOR_SKIPPED\" \"$(state::get_assertions_skipped)\" \"$_COLOR_DEFAULT\"\n  fi\n  if [[ \"$(state::get_tests_incomplete)\" -gt 0 ]] || [[ \"$(state::get_assertions_incomplete)\" -gt 0 ]]; then\n    printf \" %s%s incomplete%s,\" \"$_COLOR_INCOMPLETE\" \"$(state::get_assertions_incomplete)\" \"$_COLOR_DEFAULT\"\n  fi\n  if [[ \"$(state::get_tests_snapshot)\" -gt 0 ]] || [[ \"$(state::get_assertions_snapshot)\" -gt 0 ]]; then\n    printf \" %s%s snapshot%s,\" \"$_COLOR_SNAPSHOT\" \"$(state::get_assertions_snapshot)\" \"$_COLOR_DEFAULT\"\n  fi\n  if [[ \"$(state::get_tests_failed)\" -gt 0 ]] || [[ \"$(state::get_assertions_failed)\" -gt 0 ]]; then\n    printf \" %s%s failed%s,\" \"$_COLOR_FAILED\" \"$(state::get_assertions_failed)\" \"$_COLOR_DEFAULT\"\n  fi\n  printf \" %s total\\n\" \"$total_assertions\"\n\n  if [[ \"$(state::get_tests_failed)\" -gt 0 ]]; then\n    printf \"%s%s%s\\n\" \"$_COLOR_RETURN_ERROR\" \"Some tests failed\" \"$_COLOR_DEFAULT\"\n    console_results::print_execution_time\n    exit 1\n  fi\n\n  if [[ \"$(state::get_tests_incomplete)\" -gt 0 ]]; then\n    printf \"%s%s%s\\n\" \"$_COLOR_RETURN_INCOMPLETE\" \"Some tests incomplete\" \"$_COLOR_DEFAULT\"\n    console_results::print_execution_time\n    exit 0\n  fi\n\n  if [[ \"$(state::get_tests_skipped)\" -gt 0 ]]; then\n    printf \"%s%s%s\\n\" \"$_COLOR_RETURN_SKIPPED\" \"Some tests skipped\" \"$_COLOR_DEFAULT\"\n    console_results::print_execution_time\n    exit 0\n  fi\n\n  if [[ \"$(state::get_tests_snapshot)\" -gt 0 ]]; then\n    printf \"%s%s%s\\n\" \"$_COLOR_RETURN_SNAPSHOT\" \"Some snapshots created\" \"$_COLOR_DEFAULT\"\n    console_results::print_execution_time\n    exit 0\n  fi\n\n  if [[ $total_tests -eq 0 ]]; then\n    printf \"%s%s%s\\n\" \"$_COLOR_RETURN_ERROR\" \"No tests found\" \"$_COLOR_DEFAULT\"\n    console_results::print_execution_time\n    exit 1\n  fi\n\n  printf \"%s%s%s\\n\" \"$_COLOR_RETURN_SUCCESS\" \"All tests passed\" \"$_COLOR_DEFAULT\"\n  console_results::print_execution_time\n  exit 0\n}\n\nfunction console_results::print_execution_time() {\n  if [[ $SHOW_EXECUTION_TIME == false ]]; then\n    return\n  fi\n\n  if [[ \"$_OS\" != \"OSX\" ]]; then\n    _EXECUTION_TIME=$((($(date +%s%N) - \"$_START_TIME\") / 1000000))\n    printf \"${_COLOR_BOLD}%s${_COLOR_DEFAULT}\\n\" \"Time taken: ${_EXECUTION_TIME} ms\"\n  fi\n}\n\nfunction console_results::print_successful_test() {\n  ((_SUCCESSFUL_TEST_COUNT++))\n\n  if [[ \"$SIMPLE_OUTPUT\" == true ]]; then\n    if (( _SUCCESSFUL_TEST_COUNT % 50 != 0 )); then\n      printf \".\"\n    else\n      echo \".\"\n    fi\n  else\n    local test_name=$1\n    local data=$2\n\n    if [[ -z \"$data\" ]]; then\n      printf \"%s Passed%s: %s\\n\" \"$_COLOR_PASSED\" \"$_COLOR_DEFAULT\" \"${test_name}\"\n    else\n      printf \"%s Passed%s: %s (%s)\\n\" \"$_COLOR_PASSED\" \"$_COLOR_DEFAULT\" \"${test_name}\" \"${data}\"\n    fi\n  fi\n}\n\nfunction console_results::print_failed_test() {\n  local test_name=$1\n  local expected=$2\n  local failure_condition_message=$3\n  local actual=$4\n\n  printf \"\\\n${_COLOR_FAILED} Failed${_COLOR_DEFAULT}: %s\n    ${_COLOR_FAINT}Expected${_COLOR_DEFAULT} ${_COLOR_BOLD}'%s'${_COLOR_DEFAULT}\n    ${_COLOR_FAINT}%s${_COLOR_DEFAULT} ${_COLOR_BOLD}'%s'${_COLOR_DEFAULT}\\n\"\\\n    \"${test_name}\" \"${expected}\" \"${failure_condition_message}\" \"${actual}\"\n}\n\nfunction console_results::print_failed_snapshot_test() {\n  local test_name=$1\n  local snapshot_file=$2\n\n  printf \"${_COLOR_FAILED} Failed${_COLOR_DEFAULT}: %s\n    ${_COLOR_FAINT}Expected to match the snapshot${_COLOR_DEFAULT}\\n\" \"$test_name\"\n\n  if command -v git > /dev//null; then\n    local actual_file\n    actual_file=\"${snapshot_file}.tmp\"\n    echo \"$actual\" > \"$actual_file\"\n    git diff --no-index --word-diff --color=always \"$snapshot_file\" \"$actual_file\" 2>/dev/null\\\n      | tail -n +6 | sed \"s/^/    /\"\n    rm \"$actual_file\"\n  fi\n}\n\nfunction console_results::print_skipped_test() {\n  local test_name=$1\n  local reason=$2\n\n  printf \"${_COLOR_SKIPPED} Skipped${_COLOR_DEFAULT}: %s\\n\" \"${test_name}\"\n\n  if [[ -n \"$reason\" ]]; then\n    printf \"${_COLOR_FAINT}    %s${_COLOR_DEFAULT}\\n\" \"${reason}\"\n  fi\n}\n\nfunction console_results::print_incomplete_test() {\n  local test_name=$1\n  local pending=$2\n\n  printf \"${_COLOR_INCOMPLETE} Incomplete${_COLOR_DEFAULT}: %s\\n\" \"${test_name}\"\n\n  if [[ -n \"$pending\" ]]; then\n    printf \"${_COLOR_FAINT}    %s${_COLOR_DEFAULT}\\n\" \"${pending}\"\n  fi\n}\n\nfunction console_results::print_snapshot_test() {\n  local test_name\n  test_name=$(helper::normalize_test_function_name \"$1\")\n\n  printf \"${_COLOR_SNAPSHOT} Snapshot${_COLOR_DEFAULT}: %s\\n\" \"${test_name}\"\n}\n\nfunction console_results::print_error_test() {\n  local test_name\n  test_name=$(helper::normalize_test_function_name \"$1\")\n  local error=\"$2\"\n\n  printf \"${_COLOR_FAILED} Failed${_COLOR_DEFAULT}: %s\n    ${_COLOR_FAINT}%s${_COLOR_DEFAULT}\\n\" \"${test_name}\" \"${error}\"\n}\n#!/bin/bash\n\n# shellcheck disable=SC2034\n_DEFAULT_PARALLEL_RUN=false\n_DEFAULT_SHOW_HEADER=true\n_DEFAULT_HEADER_ASCII_ART=false\n_DEFAULT_SIMPLE_OUTPUT=false\n_DEFAULT_STOP_ON_FAILURE=false\n_DEFAULT_SHOW_EXECUTION_TIME=true\n_DEFAULT_DEFAULT_PATH=\nCAT=\"$(which cat)\"\n#!/bin/bash\n\n# Deprecated: Please use assert_equals instead.\nfunction assertEquals() {\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  assert_equals \"$1\" \"$2\" \"$label\"\n}\n\n# Deprecated: Please use assert_empty instead.\nfunction assertEmpty() {\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  assert_empty \"$1\" \"$label\"\n}\n\n# Deprecated: Please use assert_not_empty instead.\nfunction assertNotEmpty() {\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  assert_not_empty \"$1\" \"$label\"\n}\n\n# Deprecated: Please use assert_not_equals instead.\nfunction assertNotEquals() {\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  assert_not_equals \"$1\" \"$2\" \"$label\"\n}\n\n# Deprecated: Please use assert_contains instead.\nfunction assertContains() {\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  assert_contains \"$1\" \"$2\" \"$label\"\n}\n\n# Deprecated: Please use assert_not_contains instead.\nfunction assertNotContains() {\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  assert_not_contains \"$1\" \"$2\" \"$label\"\n}\n\n# Deprecated: Please use assert_matches instead.\nfunction assertMatches() {\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  assert_matches \"$1\" \"$2\" \"$label\"\n}\n\n# Deprecated: Please use assert_not_matches instead.\nfunction assertNotMatches() {\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  assert_not_matches \"$1\" \"$2\" \"$label\"\n}\n\n# Deprecated: Please use assert_exit_code instead.\nfunction assertExitCode() {\n  local actual_exit_code=$?\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  assert_exit_code \"$1\" \"$label\" \"$actual_exit_code\"\n}\n\n# Deprecated: Please use assert_successful_code instead.\nfunction assertSuccessfulCode() {\n  local actual_exit_code=$?\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  assert_successful_code \"$1\" \"$label\" \"$actual_exit_code\"\n}\n\n# Deprecated: Please use assert_general_error instead.\nfunction assertGeneralError() {\n  local actual_exit_code=$?\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  assert_general_error \"$1\" \"$label\" \"$actual_exit_code\"\n}\n\n# Deprecated: Please use assert_command_not_found instead.\nfunction assertCommandNotFound() {\n  local actual_exit_code=$?\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  assert_command_not_found \"{command}\" \"$label\" \"$actual_exit_code\"\n}\n\n# Deprecated: Please use assert_array_contains instead.\nfunction assertArrayContains() {\n  assert_array_contains \"$1\" \"${@:2}\"\n}\n\n# Deprecated: Please use assert_array_not_contains instead.\nfunction assertArrayNotContains() {\n  assert_array_not_contains \"$1\" \"${@:1}\"\n}\n#!/bin/bash\n\nset -o allexport\n# shellcheck source=/dev/null\n[[ -f \".env\" ]] && source .env set\nset +o allexport\n\nif [[ -z \"$PARALLEL_RUN\" ]]; then\n  PARALLEL_RUN=$_DEFAULT_PARALLEL_RUN\nfi\n\nif [[ -z \"$SHOW_HEADER\" ]]; then\n  SHOW_HEADER=$_DEFAULT_SHOW_HEADER\nfi\n\nif [[ -z \"$HEADER_ASCII_ART\" ]]; then\n  HEADER_ASCII_ART=$_DEFAULT_HEADER_ASCII_ART\nfi\n\nif [[ -z \"$SIMPLE_OUTPUT\" ]]; then\n  SIMPLE_OUTPUT=$_DEFAULT_SIMPLE_OUTPUT\nfi\n\nif [[ -z \"$STOP_ON_FAILURE\" ]]; then\n  STOP_ON_FAILURE=$_DEFAULT_STOP_ON_FAILURE\nfi\n\nif [[ -z \"$SHOW_EXECUTION_TIME\" ]]; then\n  SHOW_EXECUTION_TIME=$_DEFAULT_SHOW_EXECUTION_TIME\nfi\n\nif [[ -z \"$DEFAULT_PATH\" ]]; then\n  DEFAULT_PATH=$_DEFAULT_DEFAULT_PATH\nfi\n#!/bin/bash\n\n#\n# @param $1 string Eg: \"test_some_logic_camelCase\"\n#\n# @return string Eg: \"Some logic camelCase\"\n#\nfunction helper::normalize_test_function_name() {\n  local original_function_name=\"$1\"\n  local result\n\n  # Remove \"test_\" prefix\n  result=\"${original_function_name#test_}\"\n  # Replace underscores with spaces\n  result=\"${result//_/ }\"\n  # Remove \"test\" prefix\n  result=\"${result#test}\"\n  # Capitalize the first letter\n  result=\"$(tr '[:lower:]' '[:upper:]' <<< \"${result:0:1}\")${result:1}\"\n\n  echo \"$result\"\n}\n\nfunction helper::check_duplicate_functions() {\n  local script=\"$1\"\n\n  local filtered_lines\n  filtered_lines=$(grep -E '^\\s*(function)?\\s*test[a-zA-Z_][a-zA-Z_0-9]*\\s*\\(\\)?\\s*{' \"$script\")\n\n  local function_names\n  function_names=$(echo \"$filtered_lines\" | awk '{gsub(/\\(|\\)/, \"\"); print $2}')\n\n  local sorted_names\n  sorted_names=$(echo \"$function_names\" | sort)\n\n  local duplicates\n  duplicates=$(echo \"$sorted_names\" | uniq -d)\n  if [ -n \"$duplicates\" ]; then\n    state::set_duplicated_functions_merged \"$script\" \"$duplicates\"\n    return 1\n  fi\n}\n\n#\n# @param $1 string Eg: \"prefix\"\n# @param $2 string Eg: \"filter\"\n# @param $3 array Eg: \"[fn1, fn2, prefix_filter_fn3, fn4, ...]\"\n#\n# @return array Eg: \"[prefix_filter_fn3, ...]\" The filtered functions with prefix\n#\nfunction helper::get_functions_to_run() {\n  local prefix=$1\n  local filter=$2\n  local function_names=$3\n\n  local functions_to_run=()\n\n  for function_name in $function_names; do\n    if [[ $function_name != ${prefix}* ]]; then\n      continue\n    fi\n\n    local lower_case_function_name\n    lower_case_function_name=$(echo \"$function_name\" | tr '[:upper:]' '[:lower:]')\n    local lower_case_filter\n    lower_case_filter=$(echo \"$filter\" | tr '[:upper:]' '[:lower:]')\n\n    if [[ -n $filter && $lower_case_function_name != *\"$lower_case_filter\"* ]]; then\n      continue\n    fi\n\n    if [[ \"${functions_to_run[*]}\" =~ ${function_name} ]]; then\n      return 1\n    fi\n\n    functions_to_run+=(\"$function_name\")\n  done\n\n  echo \"${functions_to_run[@]}\"\n}\n\n#\n# @param $1 string Eg: \"do_something\"\n#\nfunction helper::execute_function_if_exists() {\n  local function_name=$1\n\n  if declare -F | awk '{print $3}' | grep -Eq \"^${function_name}$\"; then\n    \"$function_name\"\n  fi\n}\n\n#\n# @param $1 string Eg: \"do_something\"\n#\nfunction helper::unset_if_exists() {\n  local function_name=$1\n\n  if declare -F | awk '{print $3}' | grep -Eq \"^${function_name}$\"; then\n    unset \"$function_name\"\n  fi\n}\n\nfunction helper::find_files_recursive() {\n  local path=\"$1\"\n\n  if [[ \"$path\" == *\"*\"* ]]; then\n    eval find \"$path\" -type f -name '*[tT]est.sh' | sort | uniq\n  elif [[ -d \"$path\" ]]; then\n    find \"$path\" -type f -name '*[tT]est.sh' | sort | uniq\n  else\n    echo \"$path\"\n  fi\n}\n\nhelper::normalize_variable_name() {\n  local input_string=\"$1\"\n  local normalized_string\n\n  normalized_string=\"${input_string//[^a-zA-Z0-9_]/_}\"\n\n  if [[ ! $normalized_string =~ ^[a-zA-Z_] ]]; then\n    normalized_string=\"_$normalized_string\"\n  fi\n\n  echo \"$normalized_string\"\n}\n\nfunction helper::get_provider_data() {\n  local function_name=\"$1\"\n  local script=\"$2\"\n  local data_provider_function\n\n  if [[ ! -f \"$script\" ]]; then\n    return\n  fi\n\n  data_provider_function=$(\\\n    grep -B 1 \"function $function_name()\" \"$script\" |\\\n    grep \"# data_provider \" |\\\n    sed -E -e 's/\\ *# data_provider (.*)$/\\1/g'\\\n  )\n\n  if [[ -n \"$data_provider_function\" ]]; then\n    helper::execute_function_if_exists \"$data_provider_function\"\n  fi\n}\n\nfunction helper::trim() {\n    local input_string=\"$1\"\n    local trimmed_string\n\n    trimmed_string=\"${input_string#\"${input_string%%[![:space:]]*}\"}\"\n    trimmed_string=\"${trimmed_string%\"${trimmed_string##*[![:space:]]}\"}\"\n\n    echo \"$trimmed_string\"\n}\n#!/bin/bash\n\nfunction runner::load_test_files() {\n  local filter=$1\n  local files=(\"${@:2}\") # Store all arguments starting from the second as an array\n\n  if [[ \"${#files[@]}\" == 0 ]]; then\n    if [[ -n \"${DEFAULT_PATH}\" ]]; then\n      while IFS='' read -r line; do\n        files+=(\"$line\");\n      done < <(helper::find_files_recursive \"$DEFAULT_PATH\")\n    else\n      printf \"%sError: At least one file path is required.%s\\n\" \"${_COLOR_FAILED}\" \"${_COLOR_DEFAULT}\"\n      console_header::print_help\n      exit 1\n    fi\n  fi\n\n  for test_file in \"${files[@]}\"; do\n    if [[ ! -f $test_file ]]; then\n      continue\n    fi\n\n    # shellcheck source=/dev/null\n    source \"$test_file\"\n\n    runner::run_set_up_before_script\n    runner::call_test_functions \"$test_file\" \"$filter\"\n    if [ \"$PARALLEL_RUN\" = true ] ; then\n      wait\n    fi\n    runner::run_tear_down_after_script\n    runner::clean_set_up_and_tear_down_after_script\n  done\n}\n\nfunction runner::call_test_functions() {\n  local script=\"$1\"\n  local filter=\"$2\"\n  local prefix=\"test\"\n  # Use declare -F to list all function names\n  local function_names\n  function_names=$(declare -F | awk '{print $3}')\n  local functions_to_run\n  # shellcheck disable=SC2207\n  functions_to_run=($(helper::get_functions_to_run \"$prefix\" \"$filter\" \"$function_names\"))\n\n  if [[ \"${#functions_to_run[@]}\" -gt 0 ]]; then\n    if [[ \"$SIMPLE_OUTPUT\" == false ]]; then\n      echo \"Running $script\"\n    fi\n\n    helper::check_duplicate_functions \"$script\"\n\n    for function_name in \"${functions_to_run[@]}\"; do\n      local provider_data=()\n      IFS=\" \" read -r -a provider_data <<< \"$(helper::get_provider_data \"$function_name\" \"$script\")\"\n\n      if [[ \"${#provider_data[@]}\" -gt 0 ]]; then\n        for data in \"${provider_data[@]}\"; do\n          runner::run_test \"$function_name\" \"$data\"\n        done\n      else\n        runner::run_test \"$function_name\"\n      fi\n\n      unset \"$function_name\"\n    done\n  fi\n}\n\nfunction runner::parse_execution_result() {\n  local execution_result=$1\n\n  local assertions_failed\n  assertions_failed=$(\\\n    echo \"$execution_result\" |\\\n    tail -n 1 |\\\n    sed -E -e 's/.*##ASSERTIONS_FAILED=([0-9]*)##.*/\\1/g'\\\n  )\n\n  local assertions_passed\n  assertions_passed=$(\\\n    echo \"$execution_result\" |\\\n    tail -n 1 |\\\n    sed -E -e 's/.*##ASSERTIONS_PASSED=([0-9]*)##.*/\\1/g'\\\n  )\n\n  local assertions_skipped\n  assertions_skipped=$(\\\n    echo \"$execution_result\" |\\\n    tail -n 1 |\\\n    sed -E -e 's/.*##ASSERTIONS_SKIPPED=([0-9]*)##.*/\\1/g'\\\n  )\n\n  local assertions_incomplete\n  assertions_incomplete=$(\\\n    echo \"$execution_result\" |\\\n    tail -n 1 |\\\n    sed -E -e 's/.*##ASSERTIONS_INCOMPLETE=([0-9]*)##.*/\\1/g'\\\n  )\n\n  local assertions_snapshot\n  assertions_snapshot=$(\\\n    echo \"$execution_result\" |\\\n    tail -n 1 |\\\n    sed -E -e 's/.*##ASSERTIONS_SNAPSHOT=([0-9]*)##.*/\\1/g'\\\n  )\n\n  _ASSERTIONS_PASSED=$((_ASSERTIONS_PASSED + assertions_passed))\n  _ASSERTIONS_FAILED=$((_ASSERTIONS_FAILED + assertions_failed))\n  _ASSERTIONS_SKIPPED=$((_ASSERTIONS_SKIPPED + assertions_skipped))\n  _ASSERTIONS_INCOMPLETE=$((_ASSERTIONS_INCOMPLETE + assertions_incomplete))\n  _ASSERTIONS_SNAPSHOT=$((_ASSERTIONS_SNAPSHOT + assertions_snapshot))\n}\n\nfunction runner::run_test() {\n  local function_name=\"$1\"\n  local data=\"$2\"\n  local current_assertions_failed\n  current_assertions_failed=\"$(state::get_assertions_failed)\"\n  local current_assertions_snapshot\n  current_assertions_snapshot=\"$(state::get_assertions_snapshot)\"\n  local current_assertions_incomplete\n  current_assertions_incomplete=\"$(state::get_assertions_incomplete)\"\n  local current_assertions_skipped\n  current_assertions_skipped=\"$(state::get_assertions_skipped)\"\n\n  exec 3>&1\n\n  local test_execution_result\n  test_execution_result=$(\n    state::initialize_assertions_count\n    runner::run_set_up\n\n    \"$function_name\" \"$data\" 2>&1 1>&3\n\n    runner::run_tear_down\n    state::export_assertions_count\n  )\n\n  exec 3>&-\n\n  runner::parse_execution_result \"$test_execution_result\"\n\n  local runtime_error\n  runtime_error=$(\\\n    echo \"$test_execution_result\" |\\\n    head -n 1 |\\\n    sed -E -e 's/(.*)##ASSERTIONS_FAILED=.*/\\1/g'\\\n  )\n\n  if [[ -n $runtime_error ]]; then\n    state::add_tests_failed\n    console_results::print_error_test \"$function_name\" \"$runtime_error\"\n    return\n  fi\n\n  if [[ \"$current_assertions_failed\" != \"$(state::get_assertions_failed)\" ]]; then\n    state::add_tests_failed\n\n    if [ \"$STOP_ON_FAILURE\" = true ]; then\n      exit 1\n    fi\n\n    return\n  fi\n\n  if [[ \"$current_assertions_snapshot\" != \"$(state::get_assertions_snapshot)\" ]]; then\n    state::add_tests_snapshot\n    console_results::print_snapshot_test \"$function_name\"\n    return\n  fi\n\n  if [[ \"$current_assertions_incomplete\" != \"$(state::get_assertions_incomplete)\" ]]; then\n    state::add_tests_incomplete\n    return\n  fi\n\n  if [[ \"$current_assertions_skipped\" != \"$(state::get_assertions_skipped)\" ]]; then\n    state::add_tests_skipped\n    return\n  fi\n\n  local label\n  label=\"$(helper::normalize_test_function_name \"$function_name\")\"\n\n  console_results::print_successful_test \"${label}\" \"${data}\"\n  state::add_tests_passed\n}\n\nfunction runner::run_set_up() {\n  helper::execute_function_if_exists 'setUp' # Deprecated: please use set_up instead.\n  helper::execute_function_if_exists 'set_up'\n}\n\nfunction runner::run_set_up_before_script() {\n  helper::execute_function_if_exists 'setUpBeforeScript' # Deprecated: please use set_up_before_script instead.\n  helper::execute_function_if_exists 'set_up_before_script'\n}\n\nfunction runner::run_tear_down() {\n  helper::execute_function_if_exists 'tearDown' # Deprecated: please use tear_down instead.\n  helper::execute_function_if_exists 'tear_down'\n}\n\nfunction runner::run_tear_down_after_script() {\n  helper::execute_function_if_exists 'tearDownAfterScript' # Deprecated: please use tear_down_after_script instead.\n  helper::execute_function_if_exists 'tear_down_after_script'\n}\n\nfunction runner::clean_set_up_and_tear_down_after_script() {\n  helper::unset_if_exists 'setUp' # Deprecated: please use set_up instead.\n  helper::unset_if_exists 'set_up'\n  helper::unset_if_exists 'tearDown' # Deprecated: please use tear_down instead.\n  helper::unset_if_exists 'tear_down'\n  helper::unset_if_exists 'setUpBeforeScript' # Deprecated: please use set_up_before_script instead.\n  helper::unset_if_exists 'set_up_before_script'\n  helper::unset_if_exists 'tearDownAfterScript' # Deprecated: please use tear_down_after_script instead.\n  helper::unset_if_exists 'tear_down_after_script'\n}\n#!/bin/bash\n\nfunction skip() {\n  local reason=$1\n  local label\n  label=\"$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")\"\n\n  console_results::print_skipped_test \"${label}\" \"${reason}\"\n\n  state::add_assertions_skipped\n}\n\nfunction todo() {\n  local pending=$1\n  local label\n  label=\"$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")\"\n\n  console_results::print_incomplete_test \"${label}\" \"${pending}\"\n\n  state::add_assertions_incomplete\n}\n#!/bin/bash\n\n_TESTS_PASSED=0\n_TESTS_FAILED=0\n_TESTS_SKIPPED=0\n_TESTS_INCOMPLETE=0\n_TESTS_SNAPSHOT=0\n_ASSERTIONS_PASSED=0\n_ASSERTIONS_FAILED=0\n_ASSERTIONS_SKIPPED=0\n_ASSERTIONS_INCOMPLETE=0\n_ASSERTIONS_SNAPSHOT=0\n_DUPLICATED_FUNCTION_NAMES=\"\"\n_FILE_WITH_DUPLICATED_FUNCTION_NAMES=\"\"\n_DUPLICATED_TEST_FUNCTIONS_FOUND=false\n\nfunction state::get_tests_passed() {\n  echo \"$_TESTS_PASSED\"\n}\n\nfunction state::add_tests_passed() {\n  ((_TESTS_PASSED++)) || true\n}\n\nfunction state::get_tests_failed() {\n  echo \"$_TESTS_FAILED\"\n}\n\nfunction state::add_tests_failed() {\n  ((_TESTS_FAILED++)) || true\n}\n\nfunction state::get_tests_skipped() {\n  echo \"$_TESTS_SKIPPED\"\n}\n\nfunction state::add_tests_skipped() {\n  ((_TESTS_SKIPPED++)) || true\n}\n\nfunction state::get_tests_incomplete() {\n  echo \"$_TESTS_INCOMPLETE\"\n}\n\nfunction state::add_tests_incomplete() {\n  ((_TESTS_INCOMPLETE++)) || true\n}\n\nfunction state::get_tests_snapshot() {\n  echo \"$_TESTS_SNAPSHOT\"\n}\n\nfunction state::add_tests_snapshot() {\n  ((_TESTS_SNAPSHOT++)) || true\n}\n\nfunction state::get_assertions_passed() {\n  echo \"$_ASSERTIONS_PASSED\"\n}\n\nfunction state::add_assertions_passed() {\n  ((_ASSERTIONS_PASSED++)) || true\n}\n\nfunction state::get_assertions_failed() {\n  echo \"$_ASSERTIONS_FAILED\"\n}\n\nfunction state::add_assertions_failed() {\n  ((_ASSERTIONS_FAILED++)) || true\n}\n\nfunction state::get_assertions_skipped() {\n  echo \"$_ASSERTIONS_SKIPPED\"\n}\n\nfunction state::add_assertions_skipped() {\n  ((_ASSERTIONS_SKIPPED++)) || true\n}\n\nfunction state::get_assertions_incomplete() {\n  echo \"$_ASSERTIONS_INCOMPLETE\"\n}\n\nfunction state::add_assertions_incomplete() {\n  ((_ASSERTIONS_INCOMPLETE++)) || true\n}\n\nfunction state::get_assertions_snapshot() {\n  echo \"$_ASSERTIONS_SNAPSHOT\"\n}\n\nfunction state::add_assertions_snapshot() {\n  ((_ASSERTIONS_SNAPSHOT++)) || true\n}\n\nfunction state::is_duplicated_test_functions_found() {\n  echo \"$_DUPLICATED_TEST_FUNCTIONS_FOUND\"\n}\n\nfunction state::set_duplicated_test_functions_found() {\n  _DUPLICATED_TEST_FUNCTIONS_FOUND=true\n}\n\nfunction state::get_duplicated_function_names() {\n  echo \"$_DUPLICATED_FUNCTION_NAMES\"\n}\n\nfunction state::set_duplicated_function_names() {\n  _DUPLICATED_FUNCTION_NAMES=\"$1\"\n}\n\nfunction state::get_file_with_duplicated_function_names() {\n  echo \"$_FILE_WITH_DUPLICATED_FUNCTION_NAMES\"\n}\n\nfunction state::set_file_with_duplicated_function_names() {\n  _FILE_WITH_DUPLICATED_FUNCTION_NAMES=\"$1\"\n}\n\nfunction state::set_duplicated_functions_merged() {\n  state::set_duplicated_test_functions_found\n  state::set_file_with_duplicated_function_names \"$1\"\n  state::set_duplicated_function_names \"$2\"\n\n}\n\nfunction state::initialize_assertions_count() {\n    _ASSERTIONS_PASSED=0\n    _ASSERTIONS_FAILED=0\n    _ASSERTIONS_SKIPPED=0\n    _ASSERTIONS_INCOMPLETE=0\n    _ASSERTIONS_SNAPSHOT=0\n}\n\nfunction state::export_assertions_count() {\n  echo \"##ASSERTIONS_FAILED=$_ASSERTIONS_FAILED\\\n##ASSERTIONS_PASSED=$_ASSERTIONS_PASSED\\\n##ASSERTIONS_SKIPPED=$_ASSERTIONS_SKIPPED\\\n##ASSERTIONS_INCOMPLETE=$_ASSERTIONS_INCOMPLETE\\\n##ASSERTIONS_SNAPSHOT=$_ASSERTIONS_SNAPSHOT\\\n##\"\n}\n#!/bin/bash\n\nfunction mock() {\n  local command=$1\n  shift\n\n  if [[ $# -gt 0 ]]; then\n    eval \"function $command() { $* ; }\"\n  else\n    eval \"function $command() { echo \\\"$($CAT)\\\" ; }\"\n  fi\n\n  export -f \"${command?}\"\n}\n\nfunction spy() {\n  local command=$1\n  local variable\n  variable=\"$(helper::normalize_variable_name \"$command\")\"\n\n  export \"${variable}_times\"=0\n  export \"${variable}_params\"\n\n  eval \"function $command() { ${variable}_params=(\\\"\\$*\\\"); ((${variable}_times++)) || true; }\"\n\n  export -f \"${command?}\"\n}\n\nfunction assert_have_been_called() {\n  local command=$1\n  local variable\n  variable=\"$(helper::normalize_variable_name \"$command\")\"\n  local actual\n  actual=\"${variable}_times\"\n  local label=\"${2:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ ${!actual} -eq 0 ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${command}\" \"to has been called\" \"once\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_have_been_called_with() {\n  local expected=$1\n  local command=$2\n  local variable\n  variable=\"$(helper::normalize_variable_name \"$command\")\"\n  local actual\n  actual=\"${variable}_params\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ \"$expected\" != \"${!actual}\" ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${expected}\" \"but got\" \"${!actual}\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n\nfunction assert_have_been_called_times() {\n  local expected=$1\n  local command=$2\n  local variable\n  variable=\"$(helper::normalize_variable_name \"$command\")\"\n  local actual\n  actual=\"${variable}_times\"\n  local label=\"${3:-$(helper::normalize_test_function_name \"${FUNCNAME[1]}\")}\"\n\n  if [[ ${!actual} -ne $expected ]]; then\n    state::add_assertions_failed\n    console_results::print_failed_test \"${label}\" \"${command}\" \"to has been called\" \"${expected} times\"\n    return\n  fi\n\n  state::add_assertions_passed\n}\n#!/bin/bash\n\n# shellcheck disable=SC2034\ndeclare -r BASHUNIT_VERSION=\"0.10.1\"\n\nreadonly BASHUNIT_ROOT_DIR=\"$(dirname \"${BASH_SOURCE[0]}\")\"\nexport BASHUNIT_ROOT_DIR\n\n\n###############\n#### MAIN #####\n###############\n\n_FILTER=\"\"\n_FILES=()\n\nwhile [[ $# -gt 0 ]]; do\n  argument=\"$1\"\n  case $argument in\n    -f|--filter)\n      _FILTER=\"$2\"\n      shift\n      shift\n      ;;\n    -s|--simple)\n      SIMPLE_OUTPUT=true\n      shift\n      ;;\n    -v|--verbose)\n      SIMPLE_OUTPUT=false\n      shift\n      ;;\n    -S|--stop-on-failure)\n      STOP_ON_FAILURE=true\n      shift\n      ;;\n    -e|--env)\n      # shellcheck disable=SC1090\n      source \"$2\"\n      shift\n      shift\n      ;;\n    --version)\n      console_header::print_version\n      trap '' EXIT && exit 0\n      ;;\n    --help)\n      console_header::print_help\n      trap '' EXIT && exit 0\n      ;;\n    *)\n      while IFS='' read -r line; do\n        _FILES+=(\"$line\");\n      done < <(helper::find_files_recursive \"$argument\")\n      shift\n      ;;\n  esac\ndone\n\nconsole_header::print_version_with_env\nrunner::load_test_files \"$_FILTER\" \"${_FILES[@]}\"\nconsole_results::render_result\n\nexit 0\n",
  "/parseArger/utils/install": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"Install parseArger\" --option \"help\" --short-option \"h\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger opt shell-rc-file \"where to put the source directive\" --default-value \"$HOME/.bashrc\" --repeat --alias install-file\n# @parseArger flag comment \"add parsearger comment\" --on\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/utils\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n# OPTIONALS ARGUMENTS\n_arg_shell_rc_file=(\"$HOME/.bashrc\" )\n# FLAGS\n_arg_comment=\"on\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"Install parseArger:\"\n\techo -e \"\t--shell-rc-file|--install-file <shell-rc-file>: where to put the source directive, repeatable [default: '( $HOME/.bashrc )']\"\n\techo -e \"\t--comment|--no-comment: add parsearger comment, on by default (use --no-comment to turn it off)\"\n\techo -e \"Usage :\n\t$0 [--shell-rc-file <value>] [--[no-]comment]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--install-file|--shell-rc-file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_shell_rc_file+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--shell-rc-file=*)\n\t\t\t\t_arg_shell_rc_file+=(\"${_key##--shell-rc-file=}\")\n\t\t\t\t;;\n\t\t\t--install-file=*)\n\t\t\t\t_arg_shell_rc_file+=(\"${_key##--install-file=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--comment)\n\t\t\t\t_arg_comment=\"on\"\n\t\t\t\t;;\n\t\t\t--no-comment)\n\t\t\t\t_arg_comment=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"\"\n\tif [ \"${_positionals_count}\" -gt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 0 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 0 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"\";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\";\n\t\tlocal _regex=\"${!_match_var}\";\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\tshell-rc-file: ${_arg_shell_rc_file[*]}\";\n\techo -e \"\tcomment: ${_arg_comment}\";\n\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n_dir=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")/..\" && pwd -P)\"\noutput=\"\\nexport PARSEARGER_DIR=\\\"$_dir\\\"\nsource ${_dir}/parseArger.rc\";\n\nif [ \"$_arg_comment\" != \"off\" ]; then\n\toutput=\"\\n# parseArger${output}\";\nfi\n\nfor _file in \"${_arg_shell_rc_file[@]}\"; do\n\tif [ -f \"$_file\" ]; then\n\t\tif ! grep -q \"parseArger\" \"$_file\"; then\n\t\t\techo -e \"$output\" >> \"$_file\";\n\t\t\tlog \"parseArger installed in $_file\" 1;\n\t\telse\n\t\t\tlog \"parseArger already installed in $_file\" 1;\n\t\tfi\n\telse\n\t\tlog \"File $_file not found\" -1;\n\tfi\ndone\n",
  "/parseArger/utils/webserver": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"parsearger web server\" --option \"help\" --short-option \"h\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger opt port \"tcp port\" --default-value \"42069\"\n# @parseArger opt response-file \"which file to use for the response FIFO, mktemp if empty\"\n# @parseArger opt index-file \"index file\" --default-value \"index.html\"\n# @parseArger opt form-file \"html form file\" --default-value \"form.html\"\n# @parseArger opt form-url \"url to view form\" --default-value \"form\"\n# @parseArger opt submit-url \"form submit url\" --default-value \"form\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/utils\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n# OPTIONALS ARGUMENTS\n_arg_port=\"42069\"\n_arg_response_file=\n_arg_index_file=\"index.html\"\n_arg_form_file=\"form.html\"\n_arg_form_url=\"form\"\n_arg_submit_url=\"form\"\n# FLAGS\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"parsearger web server:\"\n\techo -e \"\t--port <port>: tcp port [default: ' 42069 ']\"\n\techo -e \"\t--response-file <response-file>: which file to use for the response FIFO, mktemp if empty\"\n\techo -e \"\t--index-file <index-file>: index file [default: ' index.html ']\"\n\techo -e \"\t--form-file <form-file>: html form file [default: ' form.html ']\"\n\techo -e \"\t--form-url <form-url>: url to view form [default: ' form ']\"\n\techo -e \"\t--submit-url <submit-url>: form submit url [default: ' form ']\"\n\techo -e \"Usage :\n\t$0 [--port <value>] [--response-file <value>] [--index-file <value>] [--form-file <value>] [--form-url <value>] [--submit-url <value>]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t--port)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_port=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--port=*)\n\t\t\t\t_arg_port=\"${_key##--port=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--response-file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_response_file=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--response-file=*)\n\t\t\t\t_arg_response_file=\"${_key##--response-file=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--index-file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_index_file=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--index-file=*)\n\t\t\t\t_arg_index_file=\"${_key##--index-file=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--form-file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_form_file=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--form-file=*)\n\t\t\t\t_arg_form_file=\"${_key##--form-file=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--form-url)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_form_url=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--form-url=*)\n\t\t\t\t_arg_form_url=\"${_key##--form-url=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--submit-url)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_submit_url=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--submit-url=*)\n\t\t\t\t_arg_submit_url=\"${_key##--submit-url=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"\"\n\tif [ \"${_positionals_count}\" -gt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 0 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 0 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"\";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\";\n\t\tlocal _regex=\"${!_match_var}\";\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\tport: ${_arg_port}\";\n\techo -e \"\tresponse-file: ${_arg_response_file}\";\n\techo -e \"\tindex-file: ${_arg_index_file}\";\n\techo -e \"\tform-file: ${_arg_form_file}\";\n\techo -e \"\tform-url: ${_arg_form_url}\";\n\techo -e \"\tsubmit-url: ${_arg_submit_url}\";\n\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\nfunction sendResponse () {\n\tlocal rcode=\"${4:-\"200\"}\";\n\tlocal __rc=$rcode;\n\tcase \"${rcode}\" in\n\t\t\"20\"*)\n\t\t\trcode+=\" OK\";\n\t\t;;\n\t\t\"30\"*)\n\t\t\trcode=\"$rcode Redirect\";\n\t\t;;\n\t\t\"401\")\n\t\t\trcode+=\" Unauthorized\";\n\t\t;;\n\t\t\"403\")\n\t\t\trcode+=\" Forbidden\";\n\t\t;;\n\t\t\"404\")\n\t\t\trcode+=\" Not Found\";\n\t\t;;\n\t\t\"405\")\n\t\t\trcode+=\" Method Not Allowed\";\n\t\t;;\n\t\t\"40\"*)\n\t\t\trcode=\"$rcode Client Error\";\n\t\t;;\n\t\t\"50\"*)\n\t\t\trcode=\"$rcode Server Error\";\n\t\t;;\n\t\t*)\n\t\t\trcode=\"500 Internal Server Error\";\n\t\t;;\n\tesac\n\t\n\tlocal content_length=$(echo -n \"$1\" | wc -c)\n\tlog \"\\t\\tcontent length $content_length\" 3;\n\tif [ \"$__rc\" -ge 400 ]; then\n\t\tlog \"\\tERROR $__rc\" -1;\n\tfi\n\techo -e \"HTTP/1.1 ${rcode}\\r\\nContent-Type: ${3:-\"text\"}/${2:-\"plain\"}\\r\\n\\r\\n$1\" > \"$_arg_response_file\"\n}\n\nfunction send404 () {\n\tlog \"\\t$1\" -1;\n\tsendResponse \"404 Not Found\" \"text\" \"plain\" 404;\n}\n\nfunction send200 () {\n\tsendResponse \"$1\" \"${2:-\"plain\"}\" \"${3:-\"text\"}\" 200;\n}\n\n# request regex\nrqre='(.*?)\\s(.*?)\\sHTTP.*?';\n# header regex\nhdre='^[A-Za-z0-9-]+:[[:space:]]';\n\nlast_headers_name=();\nlast_headers_value=();\n\nfunction handle_request () {\n\tlocal request;\n\tlocal method;\n\tlocal url;\n\tlocal content_type;\n\tlocal content_length;\n\tlocal body;\n\tlast_headers_name=();\n\tlast_headers_value=();\n\twhile read -r line; do\n\t\t__line=$(echo \"$line\" | tr -d '\\r\\n');\n\t\t[ -z \"$__line\" ] && break;\n\t\t# parsing request\n\t\tif [[ \"$__line\" =~ $rqre ]];then\n      request=$(echo \"$__line\" | sed -E \"s/$rqre/\\1 \\2/\");\n\t\t\tmethod=$(echo \"$request\" | awk '{print $1}');\n\t\t\turl=$(echo \"$request\" | awk '{print $2}');\n\t\telif [[ \"$__line\" =~ $hdre ]];then\n\t\t\theader_name=$(echo \"$__line\" | awk '{print $1}');\n\t\t\theader_value=$(echo \"$__line\" | awk '{print $2}');\n\t\t\tcase \"${header_name}\" in\n\t\t\t\t\"Content-Type:\")\n\t\t\t\t\tcontent_type=\"$header_value\";\n\t\t\t\t\tlast_headers_name+=(\"$header_name\");\n\t\t\t\t\tlast_headers_value+=(\"$header_value\");\n\t\t\t\t;;\n\t\t\t\t\"Content-Length:\")\n\t\t\t\t\tcontent_length=\"$header_value\";\n\t\t\t\t\tlast_headers_name+=(\"$header_name\");\n\t\t\t\t\tlast_headers_value+=(\"$header_value\");\n\t\t\t\t;;\n\t\t\t\t*)\n\t\t\t\t\tlast_headers_name+=(\"$header_name\");\n\t\t\t\t\tlast_headers_value+=(\"$header_value\");\n\t\t\t\t;;\n\t\t\tesac\n\t\tfi\n\t\t__line=$(echo \"$__line\" | tr -d '\\r\\n');\n\t\t[ -z \"$__line\" ] && break;\n\tdone\n\n\t# body\n  if [ \"$content_length\" != \"\" ]; then\n    bdre='(.*?)=(.*?)'\n    while read -r -n$content_length -t1 line; do\n      __line=$(echo \"$line\" | tr -d '\\r\\n')\n\n      [ -z \"$__line\" ] && break\n\n      read -r -a body <<< \"$(echo \"$__line\" | sed -E \"s/$bdre/\\1 \\2/\")\"\n    done\n  fi\n\n\t# uri segments\n\tIFS='?' read -r -a uri_segments <<< \"$url\"\n\tIFS='/' read -r -a uri_segments <<< \"${uri_segments[0]}\"\n\n\t# query string args\n\tdeclare -A query_args;\n\tIFS='?' read -r -a tqsas <<< \"$url\"\n\tIFS='&' read -r -a tqsas <<< \"${tqsas[1]}\"\n\tfor i in \"${tqsas[@]}\"; do\n\t\tIFS='=' read -r -a query_string_arg <<< \"$i\"\n\t\tlocal __argname=\"${query_string_arg[0]}\";\n\t\tlocal __argvalue=\"${query_string_arg[1]}\";\n\t\tlocal __existing=\"${query_args[\"$__argname\"]}\";\n\t\t# bash no support for arrays in associative arrays hackfix\n\t\tif [ \"$__existing\" != \"\" ]; then\n\t\t\tquery_args[\"$__argname\"]+=\" :: $__argvalue\"\n\t\telse\n\t\t\tquery_args[\"$__argname\"]=\"$__argvalue\"\n\t\tfi\n\tdone\n\n\tif [ \"$request\" != \"\" ]; then\n\t\tlog \"$request\" 2;\n\t\tif [ \"$method\" != \"\" ] && [ \"$url\" != \"\" ]; then\n\t\t\tlog \"Handling request: \" 3;\n\t\t\tlog \"$(date +%FT%T%z) $method $url\" 0;\n\t\t\tcase \"$method $url\" in\n\t\t\t\t\"GET /index\"|\"GET /\"|\"GET \")\n\t\t\t\t\tif [ -f \"$_arg_index_file\" ]; then\n\t\t\t\t\t\tsend200 \"$(cat \"$_arg_index_file\")\" \"html\";\n\t\t\t\t\telse\n\t\t\t\t\t\tsend404 \"$_arg_index_file\";\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\"GET /$_arg_form_url\")\n\t\t\t\t\tif [ -f \"$_arg_form_file\" ]; then\n\t\t\t\t\t\tsend200 \"$(cat \"$_arg_form_file\")\" \"html\";\n\t\t\t\t\telse\n\t\t\t\t\t\tsend404 \"$_arg_form_file\";\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\"POST /$_arg_submit_url\")\n\t\t\t\t\tapiCmd=(\"$(realpath \"$_SCRIPT_DIR/../parseArger\")\" \"${body[@]}\");\n\t\t\t\t\tlog \"Running: \" 2;\n\t\t\t\t\tlog \"\\t${apiCmd[*]}\" 0;\n\t\t\t\t\t__output=$(\"${apiCmd[@]}\" 2>&1);\n\t\t\t\t\tif [ $? -eq 0 ]; then\n\t\t\t\t\t\tsend200 \"$__output\";\n\t\t\t\t\telse\n\t\t\t\t\t\tsendResponse \"$__output\" \"plain\" \"text\" 500;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\"GET /$_arg_submit_url/\"*)\n\t\t\t\t\tapiCmd=(\"$_SCRIPT_DIR/../parseArger\");\n\t\t\t\t\t\n\t\t\t\t\tif [ \"${#uri_segments[@]}\" -gt 2 ]; then\n\t\t\t\t\t\tfor i in \"${!uri_segments[@]}\"; do\n\t\t\t\t\t\t\tif [ \"$i\" -gt 1 ] && [ \"$i\" -lt \"${#uri_segments[@]}\" ]; then\n\t\t\t\t\t\t\t\tapiCmd+=( \"${uri_segments[$i]}\" );\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\tdone\n\t\t\t\t\tfi\n\n\t\t\t\t\tfor i in \"${!query_args[@]}\"; do\n\t\t\t\t\t\tIFS=\" :: \" read -r -a tmpi <<< \"${query_args[$i]}\";\n\t\t\t\t\t\tif [ \"${#tmpi[@]}\" -gt 1 ]; then\n\t\t\t\t\t\t\tfor _ti in \"${tmpi[@]}\"; do\n\t\t\t\t\t\t\t\t[ \"$_ti\" != \"\" ] && apiCmd+=( \"--$(printf '%b' \"${i//%/\\\\x}\")\" \"$(printf '%b' \"${_ti//%/\\\\x}\")\" );\n\t\t\t\t\t\t\tdone\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tapiCmd+=( \"--$(printf '%b' \"${i//%/\\\\x}\")\" \"$(printf '%b' \"${query_args[$i]//%/\\\\x}\")\" );\n\t\t\t\t\t\tfi\n\t\t\t\t\tdone\n\t\t\t\t\t\n\t\t\t\t\tlog \"${apiCmd[*]}\" 0;\n\t\t\t\t\t__output=$(\"${apiCmd[@]}\" 2>&1);\n\t\t\t\t\tif [ $? -eq 0 ]; then\n\t\t\t\t\t\tsend200 \"$__output\";\n\t\t\t\t\telse\n\t\t\t\t\t\tsendResponse \"$__output\" \"plain\" \"text\" 500;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t# Set your custom routes here\n\t\t\t\t# \"GET /my/route\")\n\t\t\t\t# \tsend200 \"Hello World!\";\n\t\t\t\t# \t;;\n\t\t\t\t# serve content statically\n\t\t\t\t# \"GET /my/route\")\n\t\t\t\t#\t\t# remove /my/route/ from url to match file path\n\t\t\t\t#\t\ttrm=\"/my/route/\";\n\t\t\t\t#\t\tlocal file_path=\"/path/to/static/folder/${url//$trm/}\";\n\t\t\t\t#\t\tif [ -f \"$file_path\" ]; then\n\t\t\t\t#\t\t\tlocal ext=\"${file_path##*.}\";\n\t\t\t\t#\t\t\tsend200 \"$(cat \"$file_path\")\" \"$ext\";\n\t\t\t\t#\t\telse\n\t\t\t\t#\t\t\tsend404 \"$method $url\";\n\t\t\t\t#\t\tfi\n\t\t\t\t# \tsend200 \"Hello World!\";\n\t\t\t\t# \t;;\n\t\t\t\t*)\n\t\t\t\t\tsend404 \"$method $url\";\n\t\t\t\t\t;;\n\t\t\tesac\n\t\tfi\n\tfi\n}\n\nif [ \"$_arg_response_file\" == \"\" ]; then\n\t_arg_response_file=\"$(mktemp)\";\nfi\n\nif [ -f \"$_arg_response_file\" ]; then\n\trm -f \"$_arg_response_file\";\nfi\nlog \"Creating response file: $_arg_response_file\" 1;\nmkfifo \"$_arg_response_file\";\n\nlog \"Listening on port: $_arg_port\" 0;\nwhile true; do\n\tcat \"$_arg_response_file\" | nc -l \"$_arg_port\" | handle_request;\ndone\n",
  "/parseArger/utils/get_parseArger": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"get parseArger\" --option \"help\" --short-option \"h\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger opt branch \"version to install\" --short b --alias tag --alias install-version\n# @parseArger opt install-directory \"where to install\" --complete \"directory\"\n# @parseArger opt install-file \"rc files to install to, forces install\" --repeat\n# @parseArger flag install \"install in bashrc\" --short i\n# @parseArger flag remove-installer \"remove install script itself\" --alias rm\n# @parseArger flag ssh \"clone using ssh\"\n# @parseArger flag zip \"install using zip archive, not recommended\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/utils\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n# OPTIONALS ARGUMENTS\n_arg_branch=\n_arg_install_directory=\n_arg_install_file=()\n# FLAGS\n_arg_install=\"off\"\n_arg_remove_installer=\"off\"\n_arg_ssh=\"off\"\n_arg_zip=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"get parseArger:\"\n\techo -e \"\t-b, --branch|--tag|--install-version <branch>: version to install\"\n\techo -e \"\t--install-directory <install-directory>: where to install\"\n\techo -e \"\t--install-file <install-file>: rc files to install to, forces install, repeatable\"\n\techo -e \"\t-i|--install|--no-install: install in bashrc\"\n\techo -e \"\t--remove-installer|--no-remove-installer: remove install script itself\n\t\taliases: --rm,\"\n\techo -e \"\t--ssh|--no-ssh: clone using ssh\"\n\techo -e \"\t--zip|--no-zip: install using zip archive, not recommended\"\n\techo -e \"Usage :\n\t$0 [--branch <value>] [--install-directory <value>] [--install-file <value>] [--[no-]install] [--[no-]remove-installer] [--[no-]ssh] [--[no-]zip]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t-b|--install-version|--tag|--branch)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_branch=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--branch=*)\n\t\t\t\t_arg_branch=\"${_key##--branch=}\"\n\t\t\t\t;;\n\t\t\t--tag=*)\n\t\t\t\t_arg_branch=\"${_key##--tag=}\"\n\t\t\t\t;;\n\t\t\t--install-version=*)\n\t\t\t\t_arg_branch=\"${_key##--install-version=}\"\n\t\t\t\t;;\n\t\t\t-b*)\n\t\t\t\t_arg_branch=\"${_key##-b}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--install-directory)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_install_directory=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--install-directory=*)\n\t\t\t\t_arg_install_directory=\"${_key##--install-directory=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--install-file)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_install_file+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--install-file=*)\n\t\t\t\t_arg_install_file+=(\"${_key##--install-file=}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-i|--install)\n\t\t\t\t_arg_install=\"on\"\n\t\t\t\t;;\n\t\t\t--no-install)\n\t\t\t\t_arg_install=\"off\"\n\t\t\t\t;;\n\t\t\t--remove-installer|--rm)\n\t\t\t\t_arg_remove_installer=\"on\"\n\t\t\t\t;;\n\t\t\t--no-remove-installer)\n\t\t\t\t_arg_remove_installer=\"off\"\n\t\t\t\t;;\n\t\t\t--ssh)\n\t\t\t\t_arg_ssh=\"on\"\n\t\t\t\t;;\n\t\t\t--no-ssh)\n\t\t\t\t_arg_ssh=\"off\"\n\t\t\t\t;;\n\t\t\t--zip)\n\t\t\t\t_arg_zip=\"on\"\n\t\t\t\t;;\n\t\t\t--no-zip)\n\t\t\t\t_arg_zip=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"\"\n\tif [ \"${_positionals_count}\" -gt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 0 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 0 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"\";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\";\n\t\tlocal _regex=\"${!_match_var}\";\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\tbranch: ${_arg_branch}\";\n\techo -e \"\tinstall-directory: ${_arg_install_directory}\";\n\techo -e \"\tinstall-file: ${_arg_install_file[*]}\";\n\techo -e \"\tinstall: ${_arg_install}\";\n\techo -e \"\tremove-installer: ${_arg_remove_installer}\";\n\techo -e \"\tssh: ${_arg_ssh}\";\n\techo -e \"\tzip: ${_arg_zip}\";\n\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\necmd=();\nmcmd=(chmod \"+x\" \"-R\");\nif [ \"$_arg_zip\" != \"on\" ] && [ \"$(command -v git)\" ]; then\n\tecmd+=(git clone);\n\n\tif [ \"$_arg_ssh\" == \"on\" ]; then\n\t\tecmd+=(\"git@github.com:DimitriGilbert/parseArger.git\");\n\telse\n\t\tecmd+=(\"https://github.com/DimitriGilbert/parseArger.git\");\n\tfi\n\n\tif [ \"$_arg_branch\" != \"\" ]; then\n\t\tecmd+=(-b \"$_arg_branch\");\n\tfi\n\n\tif [ \"$_arg_install_directory\" != \"\" ]; then\n\t\tecmd+=(\"$_arg_install_directory\");\n\t\tmcmd+=(\"$_arg_install_directory/parseArger\" \"$_arg_install_directory/utils\" \"$_arg_install_directory/bin\");\n\telse\n\t\tmcmd+=(\"parseArger/parseArger\" \"parseArger/utils\" \"parseArger/bin\");\n\tfi\nelse\n\tif [ \"$_arg_branch\" == \"\" ]; then\n\t\t_arg_branch=\"main\";\n\tfi\n\t_arg_zip=\"on\";\n\tlog \"Install using zip, it is not recommended\" -1;\n\tecmd+=(curl \"https://github.com/DimitriGilbert/parseArger/archive/refs/heads/${_arg_branch}.zip\" -LJO);\n\tzcmd=(unzip -qq);\n\tzcmd2=(mv);\n\n\tif [ \"$_arg_install_directory\" != \"\" ]; then\n\t\tzcmd+=(-d \"/tmp\");\n\t\tmcmd+=(\"$_arg_install_directory/parseArger\" \"$_arg_install_directory/utils\" \"$_arg_install_directory/bin\");\n\t\tzcmd2+=(\"/tmp/parseArger-${_arg_branch}\" \"$_arg_install_directory\");\n\telse\n\t\tmcmd+=(\"parseArger/parseArger\" \"parseArger/utils\" \"parseArger/bin\");\n\t\tzcmd2+=(\"parseArger-${_arg_branch}\" \"parseArger\");\n\tfi\n\tzcmd+=( \"parseArger-${_arg_branch}.zip\" );\nfi\n\nlog \"${ecmd[*]}\" 1;\n\"${ecmd[@]}\"\n\nif [ \"$_arg_zip\" == \"on\" ]; then\n\tlog \"${zcmd[*]}\" 1;\n\t\"${zcmd[@]}\";\n\tlog \"${zcmd2[*]}\" 1;\n\t\"${zcmd2[@]}\";\n\trm \"parseArger-${_arg_branch}.zip\";\nfi\n\nlog \"${mcmd[*]}\" 1;\n\"${mcmd[@]}\"\n\nif [ \"$_arg_install\" == \"on\" ] || [ \"${#_arg_install_file[@]}\" -gt 0 ]; then\n\ticmd=(\"utils/install\" --verbose 1);\n\tif [ \"${#_arg_install_file[@]}\" -gt 0 ]; then\n\t\tfor ifile in \"${_arg_install_file[@]}\"; do\n\t\t\ticmd+=(\"--shell-rc-file\" \"$ifile\");\n\t\tdone\n\tfi\n\tlog \"${icmd[*]}\" 1;\n\n\tif [ \"$_arg_install_directory\" != \"\" ]; then\n\t\tcd \"${_arg_install_directory}\";\n\telse\n\t\tcd parseArger;\n\tfi\n\t\"${icmd[@]}\";\n\tcd -;\nfi\n",
  "/parseArger/utils/get_skills": "#!/bin/bash\n# @parseArger-begin\n# @parseArger-help \"Fetch and install Agent Skills from a repository\" --option \"help\" --short-option \"h\"\n# @parseArger-verbose --option \"verbose\" --level \"0\" --quiet-option \"quiet\"\n_has_colors=0\nif [ -t 1 ]; then # Check if stdout is a terminal\n\tncolors=$(tput colors 2>/dev/null)\n\tif [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n\t\t_has_colors=1\n\tfi\nfi\n# @parseArger-declarations\n# @parseArger opt install \"Install target (claude, opencode, or path)\" --short i --repeat\n# @parseArger opt repo \"Source repository URL\" --default-value \"https://github.com/DimitriGilbert/parseArger\"\n# @parseArger opt branch \"Source branch\" --default-value \"main\"\n# @parseArger opt skill \"Specific skill to install\" --short s --repeat\n# @parseArger flag force \"Overwrite existing skills\" --short f\n# @parseArger flag list \"List available skills in remote repo\"\n# @parseArger-declarations-end\n\n# @parseArger-utils\n_helpHasBeenPrinted=1;\n_SCRIPT_DIR=\"\"/parseArger/utils\"\";\n# @parseArger-utils-end\n\n# @parseArger-parsing\n\n__cli_arg_count=$#;\n\ndie()\n{\n\tlocal _ret=1\n    if [[ -n \"$2\" ]] && [[ \"$2\" =~ ^[0-9]+$ ]]; then\n   \t_ret=\"$2\"\n    fi\n\ttest \"${_PRINT_HELP:-no}\" = yes && print_help >&2\n\tlog \"$1\" -3 >&2\n\texit \"${_ret}\"\n}\n\n\nbegins_with_short_option()\n{\n\tlocal first_option all_short_options=''\n\tfirst_option=\"${1:0:1}\"\n\ttest \"$all_short_options\" = \"${all_short_options/$first_option/}\" && return 1 || return 0\n}\n\n# POSITIONALS ARGUMENTS\n_positionals=();\n_optional_positionals=();\n# OPTIONALS ARGUMENTS\n_arg_install=()\n_arg_repo=\"https://github.com/DimitriGilbert/parseArger\"\n_arg_branch=\"main\"\n_arg_skill=()\n# FLAGS\n_arg_force=\"off\"\n_arg_list=\"off\"\n# NESTED\n_verbose_level=\"0\";\n\n\n\nprint_help()\n{\n\t_triggerSCHelp=1;\n\n\tif [[ \"$_helpHasBeenPrinted\" == \"1\" ]]; then\n\t\t_helpHasBeenPrinted=0;\n\t\techo -e \"Fetch and install Agent Skills from a repository:\"\n\techo -e \"\t-i, --install <install>: Install target (claude, opencode, or path), repeatable\"\n\techo -e \"\t--repo <repo>: Source repository URL [default: ' https://github.com/DimitriGilbert/parseArger ']\"\n\techo -e \"\t--branch <branch>: Source branch [default: ' main ']\"\n\techo -e \"\t-s, --skill <skill>: Specific skill to install, repeatable\"\n\techo -e \"\t-f|--force|--no-force: Overwrite existing skills\"\n\techo -e \"\t--list|--no-list: List available skills in remote repo\"\n\techo -e \"Usage :\n\t$0 [--install <value>] [--repo <value>] [--branch <value>] [--skill <value>] [--[no-]force] [--[no-]list]\";\n\tfi\n\n}\n\nlog() {\n\tlocal _arg_msg=\"${1}\";\n\tlocal _arg_level=\"${2:-0}\";\n\tif [ \"${_arg_level}\" -le \"${_verbose_level}\" ]; then\n\t\tcase \"$_arg_level\" in\n\t\t\t-3)\n\t\t\t\t_arg_COLOR=\"\\033[0;31m\";\n\t\t\t\t;;\n\t\t\t-2)\n\t\t\t\t_arg_COLOR=\"\\033[0;33m\";\n\t\t\t\t;;\n\t\t\t-1)\n\t\t\t\t_arg_COLOR=\"\\033[1;33m\";\n\t\t\t\t;;\n\t\t\t1)\n\t\t\t\t_arg_COLOR=\"\\033[0;32m\";\n\t\t\t\t;;\n\t\t\t2)\n\t\t\t\t_arg_COLOR=\"\\033[1;36m\";\n\t\t\t\t;;\n\t\t\t3)\n\t\t\t\t_arg_COLOR=\"\\033[0;36m\";\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\t_arg_COLOR=\"\\033[0m\";\n\t\t\t\t;;\n\t\tesac\n\t\tif [ \"${_has_colors}\" == \"1\" ]; then\n\t\t\techo -e \"${_arg_COLOR}${_arg_msg}\\033[0m\";\n\t\telse\n\t\t\techo \"${_arg_msg}\";\n\t\tfi\n\tfi\n}\n\nparse_commandline()\n{\n\t_positionals_count=0\n\twhile test $# -gt 0\n\tdo\n\t\t_key=\"$1\"\n\t\tcase \"$_key\" in\n\t\t\t-i|--install)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_install+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--install=*)\n\t\t\t\t_arg_install+=(\"${_key##--install=}\")\n\t\t\t\t;;\n\t\t\t-i*)\n\t\t\t\t_arg_install+=(\"${_key##-i}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t--repo)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_repo=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--repo=*)\n\t\t\t\t_arg_repo=\"${_key##--repo=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t--branch)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_branch=\"$2\"\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--branch=*)\n\t\t\t\t_arg_branch=\"${_key##--branch=}\"\n\t\t\t\t;;\n\t\t\t\n\t\t\t-s|--skill)\n\t\t\t\ttest $# -lt 2 && die \"Missing value for the option: '$_key'\" 1\n\t\t\t\t_arg_skill+=(\"$2\")\n\t\t\t\tshift\n\t\t\t\t;;\n\t\t\t--skill=*)\n\t\t\t\t_arg_skill+=(\"${_key##--skill=}\")\n\t\t\t\t;;\n\t\t\t-s*)\n\t\t\t\t_arg_skill+=(\"${_key##-s}\")\n\t\t\t\t;;\n\t\t\t\n\t\t\t-f|--force)\n\t\t\t\t_arg_force=\"on\"\n\t\t\t\t;;\n\t\t\t--no-force)\n\t\t\t\t_arg_force=\"off\"\n\t\t\t\t;;\n\t\t\t--list)\n\t\t\t\t_arg_list=\"on\"\n\t\t\t\t;;\n\t\t\t--no-list)\n\t\t\t\t_arg_list=\"off\"\n\t\t\t\t;;\n\t\t\t-h|--help)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t-h*)\n\t\t\t\tprint_help;\n\t\t\t\texit 0;\n\t\t\t\t;;\n\t\t\t--verbose)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level + 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t--quiet)\n\t\t\t\t\tif [ $# -lt 2 ];then\n\t\t\t\t\t\t_verbose_level=\"$((_verbose_level - 1))\";\n\t\t\t\t\telse\n\t\t\t\t\t\t_verbose_level=\"-$2\";\n\t\t\t\t\t\tshift;\n\t\t\t\t\tfi\n\t\t\t\t\t;;\n\t\t\t\t\n\t\t\t\t*)\n\t\t\t\t_last_positional=\"$1\"\n\t\t\t\t_positionals+=(\"$_last_positional\")\n\t\t\t\t_positionals_count=$((_positionals_count + 1))\n\t\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n\nhandle_passed_args_count()\n{\n\tlocal _required_args_string=\"\"\n\tif [ \"${_positionals_count}\" -gt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: There were spurious positional arguments --- we expect at most 0 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}').\\n\\t${_positionals[*]}\" 1\n\tfi\n\tif [ \"${_positionals_count}\" -lt 0 ] && [ \"$_helpHasBeenPrinted\" == \"1\" ];then\n\t\t_PRINT_HELP=yes die \"FATAL ERROR: Not enough positional arguments - we require at least 0 (namely: $_required_args_string), but got only ${_positionals_count}.\n\t${_positionals[*]}\" 1;\n\tfi\n}\n\n\nassign_positional_args()\n{\n\tlocal _positional_name _shift_for=$1;\n\t_positional_names=\"\";\n\tshift \"$_shift_for\"\n\tfor _positional_name in ${_positional_names};do\n\t\ttest $# -gt 0 || break;\n\t\teval \"if [ \\\"\\$_one_of${_positional_name}\\\" != \\\"\\\" ];then [[ \\\"\\${_one_of${_positional_name}[*]}\\\" =~ \\\"\\${1}\\\" ]];fi\" || die \"${_positional_name} must be one of: $(eval \"echo \\\"\\${_one_of${_positional_name}[*]}\\\"\")\" 1;\n\t\tlocal _match_var=\"_match${_positional_name}\";\n\t\tlocal _regex=\"${!_match_var}\";\n\t\tif [ -n \"$_regex\" ]; then\n\t\t\t[[ \"${1}\" =~ $_regex ]] || die \"${_positional_name} does not match pattern: $_regex\"\n\t\tfi\n\t\teval \"$_positional_name=\\${1}\" || die \"Error during argument parsing, possibly an ParseArger bug.\" 1;\n\t\tshift;\n\tdone\n}\n\nprint_debug()\n{\n\tprint_help\n\t# shellcheck disable=SC2145\n\techo \"DEBUG: $0 $@\";\n\t\n\techo -e \"\tinstall: ${_arg_install[*]}\";\n\techo -e \"\trepo: ${_arg_repo}\";\n\techo -e \"\tbranch: ${_arg_branch}\";\n\techo -e \"\tskill: ${_arg_skill[*]}\";\n\techo -e \"\tforce: ${_arg_force}\";\n\techo -e \"\tlist: ${_arg_list}\";\n\n}\n\n\non_interrupt() {\n\tdie Process aborted! 130;\n}\n\n\nparse_commandline \"$@\";\nhandle_passed_args_count;\nassign_positional_args 1 \"${_positionals[@]}\";\n# trap on_interrupt INT; # Disabled for just-bash compatibility\n# @parseArger-parsing-end\n# print_debug \"$@\"\n# @parseArger-end\n\n# Logic Implementation\n\n# 1. Determine Install Paths\ninstall_paths=()\n\nfor target in \"${_arg_install[@]}\"; do\n    case \"$target\" in\n        \"claude\")\n            if [[ \"$OSTYPE\" == \"darwin\"* ]]; then\n                install_paths+=(\"$HOME/Library/Application Support/Claude/skills\")\n            else\n                install_paths+=(\"$HOME/.config/claude/skills\")\n            fi\n            ;;\n        \"opencode\")\n            install_paths+=(\"$HOME/.opencode/skills\")\n            ;;\n        *)\n            # Treat as path\n            install_paths+=(\"$target\")\n            ;;\n    esac\ndone\n\n# If no install paths and not listing, default to current dir or error?\n# Let's verify we have something to do unless listing.\nif [ \"${#install_paths[@]}\" -eq 0 ] && [ \"$_arg_list\" == \"off\" ]; then\n    die \"No install target specified. Use --install [claude|opencode|path] or --list.\" 1\nfi\n\nlog \"Preparing to fetch skills from $_arg_repo (branch: $_arg_branch)...\"\n\n# 2. Fetch Repo\ntmp_dir=$(mktemp -d)\ntrap 'rm -rf \"$tmp_dir\"' EXIT\n\nif [ -d \"$_arg_repo\" ]; then\n    log \"Repo is local directory.\"\n    cp -r \"$_arg_repo/skills\" \"$tmp_dir/\" 2>/dev/null || die \"Could not find 'skills' directory in $_arg_repo\" 1\nelse\n    log \"Cloning remote repository...\"\n    git clone --quiet --depth 1 --branch \"$_arg_branch\" \"$_arg_repo\" \"$tmp_dir/repo\" || die \"Failed to clone repository\" 1\n    if [ -d \"$tmp_dir/repo/skills\" ]; then\n        mv \"$tmp_dir/repo/skills\" \"$tmp_dir/skills\"\n    else\n        die \"Repository does not contain a 'skills' directory.\" 1\n    fi\nfi\n\n# 3. List Mode\nif [ \"$_arg_list\" == \"on\" ]; then\n    echo \"Available skills in $_arg_repo:\"\n    if [ -d \"$tmp_dir/skills\" ]; then\n        for skill in \"$tmp_dir/skills\"/*; do\n            if [ -d \"$skill\" ]; then\n                echo \" - $(basename \"$skill\")\"\n            fi\n        done\n    else\n        echo \"No skills found.\"\n    fi\n    exit 0\nfi\n\n# 4. Install Skills\nskills_to_install=()\nif [ \"${#_arg_skill[@]}\" -gt 0 ]; then\n    skills_to_install=(\"${_arg_skill[@]}\")\nelse\n    # Install all found skills\n    for skill_path in \"$tmp_dir/skills\"/*; do\n        if [ -d \"$skill_path\" ]; then\n            skills_to_install+=(\"$(basename \"$skill_path\")\")\n        fi\n    done\nfi\n\nlog \"Found ${#skills_to_install[@]} skills to install.\"\n\nfor dest_path in \"${install_paths[@]}\"; do\n    log \"Installing to: $dest_path\"\n    mkdir -p \"$dest_path\" || die \"Failed to create directory $dest_path\" 1\n\n    for skill_name in \"${skills_to_install[@]}\"; do\n        source_skill=\"$tmp_dir/skills/$skill_name\"\n        dest_skill=\"$dest_path/$skill_name\"\n\n        if [ ! -d \"$source_skill\" ]; then\n            log \"Warning: Skill '$skill_name' not found in source. Skipping.\" -2\n            continue\n        fi\n\n        if [ -d \"$dest_skill\" ]; then\n            if [ \"$_arg_force\" == \"on\" ]; then\n                log \"Overwriting existing skill: $skill_name\"\n                rm -rf \"$dest_skill\"\n            else\n                log \"Skill '$skill_name' already exists. Use --force to overwrite. Skipping.\" -1\n                continue\n            fi\n        fi\n\n        log \"Installing $skill_name...\"\n        cp -r \"$source_skill\" \"$dest_skill\" || log \"Failed to copy $skill_name\" -3\n    done\ndone\n\nlog \"Done.\"\n"
};
